<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2F2018%2F11%2F27%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、工厂模式介绍1.工厂模式的定义“Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.”(在基类中定义创建对象的一个接口，让子类决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。) 2.工厂模式的分类： 简单工厂（Simple Factory）模式，又称静态工厂方法模式（Static Factory Method Pattern）。 工厂方法（Factory Method）模式，又称多态性工厂（Polymorphic Factory）模式或虚拟构造子（Virtual Constructor）模式。 抽象工厂（Abstract Factory）模式，又称工具箱（Kit 或 Toolkit）模式。 3.为什么要用工厂模式 解耦 ：把对象的创建和使用的过程分开 降低代码重复: 如果创建某个对象的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码 降低维护成本 ：由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需要创建对象B的地方去逐个修正，只需要在工厂里修改即可，降低维护成本 二、简单工厂模式1.介绍严格的说，简单工厂模式并不是23种常用的设计模式之一，它只算工厂模式的一个特殊实现。简单工厂模式在实际中的应用相对于其他2个工厂模式用的还是相对少得多，因为它只适应很多简单的情况。 最重要的是它违背了我们在概述中说的 开放-封闭原则 （虽然可以通过反射的机制来避免，后面我们会介绍到） 。因为每次你要新添加一个功能，都需要在生 switch-case 语句（或者 if-else 语句）中去修改代码，添加分支条件。 2.适用场景 需要创建的对象较少 客户端不关心对象的创建过程 3.简单工厂模式角色分配 工厂(Factory)角色:简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。 抽象产品(Product)角色: 简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 具体产品(Concrete Product)角色:简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。 4.简单工厂实例创建一个可以绘制不同形状的绘图工具，可以绘制圆形，正方形，三角形，每个图形都会有一个draw()方法用于绘图. 1. 创建 Shape 接口 123public interface Shape &#123; void draw();&#125; 2. 创建实现该接口的具体图形类 圆形 1234567891011public class Circle implements Shape &#123; public Circle() &#123; System.out.println("Circle"); &#125; @Override public void draw() &#123; System.out.println("Draw a Circle"); &#125;&#125; 长方形 1234567891011public class Rectangle implements Shape&#123; public Rectangle() &#123; System.out.println("Rectangle"); &#125; @Override public void draw() &#123; System.out.println("Draw a Rectangle"); &#125;&#125; 正方形 1234567891011public class Square implements Shape &#123; public Square() &#123; System.out.println("Square"); &#125; @Override public void draw() &#123; System.out.println("Draw a Square"); &#125;&#125; 3. 创建工厂类 123456789101112131415161718public class ShapeFactory &#123; public static Shape getShape(String shapType)&#123; if (shapType == null)&#123; return null; &#125; if (shapType.equalsIgnoreCase("CIRCLE"))&#123; return new Circle(); &#125;else if (shapType.equalsIgnoreCase("RECTANGLE"))&#123; return new Rectangle(); &#125;else if (shapType.equalsIgnoreCase("SQUARE"))&#123; return new Square(); &#125; return null; &#125;&#125; 4.测试类 12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; // 获取 Circle 的对象，并调用它的 draw 方法 Shape circle = ShapeFactory.getShape("Circle"); circle.draw(); // 获取 Rectangle 的对象，并调用它的 draw 方法 Shape rectangle = ShapeFactory.getShape("Rectangle"); rectangle.draw(); // 获取 Square 的对象，并调用它的 draw 方法 Shape square = ShapeFactory.getShape("Square"); square.draw(); &#125;&#125; 运行结果 CircleDraw a CircleRectangleDraw a RectangleSquareDraw a Square 这样的实现有个问题，如果我们新增产品类的话，就需要修改工厂类中的getShape（）方法，这很明显不符合 开放-封闭原则 。 5.使用反射机制改善简单工厂将工厂类改为下面的形式： 利用反射解决简单工厂每次增加新了产品类都要修改产品工厂的弊端 12345678910111213141516171819public class ShapeFactory2 &#123; public static Object getClass(Class&lt;? extends Shape&gt; clazz)&#123; Object obj = null; try &#123; obj = Class.forName(clazz.getName()).newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return obj; &#125;&#125; 测试类： 1234567891011121314public class Test2 &#123; public static void main(String[] args) &#123; Circle circle = (Circle) ShapeFactory2.getClass(Circle.class); circle.draw(); Rectangle rectangle = (Rectangle) ShapeFactory2.getClass(Rectangle.class); rectangle.draw(); Square square = (Square) ShapeFactory2.getClass(Square.class); square.draw(); &#125;&#125; 这种方式的虽然符合了 开放-关闭原则 ，但是每一次传入的都是产品类的全部路径，这样比较麻烦。如果需要改善的话可以通过 反射+配置文件 的形式来改善，这种方式使用的也是比较多的。 三、工厂方法模式1.介绍工厂方法模式应该是在工厂模式家族中是用的最多模式，一般项目中存在最多的就是这个模式。 工厂方法模式是简单工厂的仅一步深化， 在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说 每个对象都有一个与之对应的工厂 。 2.适用场景 一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无需关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 3.工厂方法模式角色分配 抽象工厂(Abstract Factory)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。 具体工厂(Concrete Factory)角色 ：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。 抽象产品(Abstract Product)角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。 具体产品(Concrete Product)角色 ：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应。 4.工厂方法模式实例上面简单工厂例子中的图形接口以及相关图像实现类不变。我们只需要增加一个工厂接口以及实现这个接口的工厂类即可。 1. 创建 Shape 接口 123public interface Shape &#123; void draw();&#125; 2. 增加一个工厂接口 123public interface Factory &#123; public Shape getShape();&#125; 3. 增加相关工厂类 圆形工厂类 123456public class CircleFactory implements Factory &#123; @Override public Shape getShape() &#123; return new Circle(); &#125;&#125; 长方形工厂类 123456public class RectangleFactory implements Factory &#123; @Override public Shape getShape() &#123; return new Rectangle(); &#125;&#125; 正方形工厂类 123456public class SquareFactory implements Factory &#123; @Override public Shape getShape() &#123; return new Square(); &#125;&#125; 4.测试类 1234567public class Test &#123; public static void main(String[] args) &#123; Factory circleFactory = new CircleFactory(); Shape circle = circleFactory.getShape(); circle.draw(); &#125;&#125; 运行结果 CircleDraw a Circle 四、抽象工厂模式1.介绍在工厂方法模式中，其实我们有一个潜在意识的意识。那就是我们生产的都是同一类产品。抽象工厂模式是工厂方法的仅一步深化，在这个模式中的工厂类不单单可以创建一种产品，而是可以创建一组产品。 抽象工厂应该是比较最难理解的一个工厂模式了。 2.适用场景 和工厂方法一样客户端不需要知道它所创建的对象的类。 需要一组对象共同完成某种功能时，并且可能存在多组对象完成不同功能的情况。（同属于同一个产品族的产品） 系统结构稳定，不会频繁的增加对象。（因为一旦增加就需要修改原有代码，不符合开闭原则） 3.抽象工厂方法模式角色分配 抽象工厂（AbstractFactory）角色 ：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。 具体工厂类（ConreteFactory）角色 ：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。 抽象产品（Abstract Product）角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。 具体产品（Concrete Product）角色 ：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。在抽象工厂中创建的产品属于同一产品族，这不同于工厂模式中的工厂只创建单一产品，我后面也会详解介绍到。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>简单工厂模式</tag>
        <tag>工厂方法模式</tag>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串转整数]]></title>
    <url>%2F2018%2F11%2F13%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 输入描述:1输入一个字符串,包括数字字母符号,可以为空 输出描述:1如果是合法的数值表达则返回该数字，否则返回0 输入例子:12+2147483647 1a33 输出例子:122147483647 0 思路将字符串转化为数组进行处理，例如12 = 110+2；123 = 12\10+3； 此外还需要注意一下几点 字符串是否为空 字符串两边有空格自动屏蔽 字符串是否溢出（大于最大值，小于最小值） 字符串的符号怎么判断 “+123”和”123”效果一样 字符串的每一位的正确性 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class StringToInt &#123; public static void main(String[] args) &#123; String a = "12a3"; int b = StringToInt(a); System.out.println(b); &#125; public static int StringToInt(String str) &#123; if (str == null || str.equals("")) &#123; return 0; &#125; String s = str.trim(); int result = 0; int symbol = 1;//符号位 int i = 0, len = s.length(); char[] array = s.toCharArray(); boolean isValid = false;//结果是否有效 if (len &gt; 0) &#123; char firstChar = s.charAt(0); if (firstChar &lt; '0') &#123; if (firstChar == '-') &#123; symbol = -1; &#125; else if (firstChar != '+') &#123; return 0; &#125; if (len == 1)&#123; return 0; &#125; i++; &#125; for (int j = i;j &lt; len;j++)&#123; if (!('0' &lt;= array[j] &amp;&amp; array[j] &lt;= '9' ))&#123; isValid = true; return 0; &#125; result = result*10 + array[j] - '0'; if ((symbol == 1 &amp;&amp; result&gt;Integer.MAX_VALUE)||(symbol == -1 &amp;&amp; result &lt; Integer.MIN_VALUE))&#123; isValid = true; return 0; &#125; &#125; &#125;else &#123; return 0; &#125; return result*symbol; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer(JAVA)</category>
      </categories>
      <tags>
        <tag>字符串转整数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础十一-Map]]></title>
    <url>%2F2018%2F11%2F08%2FJava%E5%9F%BA%E7%A1%80%E5%8D%81%E4%B8%80-Map%2F</url>
    <content type="text"><![CDATA[Map 中的数据是以键值对（key - value）的形式存储的 key - value 以 Entry 类型的对象实例存在 可以通过 key 值快速的查找 value 值 一个映射不能包含重复的键 每个键最多只能映射到一个值 当访问的值不在的时候，方法会抛出一个 NoSuchElementException 异常 当对象的类型和 Map 里元素类型不兼容的时候，就会抛出一个 ClassCastException 异常 当在不允许使用 Null 对象的 Map 中使用Null对象，会抛出一个 NullPointerException 异常 当尝试修改一个只读的 Map 时，会抛出一个 UnsupportedOperationException 异常 常用的方法 添加或者修改功能 V put(K key, V value)：添加元素 /修改元素，并返回修改前元素的值 删除功能 void clear()：移除所有的键值对元素 V remove(Object key)：删除键对应的元素，并把值返回 判断功能 boolean containsKey(Object key)：判断集合是否包含指定的键 boolean containsValue(Object value)：判断集合是否包含指定的值 boolean isEmpty()：判断集合是否为空 获取功能 Set&lt; Map.Entry&lt; K,V&gt;&gt; entrySet()：遍历 V get(Object key)：根据键获取值 Set&lt; K&gt; keySet()：获取集合中所有键的集合 Collection&lt; V&gt; values()：获取集合中所有值的集合 长度功能 int size()：返回集合中的键值对的对数 HashMap什么是Hash表在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能 数组：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n) 线性链表：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n) 二叉树：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。 哈希表：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。 我们知道，数据结构的物理存储结构只有两种：顺序存储结构和链式存储结构（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，哈希表的主干就是数组。 比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。 存储位置 = f(关键字) 其中，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。 哈希冲突然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式 HashMap 是 Java 中 Map 的一个实现类，它是一个双列结构(数据+链表)，这样的结构使得它的查询和插入效率都很高。HashMap 允许 null 键和值，它的键唯一，元素的存储无序，并且它是线程不安全的。 由于 HashMap 的这些特性，它在 Java 中被广泛地使用，下面我们就基于 Java 8 分析一下 HashMap 的源码。 定义HashMap 实现了 Map 接口，继承 AbstractMap。其中 Map 接口定义了键映射到值的规则，而 AbstractMap 类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作，其实 AbstractMap 类已经实现了 Map。 123public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 构造函数HashMap提供了三个构造函数： HashMap()：构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap HashMap(int initialCapacity)：构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap HashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和加载因子的空 HashMap 在这里提到了两个参数：初始容量，加载因子。这两个参数是影响 HashMap 性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是 O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。 HashMap是一种支持快速存取的数据结构，要了解它的性能必须要了解它的数据结构。 数据结构首先 HashMap 是一个双列结构，它是一个散列表，存储方式是键值对。 它继承了 AbstractMap，实现了 Map&lt;K,V&gt; Cloneable Serializable 接口。 HashMap 的双列结构是数组 Node[]+链表，我们知道数组的查询很快，但是修改很慢，因为数组定长，所以添加或者减少元素都会导致数组扩容。而链表结构恰恰相反，它的查询慢，因为没有索引，需要遍历链表查询。但是它的修改很快，不需要扩容，只需要在首或者尾部添加即可。HashMap 正是应用了这两种数据结构，以此来保证它的查询和修改都有很高的效率。 HashMap 在调用 put() 方法存储元素的时候，会根据 key 的 hash 值来计算它的索引，这个索引有什么用呢？HashMap 使用这个索引来将这个键值对储存到对应的数组位置，比如如果计算出来的索引是 n，则它将存储在 Node[n] 这个位置。 HashMap 在计算索引的时候尽量保证它的离散，但还是会有不同的 key 计算出来的索引是一样的，那么第二次 put 的时候，key 就会产生冲突。HashMap 用链表的结构解决这个问题，当 HashMap 发现当前的索引下已经有不为 null 的 Node 存在时，会在这个 Node 后面添加新元素，同一索引下的元素就组成了链表结构，Node 和 Node 之间如何联系可以看下面 Node 类的源码分析。 几个比较重要的字段DEFAULT_INITIAL_CAPACITY，默认初始化的容量为16，必须是2的幂。 1static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 MAXIMUM_CAPACITY，最大长度，2^30： 1static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; DEFAULT_LOAD_FACTOR，默认加载因子，0.75： 1static final float DEFAULT_LOAD_FACTOR = 0.75f; 由链表转换成树的阈值TREEIFY_THRESHOLD 一个桶中 bin（箱子）的存储方式由链表转换成树的阈值。即当桶中bin的数量超过 TREEIFY_THRESHOLD 时使用树来代替链表。默认值是8 1static final int TREEIFY_THRESHOLD = 8; 由树转换成链表的阈值UNTREEIFY_THRESHOLD 当执行resize操作时，当桶中bin的数量少于UNTREEIFY_THRESHOLD时使用链表来代替树。默认值是6 1static final int UNTREEIFY_THRESHOLD = 6; MIN_TREEIFY_CAPACITY 当桶中的 bin 被树化时最小的 hash 表容量。（如果没有达到这个阈值，即 hash 表容量小于MIN_TREEIFY_CAPACITY，当桶中 bin 的数量太多时会执行 resize 扩容操作）这个 MIN_TREEIFY_CAPACITY 的值至少是 TREEIFY_THRESHOLD 的4倍。 1static final int MIN_TREEIFY_CAPACITY = 64; Node下边是非常重要的一个内部类 Node ，它实现了 Map.Entry，Node 是 HashMap 中的基本元素，每个键值对都储存在一个 Node 对象里， Node 类有四个成员变量：hash key 的哈希值、键值对 key 与 value，以及 next 指针。next 也是 Node 类型，这个 Node 指向的是链表下一个键值对，这也就是前文提到的 hash 冲突时 HashMap 的处理办法。 Node 类内部实现了 Map.Entry 接口中的 getKey()、getValue() 等方法，所以在遍历 Map 的时候我们可以用 Map.entrySet() 。 123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; put() 流程put() 方法put() 主要是将 key 和 value 保存到 Node 数组中，HashMap 根据 key 的 hash 值来确定它的索引，源码里 put 方法将调用内部的 putVal() 方法。 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; HashMap 在 put 键值对的时候会调用 hash() 方法计算 key 的 hash 值，hash() 方法会调用 Object 的 native 方法 hashCode() 并且将计算之后的 hash 值高低位做异或运算，以增加 hash 的复杂度。（Java 里一个 int 类型占 4 个字节，一个字节是 8 bit，所以下面源码中的 h 与 h 右移 16 位就相当于高低位异或） 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; putAll() 方法这部分是主要 put 的逻辑 计算容量：根据 map 的 size 计算数组容量大小，如果元素数量也就是 size 大于数组容量 ×0.75，则对数组进行扩容，扩容到原来的 2 倍。 查找数据索引：根据 key 的 hash 值和数组长度找到 Node 数组索引。 储存：这里有以下几种情况（假设计算出的 hash 为 i，数组为 tab，变量以代码为例） a. 当前索引为 null，直接 new 一个 Node 并存到数组里，tab[i]=newNode(hash, key, value, null) b. 数组不为空，这时两个元素的 hash 是一样的，再调用 equals 方法判断 key 是否一致，相同，则覆盖当前的 value，否则继续向下判断 c. 上面两个条件都不满足，说明 hash 发生冲突，Java 8 里实现了红黑树，红黑树在进行插入和删除操作时通过特定算法保持二叉查找树的平衡，从而可以获得较高的查找性能。本篇也是基于 Java 8 的源码进行分析，在这里 HashMap 会判断当前数组上的元素 tab[i] 是否是红黑树，如果是，调用红黑树的 putTreeVal 的 put 方法，它会将新元素以红黑树的数据结构储存到数组中。 如果以上条件都不成立，表明 tab[i] 上有其它 key 元素存在，并且没有转成红黑树结构，这时只需调用 tab[i].next 来遍历此链表，找到链表的尾然后将元素存到当前链表的尾部。 1transient Node&lt;K,V&gt;[] table; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 根据当前的map size计算容量大小capacity， 主要实现是在resize()中计算capacity，需要扩容的时候， 长度左移一位（二倍） if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 这里就是经常说的桶结构了， 看过HashMap介绍的都知道它的内部有不同的桶, 这个桶实际上就是一个链表结构 // 在这个地方， HashMap先判断key所属的桶是否存在。 (n - 1) &amp; hash 相当于计算桶的序号， 根据桶序号来找到对应的桶 // 这里的table 是HashMap的数组， 数组为空就新建一个数组 newNode(hash, key, value, null) if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; //数组不为空， 先判断key是否存在， 存在 就覆盖value Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 如果此链表是红黑树结构（TreeNode） else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // 循环当前链表， 找出p.next为空的位置就是链表的末端， 添加上 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // 这里会判断这个链表是否需要转换为红黑树链表 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) // put之后，如果元素个数大于当前的数组容量了，进行数组扩容 resize(); afterNodeInsertion(evict); return null;&#125; get()get() 方法get() 方法会调用 getNode() 方法，这是 get() 的核心，getNode() 方法的两个参数分别是 hash 值和 key。 1234public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; 这里重点来看 getNode() 方法，前面讲到过，HashMap 是通过 key 生成的 hash 值来存储到数组的对应索引上，HashMap 在 get 的时候也是用这种方式来查找元素的。 根据 hash 值和数组长度找到 key 对应的数组索引。 拿到当前的数组元素，也就是这个链表的第一个元素 first，先用 hash 和 equals() 判断是不是第一个元素，是的话直接返回，不是的话继续下面的逻辑。 不是链表的第一个元素，判断这个元素 first 是不是红黑树，如果是调用红黑树的 getTreeNode 方法来查询。 如果不是红黑树结构，从 first 元素开始遍历当前链表，直到找到要查询的元素，如果没有则返回 null。 1234567891011121314151617181920212223242526272829final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; // tab： HashMap的数组 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // 判断数组不为空， 桶不为空 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 先查询桶的第一个元素 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 不是第一个元素 if ((e = first.next) != null) &#123; // 如果是红黑树， 则用红黑树的方法查询 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 不是红黑树， 遍历桶， 直到找到对应的key， 返回 do &#123; // 1. 判断hash值是否相等； // 2. 判断key相等。 防止hash碰撞发生 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; HashMap 的扩容机制扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。 我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。 123456789101112void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值&#125; 这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。 1234567891011121314151617void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125;while (e != null); &#125; &#125;&#125; newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。 下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order // 链表优化重hash的代码块 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; LinkedHashMap​ LinkedHashMap继承自HashMap，是Hash表和链表的实现，并且依靠着双向链表保证了迭代顺序是插入的顺序。如果 一个key重新插入到LinkedHashMap中，那么这个插入顺序是无效的，也就是说，如果m.put(K,V)时，调用m.containsKey(k),将会返回true，更新value值，但是顺序不变。 1234567891011121314public class TestLinkHashMap &#123; public static void main(String[] args)&#123; Map&lt;String,Object&gt; map = new LinkedHashMap&lt;&gt;(); map.put(&quot;1&quot;,&quot;1&quot;); map.put(&quot;2&quot;,&quot;2&quot;); map.put(&quot;3&quot;,&quot;3&quot;); //重新插入&quot;1&quot; map.put(&quot;1&quot;,&quot;4&quot;); for (Map.Entry&lt;String,Object&gt; entry:map.entrySet()) &#123; System.out.println(&quot;key=&quot;+entry.getKey()+&quot; &quot;+&quot;value=&quot;+entry.getValue()); &#125; &#125;&#125; 运行结果 key=1 value=4key=2 value=2key=3 value=3 从上面的程序我们可以看见，同一key的多次插入，并不会影响其顺序 数据结构循环双向链表的头部存放的是最久访问的节点或最先插入的节点，尾部为最近访问的或最近插入的节点，迭代器遍历方向是从链表的头部开始到链表尾部结束，在链表尾部有一个空的header节点，该节点不存放key-value内容，为LinkedHashMap类的成员属性，循环双向链表的入口； 它继承了HashMap的Node，Node基础上添加了before和after两个指针， 123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; 重要的属性12345678910111213141516/** * 双向链表的头部(eldest) */ transient LinkedHashMap.Entry&lt;K,V&gt; head; /** * 双向链表的尾部(youngest) */ transient LinkedHashMap.Entry&lt;K,V&gt; tail; /** * *accessOrder为true时，按访问顺序排序，false时，按插入顺序排序 * */ final boolean accessOrder; 重点的方法 LinkedHashMap的Entry是继承与Node类，也就是LinkedHashMap与HashMap的根本区别所在，Node是链表形式，只有next与下一个元素进行连接，而Entry的链表有before和after两个连接点。 123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; 区别是将节点变成Entry，并且按照链表方式将元素有序连接 12345Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p); return p;&#125; afterNodeAccess方法 12345678910111213141516171819202122232425262728293031323334353637void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; // 若访问顺序为true，且访问的对象不是尾结点 if (accessOrder &amp;&amp; (last = tail) != e) &#123; // 向下转型，记录p的前后结点 LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; // p的后结点为空 p.after = null; // 如果p的前结点为空 if (b == null) // a为头结点 head = a; else // p的前结点不为空 // b的后结点为a b.after = a; // p的后结点不为空 if (a != null) // a的前结点为b a.before = b; else // p的后结点为空 // 后结点为最后一个结点 last = b; // 若最后一个结点为空 if (last == null) // 头结点为p head = p; else &#123; // p链入最后一个结点后面 p.before = last; last.after = p; &#125; // 尾结点为p tail = p; // 增加结构性修改数量 ++modCount; &#125;&#125; 就是说在进行put之后就算是对节点的访问了，那么这个时候就会更新链表，把最近访问的放到最后，保证链表。关键参数是accessOrder，这个参数只有在public LinkedHashMap(int initialCapacity, float loadFactor,boolean accessOrder) 中可以手动设置为true，其余时候都默认为false HashtableTreeMap]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java基础十一-Set]]></title>
    <url>%2F2018%2F11%2F08%2FJava%E5%9F%BA%E7%A1%80%E5%8D%81%E4%B8%80-Set%2F</url>
    <content type="text"><![CDATA[Set 和 List 一样，也继承于 Collection，是集合的一种。和 List 不同的是，Set 内部实现是基于 Map 的，所以 Set取值时不保证数据和存入的时候顺序一致，并且不允许空值，不允许重复值。 Set主要有2个实现方式，一个是 TreeSet，另一个是 HashSet 。 HashSet HashSet 是 Set 的一个重要实现类，称为哈希集 HashSet 中的元素无序并且不可以重复 HashSet 中只允许一个 null 元素 具有良好的存取和查找性能 就如它的名字一样，HashSet 主要由 HashMap 实现 如果调用HashSet的无参构造函数，那么就会使用默认的HashMap，初始化Size为16，扩张系数为0.75 1234567/** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * default initial capacity (16) and load factor (0.75). */public HashSet() &#123; map = new HashMap&lt;&gt;();&#125; 接下来，我们简单的看一下 HashSet 的几个数据执行操作 123456789101112131415/** * Adds the specified element to this set if it is not already present. * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;. * If this set already contains the element, the call leaves the set * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;. * * @param e element to be added to this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified * element */public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 123456789101112131415/** * Removes the specified element from this set if it is present. * More formally, removes an element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;, * if this set contains such an element. Returns &lt;tt&gt;true&lt;/tt&gt; if * this set contained the element (or equivalently, if this set * changed as a result of the call). (This set will not contain the * element once the call returns.) * * @param o object to be removed from this set, if present * @return &lt;tt&gt;true&lt;/tt&gt; if the set contained the specified element */public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125; 1234567/** * Removes all of the elements from this set. * The set will be empty after this call returns. */public void clear() &#123; map.clear();&#125; 12345678/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements. * * @return &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements */public boolean isEmpty() &#123; return map.isEmpty();&#125; 12345678/** * Returns the number of elements in this set (its cardinality). * * @return the number of elements in this set (its cardinality) */public int size() &#123; return map.size();&#125; 12345678910/** * Returns an iterator over the elements in this set. The elements * are returned in no particular order. * * @return an Iterator over the elements in this set * @see ConcurrentModificationException */public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator();&#125; 可以看出，HashMap 的几个主要数据执行操作都是间接的调用了内部的 HashMap 的数据操作 HashSet 的值是 HashMap 的 key HashMap 的 value 是写死的 PRESENT 所以遍历 HashSet 的值，也就是遍历 HashMap 的 KeyEntry HashSet 如何检查重复HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 是按照哈希值来存的所以取数据也是按照哈希值取得。 HashSet 会通过元素的 hashcode（）和 equals 方法进行判断元素是否重复。 当你试图把对象加入 HashSet 时，HashSet 会使用对象的 hashCode 来判断对象加入的位置。同时也会与其他已经加入的对象的 hashCode 进行比较，如果没有相等的 hashCode，HashSet 就会假设对象没有重复出现。 简单一句话，如果对象的hashCode值是不同的，那么HashSet会认为对象是不可能相等的。 因此我们自定义类的时候需要重写 hashCode，来确保对象具有相同的 hashCode 值。 如果元素(对象)的 hashCode 值相同,是不是就无法存入 HashSet 中了? 当然不是，HashSet 会继续用 equals 进行比较，如果 equals 为 true ，那么 HashSet 认为新加入的对象重复了，所以加入失败；如果 equals 为 false 那么HashSet 认为新加入的对象没有重复，新元素可以存入。 总结 元素的哈希值是通过元素的 hashcode 方法来获取的，HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较 equals 方法，如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。 哈希值相同 equals 为 false 的元素是怎么存储呢？就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.Objects;public class Student &#123; private Integer stuNum; private String stuName; private Integer stuAge; public Student(Integer stuNum, String stuName, Integer stuAge) &#123; this.stuNum = stuNum; this.stuName = stuName; this.stuAge = stuAge; &#125; public Integer getStuNum() &#123; return stuNum; &#125; public void setStuNum(Integer stuNum) &#123; this.stuNum = stuNum; &#125; public String getStuName() &#123; return stuName; &#125; public void setStuName(String stuName) &#123; this.stuName = stuName; &#125; public Integer getStuAge() &#123; return stuAge; &#125; public void setStuAge(Integer stuAge) &#123; this.stuAge = stuAge; &#125; @Override public boolean equals(Object o) &#123; System.out.println(this + "---equals---" + o); if (o instanceof Student)&#123; Student s = (Student) o; return this.stuName.equals(s.stuName) &amp;&amp; this.stuAge.equals(s.stuAge); &#125;else &#123; return false; &#125; &#125; @Override public int hashCode() &#123; System.out.println("hashCode is :"+ this.stuName); return this.stuName.hashCode() + stuNum * 4; &#125; @Override public String toString() &#123; return "Student&#123;" + "stuNum=" + stuNum + ", stuName='" + stuName + '\'' + ", stuAge=" + stuAge + '&#125;'; &#125;&#125; 1234567891011121314151617181920212223242526import java.util.HashSet;import java.util.Iterator;import java.util.Set;public class Main&#123; public static void main(String[] args) &#123; Set set = new HashSet(); Student s1 = new Student(0001,"Jack",18); Student s2 = new Student(0002,"Mike",20); Student s3 = new Student(0003,"Lucy",19); Student s4 = new Student(0003,"Lucy",19); Student s5 = new Student(0003,"Lucy",20); Student s6 = new Student(0004,"Lucy",20); set.add(s1); set.add(s2); set.add(s3); set.add(s4); set.add(s5); set.add(s6); Iterator it = set.iterator(); while (it.hasNext())&#123; System.out.println(it.next()); &#125; &#125;&#125; 运行结果 hashCode is :JackhashCode is :MikehashCode is :LucyhashCode is :LucyStudent{stuNum=3, stuName=’Lucy’, stuAge=19}—equals—Student{stuNum=3, stuName=’Lucy’, stuAge=19}hashCode is :LucyStudent{stuNum=3, stuName=’Lucy’, stuAge=20}—equals—Student{stuNum=3, stuName=’Lucy’, stuAge=19}hashCode is :LucyStudent{stuNum=1, stuName=’Jack’, stuAge=18}Student{stuNum=2, stuName=’Mike’, stuAge=20}Student{stuNum=4, stuName=’Lucy’, stuAge=20}Student{stuNum=3, stuName=’Lucy’, stuAge=19}Student{stuNum=3, stuName=’Lucy’, stuAge=20} 重写后的 hashCode 的判断依据是this.stuName.hashCode() + stuNum * 4 重写后的 equals 中的判断依据是this.stuName.equals(s.stuName) &amp;&amp; this.stuAge.equals(s.stuAge); 这里我们可以看到，因为 s3 和 s4 的 hashCode 相同，所以，会用 equals 进行比较，而 s3 和 s4 的 equals 也相同，那么 HashSet 认为新加入的对象重复了，所以加入失败。 而在判断 s3 和 s5 时， s3 和 s5 的 hashCode 相同，而 equals 不同，HashSet 认为新加入的对象没有重复，新元素可以存入。 s3 和 s6 比较的时候 hashCode 不同，直接判断是不同的对象，认为没有重复，可以存入。 LinkedHashSet继承自 HashSet，只是实现了几个构造方法，并且这几个构造方法都是直接使用了父类的构造方法。 LinkedHashSet 所使用的父类构造方法： 12345678910111213141516/** * Constructs a new, empty linked hash set. (This package private * constructor is only used by LinkedHashSet.) The backing * HashMap instance is a LinkedHashMap with the specified initial * capacity and the specified load factor. * * @param initialCapacity the initial capacity of the hash map * @param loadFactor the load factor of the hash map * @param dummy ignored (distinguishes this * constructor from other int, float constructor.) * @throws IllegalArgumentException if the initial capacity is less * than zero, or if the load factor is nonpositive */HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125; HashSet 其他的构造方法（这里只举出一个）： 1234567891011/** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * the specified initial capacity and default load factor (0.75). * * @param initialCapacity the initial capacity of the hash table * @throws IllegalArgumentException if the initial capacity is less * than zero */public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity);&#125; 只有在 HashSet 的这个构造方法中，把 map 实例化 LinkedHashMap，而其他的构造方法则是把 map 实例化为HashMap 。所以 LinkedHashSet 的实现是通过 LinkedHashMap 实现的。 注意：无论是 HashSet 还是 LinkedHashSet，它们本质上是一个值（Value）为同一 Object（即是源码中的PRESENT）的 Map。 LinkedHashSet 集合同样是根据元素的 hashCode 值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet 将会以元素的添加顺序访问集合的元素。 LinkedHashSet 在迭代访问 Set 中的全部元素时，性能比 HashSet 好，但是插入时性能稍微逊色于 HashSet。 TreeSetTreeSet 和 HashMap 的处理方式相似，这里就不重复展开，区别的地方在于，TreeSet 是基于 TreeMap 实现的，TreeSet 是有序的。 我们先来看这么一段代码 1234567891011121314151617import java.util.Iterator;import java.util.Set;import java.util.TreeSet;public class Main&#123; public static void main(String[] args) &#123; Set set = new TreeSet(); set.add("cccc"); set.add("dddd"); set.add("aaaa"); set.add("bbbb"); Iterator it = set.iterator(); while (it.hasNext())&#123; System.out.println(it.next()); &#125; &#125;&#125; 运行结果 aaaabbbbccccdddd 既然 TreeSet 可以自然排序,那么 TreeSet 必定是有排序规则的。 让存入的元素自定义比较规则 给 TreeSet 指定排序规则 方式一：元素自身具备比较性 元素自身具备比较性，需要元素实现 Comparable 接口，重写 compareTo 方法，也就是让元素自身具备比较性，这种方式叫做元素的自然排序也叫做默认排序。 方式二：容器具备比较性 当元素自身不具备比较性，或者自身具备的比较性不是所需要的。那么此时可以让容器自身具备。需要定义一个类实现接口 Comparator，重写 compare 方法，并将该接口的子类实例对象作为参数传递给 TreeMap 集合的构造方法。 注意： 当 Comparable 比较方式和 Comparator 比较方式同时存在时，以 Comparator 的比较方式为主 在重写 compareTo 或者 compare 方法时，必须要明确比较的主要条件相等时要比较次要条件 假设姓名和年龄一致的人为相同的人，如果想要对人按照年龄的大小来排序，如果年龄相同的人，需要如何处理？不能直接 return 0，因为可能姓名不同（年龄相同姓名不同的人是不同的人）。此时就需要进行次要条件判断（需要判断姓名），只有姓名和年龄同时相等的才可以返回 0。 通过return 0来判断唯一性 为什么使用TreeSet存入字符串,字符串默认输出是按升序排列的？ 因为字符串实现了 Comparable 接口。字符串重写了该接口的 compareTo 方法,所以 String 对象具备了比较性。那么同样道理,我的自定义元素(例如 Person 类，Book 类)想要存入 TreeSet 集合,就需要实现该接口,也就是要让自定义对象具备比较性。 存入 TreeSet 集合中的元素要具备比较性。 比较性要实现 Comparable 接口，重写该接口的 compareTo 方法 TreeSet 属于 Set 集合，该集合的元素是不能重复的，TreeSet 如何保证元素的唯一性？ 通过 compareTo 或者 compare 方法中的来保证元素的唯一性。 添加的元素必须要实现 Comparable 接口。当 compareTo() 函数返回值为0时，说明两个对象相等，此时该对象不会添加进来。 让元素自身具备比较性也就是元素需要实现Comparable接口，覆盖compareTo 方法。这种方式也作为元素的自然排序，也可称为默认排序。年龄按照搜要条件，年龄相同再比姓名。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.util.Objects;public class Student implements Comparable&#123; private Integer stuNum; private String stuName; private Integer stuAge; public Student(Integer stuNum, String stuName, Integer stuAge) &#123; this.stuNum = stuNum; this.stuName = stuName; this.stuAge = stuAge; &#125; public Integer getStuNum() &#123; return stuNum; &#125; public void setStuNum(Integer stuNum) &#123; this.stuNum = stuNum; &#125; public String getStuName() &#123; return stuName; &#125; public void setStuName(String stuName) &#123; this.stuName = stuName; &#125; public Integer getStuAge() &#123; return stuAge; &#125; public void setStuAge(Integer stuAge) &#123; this.stuAge = stuAge; &#125; @Override public boolean equals(Object o) &#123; System.out.println(this + "---equals---" + o); if (o instanceof Student)&#123; Student s = (Student) o; return this.stuName.equals(s.stuName) &amp;&amp; this.stuAge.equals(s.stuAge); &#125;else &#123; return false; &#125; &#125; @Override public int hashCode() &#123; System.out.println("hashCode is :"+ this.stuName); return this.stuName.hashCode() + stuNum * 4; &#125; @Override public String toString() &#123; return "Student&#123;" + "stuNum=" + stuNum + ", stuName='" + stuName + '\'' + ", stuAge=" + stuAge + '&#125;'; &#125; @Override public int compareTo(Object o) &#123; Student s = (Student) o; System.out.println(this + "compareTo:" + s); if (this.stuAge &gt; s.stuAge)&#123; return 1; &#125; if (this.stuAge &lt; s.stuAge)&#123; return -1; &#125; return this.stuName.compareTo(s.stuName); &#125;&#125; 123456789101112131415import java.util.TreeSet;public class Main&#123; public static void main(String[] args) &#123; TreeSet ts = new TreeSet(); ts.add( new Student(0001,"Jack",18)); ts.add( new Student(0002,"Mike",20)); ts.add( new Student(0003,"Lucy",19)); ts.add( new Student(0003,"Lucy",19)); ts.add( new Student(0003,"Lucy",20)); ts.add( new Student(0004,"Lucy",20)); System.out.println(ts); System.out.println(ts.size()); &#125;&#125; 运行结果 Student{stuNum=1, stuName=’Jack’, stuAge=18}compareTo:Student{stuNum=1, stuName=’Jack’, stuAge=18}Student{stuNum=2, stuName=’Mike’, stuAge=20}compareTo:Student{stuNum=1, stuName=’Jack’, stuAge=18}Student{stuNum=3, stuName=’Lucy’, stuAge=19}compareTo:Student{stuNum=1, stuName=’Jack’, stuAge=18}Student{stuNum=3, stuName=’Lucy’, stuAge=19}compareTo:Student{stuNum=2, stuName=’Mike’, stuAge=20}Student{stuNum=3, stuName=’Lucy’, stuAge=19}compareTo:Student{stuNum=3, stuName=’Lucy’, stuAge=19}Student{stuNum=3, stuName=’Lucy’, stuAge=20}compareTo:Student{stuNum=3, stuName=’Lucy’, stuAge=19}Student{stuNum=3, stuName=’Lucy’, stuAge=20}compareTo:Student{stuNum=2, stuName=’Mike’, stuAge=20}Student{stuNum=4, stuName=’Lucy’, stuAge=20}compareTo:Student{stuNum=3, stuName=’Lucy’, stuAge=19}Student{stuNum=4, stuName=’Lucy’, stuAge=20}compareTo:Student{stuNum=2, stuName=’Mike’, stuAge=20}Student{stuNum=4, stuName=’Lucy’, stuAge=20}compareTo:Student{stuNum=3, stuName=’Lucy’, stuAge=20}[Student{stuNum=1, stuName=’Jack’, stuAge=18}, Student{stuNum=3, stuName=’Lucy’, stuAge=19}, Student{stuNum=3, stuName=’Lucy’, stuAge=20}, Student{stuNum=2, stuName=’Mike’, stuAge=20}] 4 让容器自身具备比较性当元素自身不具备比较性，或者元素自身具备的比较性不是所需的。那么这时只能让容器自身具备。 定义一个类实现 Comparator 接口，覆盖 compare 方法。并将该接口的子类对象作为参数传递给 TreeSet 集合的构造函数。当 Comparable 比较方式，及 Comparator 比较方式同时存在，以 Comparator 比较方式为主。 123456789101112131415161718192021222324252627282930313233public class Book &#123; private String name; private double price; public Book(String name, double price) &#123; this.name = name; this.price = price; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return "Book&#123;" + "name='" + name + '\'' + ", price=" + price + '&#125;'; &#125;&#125; 123456789101112131415161718import java.util.Comparator;public class MyComparator implements Comparator &#123; @Override public int compare(Object o1, Object o2) &#123; Book b1 = (Book) o1; Book b2 = (Book) o2; System.out.println(b1 + "compare" + b2); if (b1.getPrice() &gt; b2.getPrice())&#123; return 1; &#125; if (b1.getPrice() &lt; b2.getPrice())&#123; return -1; &#125; return b1.getName().compareTo(b2.getName()); &#125;&#125; 1234567891011121314import java.util.TreeSet;public class Main&#123; public static void main(String[] args) &#123; TreeSet ts = new TreeSet(new MyComparator()); ts.add(new Book("think in java", 100)); ts.add(new Book("java 核心技术", 75)); ts.add(new Book("现代操作系统", 50)); ts.add(new Book("java就业教程", 35)); ts.add(new Book("think in java", 100)); ts.add(new Book("ccc in java", 100)); System.out.println(ts); &#125;&#125; HashSet、LinkedHashSet 和 TreeSet 的区别 底层存储的数据结构不同 HashSet 底层用的是 HashMap 哈希表结构存储，LinkedHashSet 继承自 HashSet 底层用的是 LinkedHashMap 链表结构存储， 而 TreeSet 底层用的是 TreeMap 树结构存储 存储时保证数据唯一性依据不同 HashSet 和 LinkedHashSet 是通过重写 hashCode() 方法和 equals() 方法来保证的，而 HashSet 通过 Compareable 接口的compareTo() 方法来保证的 有序性不一样 HashSet 无序，LinkedHashSet 以元素的插入顺序，TreeSet 有序 线程安全 都不安全]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础十一-List]]></title>
    <url>%2F2018%2F11%2F08%2FJava%E5%9F%BA%E7%A1%80%E5%8D%81%E4%B8%80-List%2F</url>
    <content type="text"><![CDATA[List 是元素有序并且可以重复的集合，称为序列 List 可以精确的控制每个元素的插入位置，或删除某个位置的元素 List 的两个主要实现类，是 ArrayList 和 LinkedList ArrayList ArrayList 底层是由数组实现的 动态增长，以满足应用程序的需求 在列表尾部插入或删除非常有效 更适合查找和更新元素 ArrayList 中的元素可以为 NULL 下面的例子介绍 ArrayList 的增删改查 1234567891011121314151617181920212223242526272829303132333435import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class Main&#123; public static void main(String[] args) &#123; List list = new ArrayList(); list.add('a'); list.add('b'); list.add('c'); list.add('d'); list.add('e'); System.out.println("list的长度为:" + list.size()); System.out.println("输出list中的第二个元素:" + list.get(1)); System.out.println("遍历list数组:"); System.out.println("--第一种遍历方法---for循环"); for (int i = 0; i &lt; list.size(); i++) &#123; System.out.print(list.get(i) + " "); &#125; System.out.println(); System.out.println("--第二种遍历方法---foreach循环（修改第三个位置的数据）"); list.set(2,'z'); for (Object i : list) &#123; System.out.print(i + " "); &#125; System.out.println(); System.out.println("--第三种遍历方法---Iterator迭代器（去掉第二个位置的数据）"); list.remove(1); Iterator iterator = list.iterator(); while (iterator.hasNext())&#123; System.out.print(iterator.next() + " "); &#125; &#125;&#125; 运行结果： list的长度为:5输出list中的第二个元素:b遍历list数组:–第一种遍历方法—for循环a b c d e–第二种遍历方法—foreach循环（修改第三个位置的数据）a b z d e–第三种遍历方法—Iterator迭代器（去掉第二个位置的数据）a z d e LinkedList 与 ArrayList 一样，LinkedList 也按照索引位置排序，但它的元素之间是双向链表的 适合快速地插入和删除元素 LinkedList 实现 List 和 Queue 两个接口 案例一：使用 LinkedList 对字符串进行管理 123456789101112131415161718192021222324252627282930import java.util.LinkedList;public class Main&#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;(); //向链表添加数据 list.add("apple"); list.add("pear"); //将数据插入链表头 list.addFirst("banana"); //将数据插入链表的末尾 list.addLast("grape"); //在指定位置添加数据 list.add(2,"orange"); //显示链表中的所有数据 System.out.println(list); //判断链表中是否包含指定元素 if (list.contains("Mast"))&#123; System.out.println("'Mast'存在"); &#125;else &#123; System.out.println("'Mast'不存在"); &#125; //返回位置3的元素 System.out.println("位置3的元素是：" + list.get(2)); //返回第一个元素 System.out.println("第一个元素是：" + list.getFirst()); //返回最后一个元素 System.out.println("最后一个元素是：" + list.getLast()); &#125;&#125; 运行结果 [banana, apple, orange, pear, grape]‘Mast’不存在位置3的元素是：orange第一个元素是：banana最后一个元素是：grape 案例二：使用 LinkedList 对自定义类进行管理 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Student &#123; private Integer stuNum; private String stuName; private Integer stuAge; public Student(Integer stuNum, String stuName, Integer stuAge) &#123; this.stuNum = stuNum; this.stuName = stuName; this.stuAge = stuAge; &#125; public Integer getStuNum() &#123; return stuNum; &#125; public void setStuNum(Integer stuNum) &#123; this.stuNum = stuNum; &#125; public String getStuName() &#123; return stuName; &#125; public void setStuName(String stuName) &#123; this.stuName = stuName; &#125; public Integer getStuAge() &#123; return stuAge; &#125; public void setStuAge(Integer stuAge) &#123; this.stuAge = stuAge; &#125; @Override public String toString() &#123; return "Student&#123;" + "stuNum=" + stuNum + ", stuName='" + stuName + '\'' + ", stuAge=" + stuAge + '&#125;'; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435import java.util.LinkedList;public class Main&#123; public static void main(String[] args) &#123; LinkedList&lt;Student&gt; stulist = new LinkedList&lt;Student&gt;(); Student s1 = new Student(0001,"Jack",18); Student s2 = new Student(0002,"Mike",20); Student s3 = new Student(0003,"Lucy",19); //将学生添加到链表，使用push完成 //LinkedList 实现 List 接口的同时，也实现了 Queue 接口 //push 和 pop 就是针对 Queue 进行添加和取出数据的操作 stulist.push(s1); stulist.push(s2); stulist.push(s3); System.out.println("链表为：" + stulist); //弹出一个元素，这里可以把链表看成一个容器，先加入链表里的元素后弹出 //依据先进后出的原则 System.out.println("弹出的数据为：" + stulist.pop()); System.out.println("调用 pop() 方法后的链表为：" + stulist); //peek() 方法获取并不移除元素 System.out.println("调用 peek() 方法的数据为：" + stulist.peek()); System.out.println("调用 peek() 方法后的链表为：" + stulist); //再次调用 pop() 方法，发现调用 pop() 方法后，数据从链表中移除了而 peek() 方法不会 System.out.println("弹出的数据为：" + stulist.pop()); System.out.println("调用 pop() 方法后的链表为：" + stulist); //重新添加元素 stulist.push(s2); stulist.push(s3); System.out.println("重新添加元素后的链表为：" + stulist); //调用 poll() 方法 System.out.println("调用 poll() 方法的数据为：" + stulist.poll()); //调用 poll() 方法在获取了元素的同时删除了链表中的元素 System.out.println("调用 poll() 方法后的链表为：" + stulist); &#125;&#125; 运行结果 链表为：[Student{stuNum=3, stuName=’Lucy’, stuAge=19}, Student{stuNum=2, stuName=’Mike’, stuAge=20}, Student{stuNum=1, stuName=’Jack’, stuAge=18}]弹出的数据为：Student{stuNum=3, stuName=’Lucy’, stuAge=19}调用 pop() 方法后的链表为：[Student{stuNum=2, stuName=’Mike’, stuAge=20}, Student{stuNum=1, stuName=’Jack’, stuAge=18}]调用 peek() 方法的数据为：Student{stuNum=2, stuName=’Mike’, stuAge=20}调用 peek() 方法后的链表为：[Student{stuNum=2, stuName=’Mike’, stuAge=20}, Student{stuNum=1, stuName=’Jack’, stuAge=18}]弹出的数据为：Student{stuNum=2, stuName=’Mike’, stuAge=20}调用 pop() 方法后的链表为：[Student{stuNum=1, stuName=’Jack’, stuAge=18}]重新添加元素后的链表为：[Student{stuNum=3, stuName=’Lucy’, stuAge=19}, Student{stuNum=2, stuName=’Mike’, stuAge=20}, Student{stuNum=1, stuName=’Jack’, stuAge=18}]调用 poll() 方法的数据为：Student{stuNum=3, stuName=’Lucy’, stuAge=19}调用 poll() 方法后的链表为：[Student{stuNum=2, stuName=’Mike’, stuAge=20}, Student{stuNum=1, stuName=’Jack’, stuAge=18}] 我们在这里发现，好像 pop() 和 poll() 的作用是一样的。 pop() 和 poll() 的区别poll是队列数据结构实现类的方法，从队首获取元素，同时获取的这个元素将从原队列删除； pop是栈结构的实现类的方法，表示返回栈顶的元素，同时该元素从栈中删除，当栈中没有元素时，调用该方法会发生异常 其实，这两个函数的代码实现是基本一致的，如果一定要说区别那么就是当头结点为空的时候，两个函数的处理方式不同：poll()选择返回null，pop()选择抛出异常。 ArrayList 和 LinkedList 的区别 ArrayList 和 LinkedLis t可想从名字分析，它们一个是 Array（动态数组）的数据结构，一个是 Link（链表）的数据结构，此外，它们两个都是对 List 接口的实现。 前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列 当随机访问 List 时（ get 和 set 操作），ArrayList 比 LinkedList 的效率更高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。 当对数据进行增加和删除的操作时( add 和 remove 操作)，LinkedList 比 ArrayList 的效率更高，因为ArrayList 是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。 从利用效率来看，ArrayList 自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而 LinkedList 自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。 线程都不安全]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础十二--线程]]></title>
    <url>%2F2018%2F10%2F29%2FJava%E5%9F%BA%E7%A1%80%E5%8D%81%E4%BA%8C%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础十一--集合]]></title>
    <url>%2F2018%2F10%2F29%2FJava%E5%9F%BA%E7%A1%80%E5%8D%81%E4%B8%80%2F</url>
    <content type="text"><![CDATA[在编程中，常常需要集中存放多个数据。从传统意义上讲，数组是我们的一个很好的选择，前提是我们事先已经明确知道我们将要保存的对象的数量。一旦在数组初始化时指定了这个数组长度，这个数组长度就是不可变的，如果我们需要保存一个可以动态增长的数据（在编译时无法确定具体的数量），Java 的集合类就是一个很好的设计方案了。 Collection 接口collection是个接口，它下面有两个子接口分别是 List 和 Set。 List 又有三个类，ArrayList、LinkList和Vector Set 又分为 HashSet、TreeSet TreeSte是二叉树，有序的 HashSet采用散列存储，是无序的 Map 接口Map 集合使用键（key）值（value）来保存数据，其中值（value）可以重复，但键（key）必须是唯一，也可以为空，但最多只能有一个 key 为空，它的主要实现类有 HashMap、LinkedHashMap、TreeMap、Hashtable（过时了）。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>List、Set、Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础十--泛型]]></title>
    <url>%2F2018%2F10%2F29%2FJava%E5%9F%BA%E7%A1%80%E5%8D%81%2F</url>
    <content type="text"><![CDATA[Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？ 答案是可以使用 Java 泛型。 使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。 泛型方法你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。 下面是定义泛型方法的规则： 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的）。 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用类型，不能是基本数据类型（像int,double,char的等）。 下面的例子演示了如何使用泛型方法打印不同字符串的元素： 123456789101112131415161718192021public class Main&#123; public static &lt;T&gt; void printArray(T[] arr)&#123; for (T i : arr) &#123; System.out.print(i + " "); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; //定义不同类型的数组 Integer[] i = &#123;1,2,3,4,5,6&#125;; Double[] d = &#123;2.1,3.2,4.7,5.8,6.7&#125;; Character[] c = &#123;'a','b','c','d','e','f','g'&#125;; System.out.println("整形数组元素："); printArray(i); System.out.println("双精度型数组元素："); printArray(d); System.out.println("字符型数组元素："); printArray(c); &#125;&#125; 运行结果： 整形数组元素：1 2 3 4 5 6双精度型数组元素：2.1 3.2 4.7 5.8 6.7字符型数组元素：a b c d e f g 有界的类型参数可能有时候，你会想限制那些被允许传递到一个类型参数的类型种类范围。例如，一个操作数字的方法可能只希望接受Number或者Number子类的实例。这就是有界类型参数的目的。 要声明一个有界的类型参数，首先列出类型参数的名称，后跟extends关键字，最后紧跟它的上界。 下面的例子演示了”extends”如何使用在一般意义上的意思”extends”（类）或者”implements”（接口）。 该例子中的泛型方法返回三个可比较对象的最大值。 1234567891011121314151617public class Main&#123; public static &lt;T extends Comparable&lt;T&gt;&gt; T maxNum(T x,T y,T z)&#123; T max = x; if (y.compareTo(x) &gt; 0)&#123; max = y; &#125; if (z.compareTo(max) &gt; 0)&#123; max = z; &#125; return max; &#125; public static void main(String[] args) &#123; System.out.println("3、4、5中最大的数是：" + maxNum(3,4,5)); System.out.println("3.1f、4.5f、5.1f中最大的数是：" + maxNum(3.1f,4.5f,5.1f)); System.out.println("'A'、'a'、'C'中最大的数是：" + maxNum('A','a','C')); &#125;&#125; 运行结果： 3、4、5中最大的数是：53.1f、4.5f、5.1f中最大的数是：5.1‘A’、’a’、’C’中最大的数是：a 泛型类泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。 和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。 如下实例演示了我们如何定义一个泛型类： 1234567891011121314151617public class Main&lt;T&gt;&#123; private T t; public void add(T t)&#123; this.t = t; &#125; public T getT()&#123; return t; &#125; public static void main(String[] args) &#123; Main&lt;Integer&gt; integerMain = new Main&lt;Integer&gt;(); Main&lt;String&gt; stringMain = new Main&lt;String&gt;(); integerMain.add(new Integer(10)); stringMain.add(new String("泛型")); System.out.println("整型值为："+integerMain.getT()); System.out.println("字符串为："+stringMain.getT()); &#125;&#125; 运行结果： 整型值为：10字符串为：泛型 类型通配符 类型通配符一般是使用 ? 代替具体的类型参数。例如 List&lt;?&gt; 在逻辑上是List,List 等所有List&lt;具体类型实参&gt;的父类。 123456789101112131415161718192021222324import com.sun.org.apache.xerces.internal.xs.StringList;import java.util.ArrayList;import java.util.List;public class Main&lt;T&gt;&#123; public static void main(String[] args) &#123; List&lt;String&gt; name = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; age = new ArrayList&lt;Integer&gt;(); List&lt;Number&gt; number = new ArrayList&lt;Number&gt;(); name.add("张三"); age.add(18); number.add(3.14); getData(name); getData(age); getData(number); &#125; public static void getData(List&lt;?&gt; data)&#123; System.out.println("data：" + data.get(0)); &#125;&#125; 运行结果： data：张三data：18data：3.14 因为 getData() 方法的参数是 List 类型的，所以 name，age，number 都可以作为这个方法的实参，这就是通配符的作用。 类型通配符上限通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型。 1234567891011121314151617181920212223242526272829import com.sun.org.apache.xerces.internal.xs.StringList;import java.util.ArrayList;import java.util.List;public class Main&lt;T&gt;&#123; public static void main(String[] args) &#123; List&lt;String&gt; name = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; age = new ArrayList&lt;Integer&gt;(); List&lt;Number&gt; number = new ArrayList&lt;Number&gt;(); name.add("张三"); age.add(18); number.add(3.14); //getUperNumber(name);//因为 name 定义的时候是 String 类型，所以会报错 getUperNumber(age); getUperNumber(number); &#125; public static void getData(List&lt;?&gt; data)&#123; System.out.println("data：" + data.get(0)); &#125; public static void getUperNumber(List&lt;? extends Number&gt; data)&#123; System.out.println("data：" + data.get(0)); &#125;&#125; 运行结果： data：18data：3.14 在注释处会出现错误，因为 getUperNumber() 方法中的参数已经限定了参数泛型上限为 Number，所以泛型为 String 是不在这个范围之内，所以会报错。 类型通配符下限通过形如 List&lt;? super Number&gt;来定义，表示类型只能接受Number及其三层父类类型，如Objec类型的实例。 &lt; ? extends T &gt;和&lt; ? super T &gt;的区别 &lt; ? extends T &gt; 表示该通配符所代表的类型是T类型的子类。 &lt; ? super T &gt; 表示该通配符所代表的类型是T类型的父类。 注意对于泛型，只是允许程序员在编译时检测到非法的类型而已。 但是在运行期时，其中的泛型标志会变化为 Object 类型。 12345678910111213141516171819202122232425import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.List;public class Main&#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(12); //list.add('a');//这么添加会报错 Class&lt; ? extends List&gt; clazz = list.getClass(); try &#123; Method add = clazz.getDeclaredMethod("add", Object.class);//但是通过反射添加是可以的 add.invoke(list,'a'); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; System.out.println(list); &#125;&#125; 运行结果： [12, a]]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础九--字符串]]></title>
    <url>%2F2018%2F10%2F27%2FJava%E5%9F%BA%E7%A1%80%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[字符串广泛应用在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String、StringBuffer、StringBuilder类来创建和操作字符串。 String创建对象12345678910public class Main&#123; public static void main(String[] args) &#123; String s1 = "这是字符串1"; String s2 = new String();//这里创建了一个空字符串 String s3 = new String("这是字符串3"); System.out.println(s1); System.out.println(s2); System.out.println(s3); &#125;&#125; 运行结果 这是字符串1 这是字符串3 String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，比如提供一个字符数组参数: 1234567public class Main&#123; public static void main(String[] args) &#123; char[] name = &#123;'C','h','i','n','a'&#125;; String str = new String(name); System.out.println(str); &#125;&#125; 运行结果 China 注意：String 类是不可改变的，所以你一旦创建了 String 对象，那么它的值就不能改了。 常用方法 方法 说明 int length() 返回当前字符串的长度 int indexOf(int ch) 查找ch字符在该字符串中第一次出现的位置 int indexOf(String str) 查找str子字符串在该字符串中第一次出现的位置 int lastIndexOf(int ch) 查找ch字符在该字符串中最后一次出现的位置 int lastIndexOf(String str) 查找str子字符串在该字符串中最后一次出现的位置 String substring(int beginIndex) 获取从beginIndex位置开始到结束的子字符串 String substring(int beginIndex,int endIndex) 获取从beginIndex位置开始到endIndex位置的子字符串[beginIndex,endIndex) String trim() 返回去除了前后空格的字符串 boolean equals(Object obj) 将该字符串与指定对象比较，返回true或者false String toLowerCase() 将字符串转换为小写 String toUpperCase() 将字符串转换为大写 char charAt(int index) 获取字符串中指定位置的字符 String[] split(String regex,int li) 将字符串分割为子字符串，返回字符串数组 byte[] getBytes() 将该字符串转换为byte数组 这里先介绍length()、charAt()、substring()、indexOf()、lastIndexOf()的方法 123456789101112public class Main&#123; public static void main(String[] args) &#123; String str = "Java编程基础，我喜欢Java编程"; System.out.println("字符串长度："+str.length()); System.out.println("字符串中第5个位置是："+str.charAt(5)); System.out.println("从4位置开始到结束的子字符串："+str.substring(4)); System.out.println("从4位置开始到6位置结束的子字符串[4,6)："+str.substring(4,6)); System.out.println("查找“编程”在该字符串中第一次出现的位置："+str.indexOf("编程")); System.out.println("查找“编程”在该字符串中最后一次出现的位置："+str.lastIndexOf("编程")); System.out.println("从8位置开始，查找子串“编程”第一次出现的位置："+str.indexOf("编程", 8)); &#125;&#125; 运行结果 字符串长度：18字符串中第5个位置是：程从4位置开始到结束的子字符串：编程基础，我喜欢Java编程从4位置开始到6位置结束的子字符串：编程查找“编程”在该字符串中第一次出现的位置：4查找“编程”在该字符串中最后一次出现的位置：16从8位置开始，查找子串“编程”第一次出现的位置：16 字符串和 byte 数组之间相互转换 123456789101112131415public class Main&#123; public static void main(String[] args) &#123; String str = "Java 编程 基础"; //将字符串转换为 byte 数组，并打印输出 byte[] bytes = str.getBytes(); for (byte i : bytes) &#123; System.out.print(i + " "); &#125; System.out.println(); //将 byte 数组转换为字符串 String str1 = new String(bytes); System.out.println(str1); &#125;&#125; 运行结果 74 97 118 97 32 -25 -68 -106 -25 -88 -117 32 -27 -97 -70 -25 -95 -128Java 编程 基础 为什么会出现这么一堆东西？ 这一堆数字其实就是字符串每一位所对应的ASCII码值，J的ASCII码值是74，a的ASCII码值是97，空格的ASCII码值是32，以此类推。那么负数是什么呢，因为默认用的是UTF-8编码，所以这里每三个负数对应一个汉字，即“编”对应-25 -68 -106，“程”对应-25 -88 -117。 在 String 中，除了有String(byte[] bytes)这个构造方法以外，还有一个构造方法String(byte[] bytes,Charset charset)，Charset 字符集。我们来看下面的代码 12345678910111213141516171819202122import java.io.UnsupportedEncodingException;public class Main&#123; public static void main(String[] args) &#123; String str = "Java 编程 基础"; //将字符串转换为 byte 数组，并打印输出 byte[] bytes = str.getBytes(); for (byte i : bytes) &#123; System.out.print(i + " "); &#125; System.out.println(); //将 byte 数组转换为字符串 String str1 = null; try &#123; str1 = new String(bytes,"GBK"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; System.out.println(str1); &#125;&#125; 运行结果 74 97 118 97 32 -25 -68 -106 -25 -88 -117 32 -27 -97 -70 -25 -95 -128Java 缂栫▼ 鍩虹 出现乱码了！为什么会这样？ 这是因为 String 转 byte 数组的时候用的是UTF-8，而 byte 转 String 的时候用的却是 GBK，编码不统一导致的。 如果你就是想用 GBK 编码的话，可以这么写 123456789101112131415161718192021222324252627import java.io.UnsupportedEncodingException;public class Main&#123; public static void main(String[] args) &#123; String str = "Java 编程 基础"; //将字符串转换为 byte 数组，并打印输出 byte[] bytes = new byte[0]; try &#123; bytes = str.getBytes("GBK");//byte[] getBytes(Charset charset) &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; for (byte i : bytes) &#123; System.out.print(i + " "); &#125; System.out.println(); //将 byte 数组转换为字符串 String str1 = null; try &#123; str1 = new String(bytes,"GBK"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; System.out.println(str1); &#125;&#125; 运行结果 74 97 118 97 32 -25 -68 -106 -25 -88 -117 32 -27 -97 -70 -25 -95 -128Java 编程 基础 存储我们来看这么一段代码 1234567891011121314public class Main&#123; public static void main(String[] args) &#123; String s1 = "string"; String s2 = "string"; String s3 = new String("string"); String s4 = new String("string"); System.out.println(s1==s2); System.out.println(s1.equals(s2)); System.out.println(s1==s3); System.out.println(s1.equals(s3)); System.out.println(s3==s4); System.out.println(s3.equals(s4)); &#125;&#125; 运行结果 truetruefalsetruefalsetrue 为什么会出现这样的情况呢？当你用String s1 = “string”;创建字符串的时候，“string” 是存放在常量池里的。当你又用创建 s2 的时候，因为在常量池中已经存在了一个 “string”，所以 s2 里存放的是 “string” 中的内存地址。但当你用String s3 = new String(“string”);创建对象时，他是存放在堆内存的（实例化对象都是在堆内存中开辟空间）。每创建一个对象，它就开辟一个空间。 StringBuffer和StringBuilder前面有提到，String 是不可变的，一旦创建了 String 对象，那么它的值就不能改了。那么我们要是想要进行多次修改，就要用到 StringBuffer 和 StringBuilder 了。 和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。 StringBuilder 和 StringBuffer 之间最大的不同是在于 StringBuilder 的方法是线程不安全的（不能同步访问）。 由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder。然而在要求线程安全的情况下，必须要用 StringBuffer。 StringBuilder的常用方法 方法 说明 String toString() 将StringBuilder对象转换为String对象 StringBuilder reverse() 将此字符序列用其反转形式取代 StringBuilder append() 追加内容到当前StringBuilder对象的末尾 StringBuilder delete() 移除此序列的子字符串中的字符。 StringBuilder insert() 将内容插入到StringBuilder对象的指定位置 1234567891011public class Main&#123; public static void main(String[] args) &#123; StringBuilder str = new StringBuilder("String"); System.out.println("StringBuilder字符串为："+str.toString(); System.out.println("反转之后："+str.reverse()); System.out.println("再反转回来："+str.reverse()); System.out.println("在末尾添加“String”："+str.append("String")); System.out.println("删除从6位置到12位置的字符[6,12)："+str.delete(6,12)); System.out.println("在位置5上加入“nnnnn”："+str.insert(5,"nnnnn")); &#125;&#125; 运行结果 StringBuilder字符串为：String反转之后：gnirtS再反转回来：String在末尾添加“String”：StringString删除从6位置到12位置的字符[6,12)：String在位置5上加入“nnnnn”：Strinnnnnng String、StringBuffer和StringBuilder区别可变性String 类中使用字符数组保存字符串，private final char value[];,所以 String 对象是不可变的。 StringBuffer 和 StringBuilder 是继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也使用字符数组保存字符串char[] value;没有被 final修饰，所以 StringBuffer 和 StringBuilder 都是可变的。 线程安全String 中的对象是不可变的，也就可以理解为常量，所以是线程安全的。 AbstractStringBuilder 是 StringBuffer 和 StringBuilder 的公共父类，定义了一些字符串的基本操作，如 append()、insert()、indexOf()等公共方法。 StringBuffer 对方法加了 synchronized 或者对调用的方法加了 synchronized，所以是线程安全的。 StringBuilder 并没有对方法加锁，所以是非线程安全的。 性能每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后指针指向新的 String 对象。 StringBuffer 每次都会对 StringBuffer 对象本身进行改变，而不是生成新的对象并改变对象的引用。 相同情况下，使用 StringBuilder 相比使用 StringBuffer 仅能获得10%-15%的性能提升，但是要冒着线程不安全的风险。 总结String：操作少量的数据 StringBuilder：单线程下操作大量数据 StringBuffer：多线程下操作大量数据 ==和equals()方法==它的作用是比较两个对象的地址是不是相等的。即，判断两个对象是不是同一个对象。（基本数据类型\==比较的是值，引用数据类型\==比较的是内存地址） equals()它的作用也是判断两个对象是否相等，但它一般有两种使用情况： 情况一类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象是，等价于通过“==”比较这两个对象。 情况二类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来判断两个对象的内容是否相等。若他们的内容相等，则返回 true（即，认为这两个对象是相等的）。 举个例子： 1234567891011121314151617181920public class Main&#123; public static void main(String[] args) &#123; String a = new String("ab");// a 为一个引用 String b = new String("ab");// b为另一个引用,对象的内容一样 String aa = "ab";// 放在常量池中 String bb = "ab";// 从常量池中查找 if (a == b)&#123;// false，非同一对象 System.out.println("a == b"); &#125; if (aa == bb)&#123;//true System.out.println("aa == bb "); &#125; if (a.equals(b))&#123;//true System.out.println("aEQb"); &#125; if (42 == 42.0)&#123;//true System.out.println("true"); &#125; &#125;&#125; 运行结果 aa == bbaEQbtrue 说明： String 中的 equals() 方法是被重写过的，因为 Object 的 equals() 是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有，就把它赋给当前的引用，如果没有就在常量池中重新创建一个 String 对象。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>String、StringBuffer、StringBuilder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础八--异常]]></title>
    <url>%2F2018%2F10%2F25%2FJava%E5%9F%BA%E7%A1%80%E5%85%AB%2F</url>
    <content type="text"><![CDATA[异常字面翻译就是“意外、例外”的意思，也就是说非正常情况。 在程序运行过程中，意外发生的情况，背离我们程序本身的意图的表现，都可以理解为异常 Java 中的异常本质上是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。 利用 Java 中的异常处理机制，我们可以更好地提升程序的健壮性 要理解 Java 异常处理是如何工作的，需要掌握以下三种类型的异常： 检查型异常：最具代表的检查性异常时用户错误或问题引起的异常，这是我们无法预见的。例如要打开一个不存在的文件，一个异常就发生了，这些异常在编译时不能被简单的忽略。 运行时异常：运行时异常时可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略 错误：错误不是异常，而是脱离我们控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，他们在编译也检查不到。 异常的分类在程序开发中，异常指不期而至的各种状况。他是一个事件，当发生在程序运行期间时，会干扰正常的指令流程。 在 Java 中，通过 Throwable 及其子类描述各种不同的异常类型 Throwable 有两个重要的子类：Exception 和 Error ErrorError 是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而代表代码运行时 JVM 出现的问题 例如，Java 虚拟机运行错误，当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError 这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。 对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。 因此我们编写程序时不需要关心这类异常 ExceptionException 是程序本身可以处理的异常。异常处理通常指针对这种类型异常的处理。 Exception 类的异常包括 unchecked exception（非检查型异常） 和 checked exception（检查型异常） unchecked exception unchecked exception：编译器不要求强制处置的异常。 包含 RunntimeException 类及其子类异常 如 NullPointerException（空指针异常）、IndexOutOfBoundsException（下标越界异常）等，这些异常时unchecked exception。 Java 编译器不会检查这些异常，在程序中可以选择捕获处理，也可以不处理，照样正常编译通过 checked exception checked exception：编译器要求必须处置的异常 是 RunntimeException 类及其子类以外，其他的 Exception 类的子类 如 IOException、SQLException 等 Java 编译器会检查这些异常，当程序中可能出现这类异常时，要求必须进行异常处理，否则编译不会通过 异常处理在 Java 应用程序中，异常处理机制为：抛出异常、捕获异常 抛出异常 当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统 异常对象中包含了异常类型和异常出现时的程序状态等异常信息 运行时系统负责寻找处置异常的代码并执行 捕获异常 在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器 运行时系统从发生异常的方法开始，依次回查调用栈中的方法，当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器 当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着 Java 程序的终止 对于运行时异常、错误或可查异常，Java 技术所要求的的异常处理方式有所不同 总体来说，Java 规定：对于可查异常必捕获、或者声明抛出。允许忽略不可查的 RuntimeException 和 Error 简单的来说，异常总是先被抛出，后被捕获的 异常处理通过5个关键字来实现：try、catch、finally、throw、throws try-catch-finally12345678910public void method()&#123; try&#123; //代码段1 //产生异常的代码段2 &#125;catch(异常类型 e)&#123; //对异常进行处理的代码段3 &#125;finally&#123; //代码段4 &#125;&#125; try-catch 使用 try-catch 块捕获并处理异常 12345678public void method()&#123; try&#123; //代码段 &#125;catch(异常类型 e)&#123; //对异常进行处理的代码段 &#125; //代码段&#125; 使用 try-catch 块捕获并处理异常——无异常 12345678public void method()&#123; try&#123; //代码段（此处不会产生异常） &#125;catch(异常类型 e)&#123; //对异常进行处理的代码段 &#125; //代码段&#125; 使用 try-catch 块捕获并处理异常——有异常并能正常匹配处理 12345678910public void method()&#123; try&#123; //代码段1 //产生异常的代码段2 //代码段3 &#125;catch(异常类型 e)&#123; //对异常进行处理的代码段4 &#125; //代码段5&#125; 使用 try-catch 块捕获并处理异常——有异常不能正常匹配处理 12345678910public void method()&#123; try&#123; //代码段1 //产生异常的代码段2 //代码段3 &#125;catch(异常类型 e)&#123; //对异常进行处理的代码段4 &#125; //代码段5&#125; 多重 catch 块 一旦某个 catch 捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个 tr-catch 语句结束。其他的 catch 子句不再有匹配和捕获异常类型的机会。 对于有多个 catch 子句的异常程序而言，应该尽量将捕获底层异常类的 catch 子句放在前面，同时尽量将捕获相对高层的异常类的 catch 子句放在后面。否则，捕获底层异常类 catch 子句将可能会被屏蔽。 引发多种类型的异常 排列 catch 语句的顺序：先子类后父类 发生异常时按顺序逐个匹配 只执行第一个与异常类型匹配的 catch 语句 12345678910111213public void method()&#123; try&#123; //代码段 //产生异常（类型2） &#125;catch(异常类型1 e)&#123; //对异常处理的代码 &#125;catch(异常类型2 e)&#123; //对异常处理的代码 &#125;catch(异常类型3 e)&#123; //对异常处理的代码 &#125; //代码段&#125; try-ctach-finally try 块后可以接零个或者多个 catch 块 如果没有 catch，则必须跟一个 finally 块 catch、finally可选 语法组合： try-catch try-finally try-catch-finally try-catch-catch-finally 在 try-catch 块后加入 finally 块 是否发生异常都执行 不执行的唯一情况 1234567891011121314public class Main&#123; public static void main(String args[]) &#123; System.out.println("普通代码"); try &#123; System.out.println("try"); throw new Exception(); &#125;catch (Exception e)&#123; System.out.println("catch"); System.exit(1); &#125;finally &#123; System.out.println("finally"); &#125; &#125;&#125; 运行结果： 普通代码 try catch 一旦在 try 块或者 catch 块中加入 System.exit(1) 这个语句 finally 语句块将会强制终止执行 其实还要一种情况，当 try 块没有执行的话，finally 也不会被执行，也就是说，当一个方法在 try 块之前就返回了，那么他的 finally 块就不会被执行。 123456789101112131415161718192021222324public class Main&#123; public static void main(String args[]) &#123; String str= method(); System.out.println(str); &#125; public static String method()&#123; int a = 3; if (a&lt;4)&#123; return "finally 没有执行"; &#125; System.out.println("普通代码"); try &#123; System.out.println("try"); throw new Exception(); &#125;catch (Exception e)&#123; System.out.println("catch"); System.exit(1); &#125;finally &#123; System.out.println("finally"); &#125; return "finally 执行了"; &#125;&#125; 运行结果： finally 没有执行 try-catch-finally的执行情况 实际应用中的经验与总结 处理运行时异常时，采用逻辑去合理规避同时辅助 try-catch 处理 在多重 catch 块后面，可以加上 catch(Exception e)来处理可能会被遗漏的异常 对于不确定的代码，也可以加上 try-catch，处理潜在的异常 尽量去处理异常，切记只是简单地调用 printStackTrace() 去打印输出 具体如何处理异常，要根据不同的业务需求和异常类型去决定 尽量添加 finally 语句块去释放占用的资源 不执行 finally 块有两种方式 try 语句没有被执行到，如在 try 语句之前 return 就返回了，这样 finally 语句就不会执行。这也说明了 finally 语句被执行的必要而非充分条件是：相应的 try 语句一定被执行到 在 try 块 catch 块中有 System.exit(0); 这样的语句。System.exit(0) 是终止 Java 虚拟机 JVM 的，连 JVM 都停止了，所有都结束了，当然 finally 语句也不会被执行到。 在 try-catch-finally 中, 当 return 遇到 finally，return 对 finally 无效 在try catch块里return的时候，finally也会被执行 finally 里的 return 语句会把 try catch 块里的 return 语句效果给覆盖掉 throw&amp;throws可以通过 throws 声明将要抛出何种类型的异常，通过 throw将产生的异常抛出 throws 如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用 throws 子句来声明抛出异常 例如：汽车在运行时可能会出现故障，汽车本身没有办法处理这个故障，那就让开车的人来处理 throws 语句用在方法定义时声明该方法要抛出的异常类型 123public void method() throws Exception1，Exception2,...,ExceptionN&#123; //可能产生异常的代码&#125; 当方法抛出异常列表中的异常时，方法不对这些类型及其子类类型的异常作处理，而抛向调用该方法的方法，由他去处理 throws的使用规则 如果是不可检查异常（unchecked exception），即 Error 、RuntimeException 或他们的子类，那么可以不适用 throws 关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出 如果一个方法中可能出现可查异常，要么用 try-catch 语句捕获，要么用 throws 子句声明将它抛出，否则会导致编译错误 当抛出了异常，则该方法的调用者必须处理或者重新抛出该异常 当子类重写父类抛出异常的方法时，声明的异常必须是父类方法所声明异常的同类或子类 throw throw 用来抛出一个异常 例如：throw new IOException(); trhow 抛出的只能是可抛出类 Throwable 或其子类的实例对象 例如：throw new String(“出错啦！”);//是错误的 12345678public void method()&#123; try&#123; //代码段1 throw new 异常类型(); &#125;catch(异常类型 e)&#123; //对异常进行处理的代码段2 &#125;&#125; 1234public void method() throw 异常类型&#123; //代码段1 throw new 异常类型();&#125; 自定义异常 使用 Java 内置的异常类可以描述在编程时出现的大部分异常情况 也可以通过自定义异常描述特定业务产生的异常类型 所谓自定义异常，就是定义一个类，去继承 Throwable 类或者它的子类 如果希望写一个检查性异常类，则需要继承 Exception 类 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类 异常链 有时候我们会捕捉一个异常后再抛出另一个异常 顾名思义就是：将异常发生的原因一个传一个穿起来，即把底层的异常信息传给上层，这样逐层抛出 Java 常见异常类型及原因分析常见的异常类型 异常类型 说明 Exception 异常层次结构的父类 ArithmeticException 算术错误情形，如以零作除数 ArrayIndexOutOfBoundsException 数组下标越界 NullPointerException 尝试访问 null 对象成员 ClassNotFoundException 不能加载所需的类 IllegalArgumentException 方法接受到非法参数 ClassCastException 对象强制类型转换出错 NumberFormatException 数字格式转换异常，如把“abc”转换为数字 NullPointerException 异常顾名思义，空指针异常，这可能是最常遇见的异常了。但是在 Java 中没有指针，怎么会有空指针异常呢？ 在 C++ 中，声明的指针需要指向一个实例（通过 new 方法构造），这个指针可以理解为地址。在 Java 中，虽然没有指针，但是有引用（通常称为对象引用，一般直接说对象），引用也是要指向一个实例对象（通过 new 方法构造）的，从某种意义上说，Java 中的引用与 C++ 中的指针没有本质区别，不同的是，出于安全的目的，在 Java 中不能对引用进行操作，而在 C++ 中可以直接进行指针的运算。 所以这里的 NullPointerException 虽然不是真正的空指针异常，但本质上差不多，是因为引用没有指向具体的实例，所以当访问这个引用的时候就会产生这种异常。例如： 123456public class Main&#123; public static void main(String args[]) &#123; String str = "这是一个测试字符串"; System.out.println(str.length()); &#125;&#125; 运行结果： 9 这段代码是没有问题的，但是如果改成下面的代码： 123456public class Main&#123; public static void main(String args[]) &#123; String str = null; System.out.println(str.length()); &#125;&#125; 运行结果： Exception in thread “main” java.lang.NullPointerException​ at Main.main(Main.java:4) 这就产生了 NullPointerException 异常了 这种异常是如何产生的呢 把调用某个方法的返回值直接赋值给某个引用，然后调用这个引用的方法。在这种情况下，如果返回的值是Null，必然会产生 NullPointerException 异常。例如： 1234567891011121314151617181920public class People &#123; private String Name; private int age; public String getName() &#123; return Name; &#125; public void setName(String name) &#123; Name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 1234567public class Main&#123; public static void main(String args[]) &#123; People p = null; p.setName("张三"); System.out.println(p.getName()); &#125;&#125; 分析：声明一个 People对象，并打印出该对象的 Name 值 说明：这个时候你的 p 就出现了空指针异常，因为你只是声明了 People 类型的对象，并没有创建对象，所以它的堆里面没有地址引用，切记你要用对象调用方法的时候，一定要先创建对象。 在方法体中调用参数的方法 如果调用方法的时候传递进来的值是 null，也要产生 NullPointerException 异常。 要避免程序产生这种异常，比较好的解决方法是在调用某个对象的方法时候判断这个对象是否可能为空，如果可能，则增加判断语句，例如上面的代码就可以写为： 123456789101112public class Main&#123; public static void main(String args[]) &#123; People p = null; if (p == null) &#123; p = new People(); p.setName("张三"); &#125;else &#123; p.setName("张三"); &#125; System.out.println(p.getName()); &#125;&#125; ClassCastException 异常从字面上看，是类型转换异常，通常是进行强制类型转换时候出现的错误。下面对产生 ClassCastException 异常的原因进行分析，然后给出这种异常的解决方法 这种异常是如何产生的呢我们来看下面这段代码 这里 Animal 表示动物类，Dog 类表示狗类，Cat 类表示猫类，Dog 和 Cat 是 Animal 类的子类。 12345678public class Main&#123; public static void main(String args[]) &#123; Animal a1 = new Dog(); Animal a2 = new Cat(); Dog d1 = (Dog) a1; Dog d2 = (Dog) a2; &#125;&#125; 运行结果 Exception in thread “main” java.lang.ClassCastException: Cat cannot be cast to Dog​ at Main.main(Main.java:6) 第5行和第6行代码基本相同，从字面意思上来看都是把 Animal 强制转换为 Dog，但是第六行代码产生了 ClassCastException 异常，说 Cat cannot be cast to Dog 。 这下就很好理解了，我在 Java 基础七-多态里的向下转型中有说到，因为 a1 本身就是 Dog 对象，所以它理所当然的可以转型为 Dog，a2 本身是 Cat 对象，所以它也理所当然的不能转为 Dog 。猫狗之间能互换吗？ 从上面的例子可以看出，ClassCastException 是进行强制类型转换的时候产生的异常。 强制类型转换的前提是父类引用指向的对象的类型是子类的时候才可以进行强制类型转换，如果父类引用指向的对象类型不是子类的时候就会产生 ClassCastException 异常。 遇到这个异常该怎么办呢？如果你知道要访问的对象的具体类型，直接转换成该类型即可。如果不能确定类型可以通过下面的两种方式进行处理（假设对象为 o ）： 通过o.getClass().getName()&gt;得到具体的类型，可以通过输出语句输出这个类型，然后根据类型进行具体的处理 通过if(o instanceof 类型)的语句来判断 o 的类型是什么 ArrayIndexOutOfBoundsException 异常这是一个非常常见的异常，从名字上看是数组下标越界错误，解决这个异常的方法就是查看为什么数组下标越界。 下面有一个错误实例。 12345678public class Main&#123; public static void main(String args[]) &#123; int[] a = &#123;1,2,3,4,5&#125;; for (int i = 0; i &lt; 6; i++) &#123; System.out.print(a[i] + " "); &#125; &#125;&#125; 运行结果 1 2 3 4 5 Exception in thread “main” java.lang.ArrayIndexOutOfBoundsException: 5​ at Main.main(Main.java:5) 1.我们可以看到错误在第5行 2.发生错误的时候，下标的值是5 接下来，我们分析为什么下标值是5的会出错就可以了。 NumberFormatException 异常数字转换异常，在把一个表示数字的字符串转换成数字类型的时候会后可能会报这个异常，原因是作为参数的字符串不是由数字组成的。 12345678public class Main&#123; public static void main(String args[]) &#123; String num1 = "123"; String num2 = "123 "; System.out.println(Integer.parseInt(num1)); System.out.println(Integer.parseInt(num2)); &#125;&#125; 运行结果 123Exception in thread “main” java.lang.NumberFormatException: For input string: “123 “​ at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)​ at java.lang.Integer.parseInt(Integer.java:580)​ at java.lang.Integer.parseInt(Integer.java:615)​ at Main.main(Main.java:6) 这是因为 num2 后面有一个空格。 堆栈溢出和内存溢出在递归调用的时候可能会产生堆栈溢出的情况，因为递归调用的时候需要把调用的状态保存起来，如果递归的深度达到一定程度，将产生堆栈溢出的异常。 如果虚拟机内存比较小，而程序对内存要求比较高，则可能产生内存溢出错误]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构一--数组]]></title>
    <url>%2F2018%2F10%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%2F</url>
    <content type="text"><![CDATA[所谓数组，就是相同类型的数据按照顺序组成的一种引用数据类型。 数组数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。 Java 语言中提供的数组是用来存储固定大小的同类型元素。 声明数组在 Java 中有两种声明数组的方式 type[] 变量名 int[] myIntArray; //首选的方法 type 变量名[] int myIntArray[]; //效果相同，但不是首选的方法 创建数组Java 中使用 new 操作符来创建数组 语法格式一：先声明后创建 type[] 变量名; 变量名 = new type[数组中元素的个数]; int[] arr; arr = new int[10]; 创建一个长度为10的数组 语法格式二：声明的同时创建数组 type 变量名[] = new type[数组中元素的个数]; int[] arr = new int[10]； 创建一个长度为10的数组 注意：数组长度必须指定 以上两种方式都叫做动态初始化，也就是说，只有在程序运行之后，你才能知道数组里到底存了那些数据。 语法格式二的命名方式 C 和 C++ 程序员比较熟悉，但是 Java 官方推荐使用第一种，一看知道是 int 型数组，叫 arr。 静态初始化：int[] arr = new int[]{1,2,3}; 在定义的时候直接初始化，大括号里就是数组的值 隐式初始化：数据类型[] 数组名 = {value0，value1…valuek}; 可以不写 new ,直接使用大括号，其实本质上还是调用了 new 的，只是可以不写出来而已，所以叫隐式初始化。 我们回过头来看看下面这句代码 12&gt; int[] arr = new int[10]；&gt; 这句代码都做了什么？ 1.int[] arr：定义了一个 int 型数组的引用，名字叫做 arr，存放在栈中 2.new int[10]：初始化了一个长度为10的 int 型数组，在堆中开辟相应大小的内存 3.int[] arr = new int[10]：将堆中开辟的数组内存地址赋值给数组引用 arr 这样，就可以通过 arr 这个变量，来操作这个数组了 是不是觉得这个过程很熟悉？没错！我们创建对象的过程也是这样的！那是不是证明，数组其实是一个对象呢？ 也没错！ Java 中的数组的确是一个对象，但是是一个特殊的对象，实在是太特殊了，以致我们都不好把它多做对象处理。 这个数组对象并不是从某个类实例化来的，而是由JVM直接创建的，因此查看类名的时候会发现是很奇怪的样子，这个直接创建的对象的父类就是Object，所以可以调用Object中的所有方法，包括你用到的toString()。 数组在内存中的存储数组会被分配连续的内存空间 比如，我们定义一个数组。 123456789101112131415161718192021222324public class Main&#123; public static void main(String[] args) &#123; // 数组大小 int size = 10; // 定义数组 double[] myList = new double[size]; myList[0] = 5.6; myList[1] = 4.5; myList[2] = 3.3; myList[3] = 13.2; myList[4] = 4.0; myList[5] = 34.33; myList[6] = 34.0; myList[7] = 45.45; myList[8] = 99.993; myList[9] = 11123; // 计算所有元素的总和 double total = 0; for (int i = 0; i &lt; size; i++) &#123; total += myList[i]; &#125; System.out.println("总和为： " + total); &#125;&#125; 它在内存空间中的存储如下图所示： 若数组没有赋值，则整型数组的默认值为0，其他类型的数组按照数据类型确定数组的默认值。 处理数组数组的元素类型和数组的大小都是确定的，所以当处理数组元素的时候，我们通常用基本循环或者 foreach 循环 下面的例子就展示了数组的创建、初始化和操纵数组 1234567891011121314151617181920212223public class Main&#123; public static void main(String[] args) &#123; double[] myList = &#123;1.9, 2.9, 3.5, 3.4&#125;; System.out.println("打印数组："); for (int i = 0; i &lt; myList.length; i++) &#123; System.out.print(myList[i] + " "); &#125; System.out.println(); System.out.println("计算所有元素的和"); double sum = 0; for (int i = 0; i &lt; myList.length; i++) &#123; sum += myList[i]; &#125; System.out.println("数组myList元素的和为：" + sum); double max = myList[0]; for (int i = 0; i &lt; myList.length; i++) &#123; if (max&lt;myList[i])&#123; max = myList[i]; &#125; &#125; System.out.println("数组myList中的最大值为：" + max); &#125;&#125; 运行结果 打印数组：1.9 2.9 3.5 3.4计算所有元素的和数组myList元素的和为：11.700000000000001数组myList中的最大值为：3.5 foreach循环foreach 循环可以在不适用下标的情况下遍历数组 12345678910public class Main&#123; public static void main(String[] args) &#123; double[] myList = &#123;1.9, 2.9, 3.5, 3.4&#125;; System.out.println("打印数组："); for (double i : myList) &#123; System.out.print(i + " "); &#125; &#125;&#125; 运行结果 打印数组：1.9 2.9 3.5 3.4 数组作为函数的参数1234567891011121314public class Main&#123; public static void main(String[] args) &#123; double[] myList = &#123;1.9, 2.9, 3.5, 3.4&#125;; System.out.println("打印数组:"); printArray(myList); &#125; public static void printArray(double[] arr)&#123; for (double i : arr) &#123; System.out.print(i + " "); &#125; &#125;&#125; 运行结果 打印数组:1.9 2.9 3.5 3.4 数组作为函数的返回值1234567891011121314151617181920public class Main&#123; public static void main(String[] args) &#123; double[] myList = &#123;1.9, 2.9, 3.5, 3.4&#125;; System.out.println("打印数组:"); double[] result = reverse(myList); for (double i : result) &#123; System.out.print(i + " "); &#125; &#125; public static double[] reverse(double[] list) &#123; double[] result = new double[list.length]; for (int i = 0, j = result.length - 1; i &lt; list.length; i++, j--) &#123; result[j] = list[i]; &#125; return result; &#125;&#125; 运行结果 打印数组:3.4 3.5 2.9 1.9 数组内容的比较数组内容的比较可以通过 equals() 吗？我们先来看个例子 1234567public class Main&#123; public static void main(String[] args) &#123; int[] a = &#123;1,2,3&#125;; int[] b = &#123;1,2,3&#125;; System.out.println(a.equals(b)); &#125;&#125; 运行结果 false 所以，不能直接用 equals() 比较数组内容。那么该怎么比较呢？ 有两种方法：一种是自己实现，另一种是利用 Arrays。 Arrays 中的方法全是static的。其中包括了 equals() 方法的各种重载版本。 12345678910111213141516171819202122232425import java.util.Arrays;public class Main&#123; public static boolean isEquals(int[] a, int[] b)&#123; if (a==null || b==null)&#123; return false; &#125; if (a.length!=b.length)&#123; return false; &#125; for (int i = 0; i &lt; a.length; i++) &#123; if (a[i]!=b[i])&#123; return false; &#125; &#125; return true; &#125; public static void main(String[] args) &#123; int[] a = &#123;1,2,3&#125;; int[] b = &#123;1,2,3&#125;; System.out.println(isEquals(a,b)); System.out.println(Arrays.equals(a,b)); &#125;&#125; 运行结果 truetrue Arrays类的使用Arrays 能方便的操作数组，他提供的方法都是静态的。 具有以下功能 对数组赋值：通过 fill 方法 对数组排序：用过 sort 方法，按升序。 比较数组：通过 equals 方法，比较数组中的元素是否相等 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找。 ……. 多维数组多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。 其实 Java 只有一维数组，但是由于数组可以存放任意类型的数据，当然也就可以存放数组了，这个时候，就可以模拟多维数组了。 基本的定义方法同样有两种 type[][] i = new type[2][3];//（推荐） type i[][] = new type[2][3];//（推荐） 变长的二维数组二维数组的每个元素是一个一维数组，这些数组不一定都是等长的。 声明二维数组的时候可以只指定第一维的大小，空缺处第二维的大小，之后在指定不同长度的数组。但是注意，第一维大小不能空缺（可以指定行数不指定列数，不能只指定列数不指定行数）。 12345678public class Main&#123; public static void main(String[] args) &#123; int[][] arr = new int[3][]; arr[0] = new int[3]; arr[1] = new int[1]; arr[2] = new int[4]; &#125;&#125; 二维数组也可以在定义的时候初始化，使用花括号的嵌套完成，这时候不指定两个维数的大小，并且根据初始化值的个数不同，可以生成不同长度的数组元素。 1int[][] arr = &#123;&#123;1,3,9&#125;,&#123;7,&#125;,&#123;4,6,8,2&#125;&#125;; 可变参数有时候，你需要一个方法，但是你调用它之前不知道要传递几个参数给它，这个时候你就需要可变参数了 12345678910111213public class Main&#123; public static void main(String[] args) &#123; System.out.println(add(2,3)); System.out.println(add(3,4,5)); &#125; public static int add(int ...args)&#123; int sum = 0; for (int i = 0; i &lt; args.length; i++) &#123; sum = sum + args[i]; &#125; return sum; &#125;&#125; 那个奇怪的int ...args就是可变参数，这样你就可以传递任意个你想传递的数据了。 java把可变参数当做数组处理。 注意：可变参数必须位于最后一项。当可变参数个数多余一个时，必将有一个不是最后一项，所以只支持有一个可变参数。因为参数个数不定，所以当其后边还有相同类型参数时，java无法区分传入的参数属于前一个可变参数还是后边的参数，所以只能让可变参数位于最后一项。 面试中关于数组的常见问题寻找数组中第二小的元素1.做容易想到的方法，先排序，然后找到第二个数组。 12345678910111213import java.util.Arrays;public class Main&#123; public static void main(String[] args) &#123; int [] array=&#123;1,8,3,6,9,3,5,7,2,6,18,19,20,20,31,27,27&#125;; System.out.println("第二大的是:" + FindSecMax(array)); &#125; public static int FindSecMax(int[] arr)&#123; Arrays.sort(arr); int sec_max = arr[arr.length-2]; return sec_max; &#125;&#125; 运行结果 第二大的是:27 不过这个方法的时间复杂度和空间复杂度都比较大。 2.先定义两个变量：一个变量用来存储数组的最大数，初始值为数组首元素，另一个变量用来存储第二大的数，初始值为最小负整数，然后遍历数组元素，如果数组元素的值比最大数变量还大，更新最大数；若数组元素的值比最大值还小，则与第二大的数比较，若该数比第二大数大，则更新第二大的数； 123456789101112131415161718192021public class Main&#123; public static void main(String[] args) &#123; int [] array=&#123;1,8,3,6,9,3,5,7,2,6,18,19,20,20,31,27,27&#125;; System.out.println("第二大的是:" + FindSecMax(array)); &#125; public static int FindSecMax(int[] arr)&#123; int max=arr[0]; int sec_max=Integer.MIN_VALUE; for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i]&gt;max)&#123; sec_max = max; max = arr[i]; &#125;else &#123; if (arr[i]&gt;sec_max)&#123; sec_max = arr[i]; &#125; &#125; &#125; return sec_max; &#125;&#125; 运行结果 第二大的是:27 合并两个数组不管数组有没有顺序，都有一个统一的思路：定义一个新数组，长度为两个数组长度之和，然后对新数组排序 如果数组是有序的 定义一个新数组，长度为两个数组长度之和 分别定义 i：a数组下标, j：b数组下标, k：新数组下标 按位循环比较两个数组，较小元素的放入新数组，下标加一（较大元素对应的下标不加一），直到某个小标等于数组长度时退出循环 再写两个 while 循环来保证两个数组作比较完后剩下的数组还能顺利传入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.Arrays;import java.util.HashMap;import java.util.Map;public class Main&#123; public static void main(String[] args) &#123;// int[] arrayA=&#123;1,8,3,6,9,3,5,7,2,6,18,19,20,20,31,27,27&#125;;// int[] arrayB = &#123;37,3,8,85,87,44,22,39,40,80,58,10,69,75,90&#125;; int[] arrayA = &#123;1,8,3,6,9,3&#125;; int[] arrayB = &#123;37,3,8,85,87&#125;; Arrays.sort(arrayA); Arrays.sort(arrayB); System.out.print("arrayA："); for (int i : arrayA) &#123; System.out.print(i+" "); &#125; System.out.println(); System.out.print("arrayB："); for (int i : arrayB) &#123; System.out.print(i+" "); &#125; //合并两个有序数组 int[] arrayC = combineSortedArray(arrayA,arrayB); System.out.println(); System.out.print("arrayC："); for (int i : arrayC) &#123; System.out.print(i+" "); &#125; &#125; public static int[] combineSortedArray(int[] arrA, int[] arrB)&#123; if (arrA == null)&#123; return arrB; &#125; if (arrB == null)&#123; return arrA; &#125; int[] arrayC = new int[arrA.length+arrB.length]; System.out.println(arrayC.length); int i=0,j=0,k=0; while (i &lt; arrA.length &amp;&amp; j &lt; arrB.length)&#123; if (arrA[i] &lt;= arrB[j])&#123; arrayC[k++] = arrA[i++]; &#125;else &#123; arrayC[k++] = arrB[j++]; &#125; &#125; while (i&lt; arrA.length)&#123; arrayC[k++] = arrA[i++]; &#125; while (j&lt; arrB.length)&#123; arrayC[k++] = arrB[j++]; &#125; return arrayC; &#125;&#125; 如果数组是无序的 将两个数组分别排序，然后按照上面的思路 重新排列数组中的正值和负值给定一个包含正数和负数的整数数组，重新排列它，使得所有的负数排在前面，所有的正数排在后面。正数间和负数间的相对顺序保持不变。 eg： 给定 [-1,2,-2,3,5,-4], 重新排列后变成 [-1,-2,-4,2,3,5] 思路一：先遍历第一遍，将负数挑出来放在一个新的数组中，再遍历一遍，将正数放进去 123456789101112131415161718192021222324252627import java.util.Arrays;public class Main&#123; public static void main(String[] args) &#123; int[] arrayA = &#123;1,7,-5,-12,-13,99,-6,31,15&#125;; int[] arrayB = positiveAndMinus(arrayA); System.out.println(Arrays.toString(arrayB)); &#125; public static int[] positiveAndMinus(int[] arr)&#123; int[] result = new int[arr.length]; int j = 0; for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; 0)&#123; result[j] = arr[i]; j++; &#125; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i]&gt;=0)&#123; result[j] = arr[i]; j++; &#125; &#125; return result; &#125;&#125; 思路二：冒泡排序的一种改进，将负数逐个“冒”出来。 1234567891011121314151617181920212223242526import java.util.Arrays;public class Main&#123; public static void main(String args[]) &#123; int[]x=&#123;1,7,-5,-12,-13,99,-6,31,15&#125;; int p=0; for(int i=x.length-1;i&gt;p;) &#123; if(x[i]&lt;0) &#123; int j=i; while(j!=0) &#123; int t=x[j]; x[j]=x[j-1]; x[j-1]=t;//交换 j--; &#125; p++; &#125; else i--; &#125; System.out.println(Arrays.toString(x)); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础七--内部类]]></title>
    <url>%2F2018%2F10%2F22%2FJava%E5%9F%BA%E7%A1%80%E4%B8%83-%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。 与之对应，包含内部类的类被称为外部类。 一般来说，内部类有四种： 成员内部类 局部内部类 匿名内部类 静态内部类 为什么要使用内部类在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。 内部类的优势 内部类提供了更好的封装，可以把内部类隐藏在外部类之中，不允许同一个包中的其他类访问该类，更好的实现了信息隐藏。 也是最吸引人的原因，每个内部类都能独立地继承一个接口，而无论外部类是否已经继承了某个接口。因此，内部类使多重继承的解决方案变得更加完整。在项目中，需要多重继承，如果是两个接口，那么好办，接口支持多重继承。如果是两个类呢？这时只有使用内部类了。 成员内部类成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式： 12345678910111213public class Circle &#123; //外部类 double r = 0; public Circle(double r) &#123; this.r = r; &#125; class Draw&#123; //内部类 public void drawSahpe()&#123; System.out.println("Draw Sahpe."); &#125; &#125;&#125; 这样看起来，Draw 类像是 Circle 类的一个成员，Circle 称为外部类，Draw 类称为 Circle 类的成员内部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括 private 成员和静态成员）。 12345678910111213141516public class Circle &#123; private double r = 0; public static int count = 1; public Circle(double r) &#123; this.r = r; &#125; class Draw&#123; public void drawSahpe()&#123; System.out.println(r); //外部类的private成员 System.out.println(count); //外部类的静态成员 System.out.println("Draw Sahpe."); &#125; &#125;&#125; 虽然成员内部类可以无条件的访问外部类的成员，但是外部类想访问成员内部类的成员缺不是那么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问。 12345678910111213141516171819public class Circle &#123; private double r = 0; public Circle(double r) &#123; this.r = r; getDrawInstance().drawSahpe(); //必须先创建成员内部类的对象，再进行访问 &#125; private Draw getDrawInstance()&#123; return new Draw(); &#125; class Draw&#123; //内部类 public void drawSahpe()&#123; System.out.println(r);//外部类的private成员 System.out.println("Draw Sahpe."); &#125; &#125;&#125; 成员内部类是依附于外部类而成在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下： 1234567891011121314151617181920public class Outter &#123; private Inner inner = null; public Outter()&#123; &#125; public Inner getInnerInstance()&#123; if (inner == null)&#123; inner = new Inner(); &#125; return inner; &#125; class Inner&#123; public Inner()&#123; &#125; &#125;&#125; 1234567891011public class Main &#123; public static void main(String[] args) &#123; //第一种方法：外部类对象.new 内部类 Outter outter = new Outter(); Outter.Inner inner = outter.new Inner(); //第二种方法：外部类对象.获取方法 Outter.Inner inner1 = outter.getInnerInstance(); //第三种方法：new 外部类.new 内部类 Outter.Inner inner2 = new Outter().new Inner(); &#125;&#125; 内部类可以拥有 private 访问权限、protected 访问权限、public 访问权限及包访问权限。比如上面的例子，如果成员内部类 Inner 用 private 修饰，则只能在外部类的内部访问，如果用 public 修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被 public 和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。 小结 内部类在外部使用时，无法直接实例化，需要借由外部类信息才能完成实例化 成员内部类中不能存在任何static的变量和方法 内部类的访问修饰符，可以任意，但是访问范围会受到影响 内部类可以直接访问外部类的成员；如果出现同名属性，有限访问内部类中定义的 可以使用外部类.this.成员的方法，访问外部类中同名的信息 外部类访问内部类信息，需要通过内部类实例，无法直接访问 内部类编译后.class文件命名:外部类$内部类.class 内部类中可以包含与外部类相同方法签名的方法，内部类对象在调用的时候调用的是内部类中的方法 局部内部类有这样一种内部类，它是嵌套在方法和作用域内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。 12345678910class Outter &#123; public void function()&#123; //局部内部类 Inner class Inner&#123; public void print()&#123; System.out.println("局部内部类..."); &#125; &#125; &#125;&#125; 小结 局部内部类类似方法的局部变量，所以在类外或者类的其他方法中不能访问这个内部类，但这并不代表局部内部类的实例和定义了它的方法中的局部变量具有相同的生命周期。 我们可以看到，这里的局部内部类 Inner 定义在了一个 if 条件作用域中，因此，在 if 之外的部分，尽管没有离开 function() 方法，就会编译报错，无法访问到 Inner 这个内部类。因此，还要广义的理解局部内部类的含义和访问条件，不可以片面的理解为仅仅是方法中定义的内部类。 只能在方法内部，局部内部类定义之后使用，不存在外部可见性问题，因此没有访问修饰符，即 class 前面不可以添加public、private、protected、static 不能再局部内部类中使用可变的局部变量 类中不能包含静态成员 类中可以包含final、abstract修饰的成员 综上，就是局部内部类的知识，其实局部内部类的名气远没有匿名内部类的名气大，但是作为一个匿名内部类的父概念，其定义了匿名内部类和普通的局部内部类的概念和特性，因此可以作为匿名内部类的知识补充。 匿名内部类匿名内部类也就是没有名字的内部类。 正因为没有名字，所以匿名内部类只能用一次，它通常是用来简化代码编写 但使用匿名内部类还有一个前提条件:必须继承一个父类或实现一个接口 这应该是我最经常用的内部类了，写 Android 的时候，使用点击事件就会用到它，来举个例子吧 12345678910111213141516@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); bt = findViewById(R.id.bt1); //1.匿名内部类 bt.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub Log.i("匿名内部类", "点击事件"); &#125; &#125;);&#125; 这就是匿名内部类的使用。代码中需要给 Button 设置一个监听器对象，使用匿名内部类能够在实现父类或者接口的方法的情况下同时产生一个相应的对象，但是前提是父类或者这个接口的方法是存在的。当然，也可以按照下面这么写。 1234private void setListener()&#123; bt.setOnClickListener(new Listener1());&#125; 1234567class Listener1 implements View.OnClickListener&#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub Log.i("匿名内部类", "点击事件"); &#125;&#125; 这样的写法虽然能达到同样的效果，但是及冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也不能有访问修饰符和 static 修饰符的。 匿名内部类初始化我们一般用构造器来完成某个实例的初始化工作，但是匿名内部类是没有构造器的，那怎么来初始化匿名内部类呢？答案是使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。 实例匿名内部类有不能的表现形式，下面为大家展示一下： 继承式的匿名内部类123abstract class Car &#123; public abstract void drive();&#125; 1234567891011public class Main &#123; public static void main(String[] args) &#123; Car car = new Car() &#123; @Override public void drive() &#123; System.out.println("Driving another car"); &#125; &#125;; car.drive(); &#125;&#125; 运行结果 Driving another car 引用变量不是引用 Car 对象，而是 Car 匿名子类的对象 建立匿名内部类的关键是重写父类的一个或者多个方法，这里再强调一下，是重写父类的方法，而不是建立新的方法。因为父类的引用不可能调用父类本身没有的方法，所以建立新的方法是多余的。 接口式的匿名内部类123public interface Vehicle &#123; public void drive();&#125; 12345678910public class Main &#123; public static void main(String[] args) &#123; Vehicle v = new Vehicle() &#123; @Override public void drive() &#123; System.out.println("Driving a car"); &#125; &#125;; &#125;&#125; 运行结果 Driving a car 这段代码很奇怪，乍一看以为实例化了个接口。事实并非如此，接口式的匿名内部类是实现了一个接口的匿名类。而且只能实现一个借口。 参数式的匿名内部类12public interface Foo &#123;&#125; 123abstract class Bar &#123; void doStuff(Foo f)&#123;&#125;&#125; 123public class BarOne extends Bar &#123; void doStuff(Foo f)&#123;&#125;&#125; 12345678910public class Main &#123; static void go()&#123; Bar b = new BarOne(); b.doStuff(new Foo() &#123; public void foo()&#123; System.out.println("foofy"); &#125; &#125;); &#125;&#125; 由上面3个例子可以看出，只要一个类是抽象的或者是一个接口，那么其子类中的方法都可以使用匿名内部类来实现。最常用的情况就是在多线程的实现上，因为要实现多线程必须继承 Thread 类或是实现 Runable 接口 Thread 类的匿名内部类实现12345678910111213public class Main &#123; public static void main(String[] args) &#123; Thread t = new Thread()&#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.print(i + " "); &#125; &#125; &#125;; t.start(); &#125;&#125; Runnable 接口的匿名内部类实现1234567891011121314public class Main&#123; public static void main(String[] args) &#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.print(i + " "); &#125; &#125; &#125;; Thread t = new Thread(r); t.start(); &#125;&#125; 小结 匿名内部类没有类型名称、实例对象名称 编译后的文件命名：外部类$数字.class 无法使用private、public、protected、abstract、static修饰，匿名内部类不能出现抽象方法 无法编写构造方法，可以添加构造代码块 不能出现静态成员 匿名内部类可以实现接口也可以继承父类，但不可以兼得 匿名内部类不能是抽象的，它必须要实现继承的类或者实现接口的所有抽象方法 静态内部类静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字 static 。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非 static 成员变量或方法。这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非 static 成员就会产生矛盾，因为外部类的非 static 必须依附于具体的对象。 12345678910111213141516171819public class Outter &#123; private static int age = 12; private String name = "外部类"; public void say()&#123; System.out.println("这是外部类的静态方法"); &#125; static class Inner&#123; public static void say()&#123; System.out.println("这是内部类的静态方法"); &#125; public String print()&#123; new Outter().say(); return new Outter().name + "到此一游"; &#125; &#125;&#125; 123456public class Main&#123; public static void main(String[] args) &#123; Outter.Inner in = new Outter.Inner(); System.out.println(in.print()); &#125;&#125; 运行结果 这是外部类的静态方法外部类到此一游 可以看到，如果用 static 将内部类静态化，那么内部类就只能访问外部类的静态成员变量，具有局限性。 其次，因为内部类被静态化，因此 Outter.Inner 可以当做一个整体看，可以直接 new 出内部类的对象。(因为类名访问 static ，生不成外部类对象都没关系) 小结 静态内部类中，只能直接访问外部类的静态成员，如果需要调用非静态成员，可以通过对象实例 new Outter().say(); 这样调用 静态内部类对象实例时，可以不依赖于外部类对象 可以通过外部类.内部类.静态成员的方式，访问内部类中的静态成员 当内部类属性与外部类属性同名时，默认直接调用内部类中的成员 如果需要访问外部类中的静态属性，则可以通过外部类.属性的方式 如果需要访问外部类中的非静态属性，则可以通过new 外部类().属性的方式 接口中的内部类我们在实际开发中，如果想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么接口内部的嵌套类会显得很方便。也就是说，在接口中可以含有内部类。 首先创建接口，接口中定义了普通内部类 InnerClass 和抽象内部类 AbInnerClass 1234567891011121314151617181920212223242526public interface IOuterInterface &#123; int TEMP = 100;//常亮 void abMethod();//抽象方法 public default void deMethod()&#123;//jdk1.8后可添加 System.out.println("接口中的静态方法"); &#125; public static void stMethod()&#123;//jdk1.8后可添加 System.out.println("接口中的静态方法"); &#125; //普通内部类 public class InnerClass&#123; public void show()&#123; System.out.println("接口中可定义普通成员内部类"); &#125; &#125; //抽象内部类 public abstract class AbInnerClass&#123; public abstract void abInfo(); public void info()&#123; System.out.println("接口中可以定义抽象成员内部类"); &#125; &#125;&#125; 普通成员内部类的实例化 123456789101112public class ClassDemo implements IOuterInterface&#123; @Override public void abMethod() &#123; System.out.println("实现类"); &#125; //获取接口中内部类方法 public InnerClass getInner()&#123; return new InnerClass(); &#125;&#125; 123456789101112131415public class Main&#123; public static void main(String[] args) &#123; //第一种实例化对象方式 //通过 接口名.类名 进行实例化 IOuterInterface.InnerClass innerClass = new IOuterInterface.InnerClass(); innerClass.show(); //第二种实例化对象方式 //通过在实现类中创建接口中内部类获取方法 //用实现类对象调用获取方法 ClassDemo demo = new ClassDemo(); demo.getInner().show(); &#125;&#125; 运行结果 接口中可定义普通成员内部类接口中可定义普通成员内部类 抽象成员内部类的实例化 1234567891011121314public class AbClassDemo implements IOuterInterface &#123; @Override public void abMethod() &#123; &#125; //继承抽象类AbInnerClass public class AbDemo extends AbInnerClass&#123; @Override public void abInfo() &#123; System.out.println("重写了接口中国抽象类中的抽象方法"); &#125; &#125;&#125; 12345678910111213141516171819202122public class Main&#123; public static void main(String[] args) &#123; //第一种实例化对象方式 //通过 接口名.类名 进行实例化 //但是对于抽象类而言，不能直接实例化，所以这里可以使用匿名内部类的方式 IOuterInterface.AbInnerClass abInner = new IOuterInterface.AbInnerClass() &#123; @Override public void abInfo() &#123; System.out.println("重写抽象类中的抽象方法"); &#125; &#125;; abInner.abInfo(); abInner.info(); System.out.println(); //第二种实例化对象方式 //在实现类中定义内部类继承接口中的抽象内部类 IOuterInterface.AbInnerClass abInnerOne = new AbClassDemo().new AbDemo(); abInnerOne.abInfo(); abInnerOne.info(); &#125;&#125; 运行结果 重写抽象类中的抽象方法接口中可以定义抽象成员内部类 重写了接口中国抽象类中的抽象方法接口中可以定义抽象成员内部类 小结这里只是提供给大家几种实例化接口中内部类的思路和方式，大家也可以用其他方式去进行对象实例化，当然前提是要满足代码规则。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>多态</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础七--接口]]></title>
    <url>%2F2018%2F10%2F18%2FJava%E5%9F%BA%E7%A1%80%E4%B8%83-%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。 接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。 接口与类相似点 一个接口可以有多个方法 接口文件保存在 .java 结尾的文件中，文件名使用接口名 接口的字节码文件保存在 .class 结尾的文件中 接口相应的字节码文件必须在与包名称相匹配的目录结构中 接口与类的区别 接口不能用于实例化对象 接口没有构造方法 接口中所有的方法必须是抽象方法 接口不能包含成员变量，除了 static 和 final 变量 接口不是被类继承了，而是被类实现了 接口支持多继承 接口特性 接口中每个方法也是隐式抽象的，接口中的方法会被隐式的指定为 public abstract （只能是 public abstract，其他修饰符都会报错） 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误） 接口中的方法不能再接口中实现，只能由实现了接口的类来实现接口中的方法 抽象类和接口的区别 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的 接口中不能含有静态代码块以及静态方法（用 static 修饰的方法），而抽象类是可以有静态代码块和静态方法 一个类只能继承一个抽象类，而一个类却可以实现多个接口 接口的声明123456[修饰符] interface 接口名[extends 父接口1，父接口2..]&#123; 零到多个常量定义... 零到多个抽象方法的定义... 零到多个默认方法的定义...（jdk1.8 新增） 零到多个静态方法的定义...（jdk1.8 新增）&#125; interface 关键字用来声明一个接口。下面是接口声明的一个简单例子。 12345public interface Animal &#123; static int age = 6; final String name = &quot;名字&quot;; public void sleep();&#125; 接口的特性 接口是隐式抽象的，当声明一个接口的时候，不必使用 abstract 关键字 接口中每一个方法也是隐式抽象的，声明时同样不需要 abstract 关键字 接口中的方法都是共有的 接口的实现当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象类 类使用 implements 关键字实现接口。在类声明中，implements 关键字放在 class 声明后面 实现一个接口的语法 1...implements 接口名[,其他接口名称,其他接口名称..,...] 12345public interface Animal &#123; static int age = 6; final String name = "名字"; public void sleep();&#125; 1234567891011public class Cat implements Animal&#123; public void run()&#123; System.out.println("我不想跑"); &#125; @Override public void sleep() &#123; System.out.println("猫爱睡觉"); &#125;&#125; 1234567public class Main &#123; public static void main(String[] args) &#123; Cat c = new Cat(); c.run(); c.sleep(); &#125;&#125; 运行结果 我不想跑猫爱睡觉 重写接口中声明的方法时，需要注意以下规则： 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型 如果实现接口的类是抽象类，那么就没有必要实现该接口的方法 在实现接口的时候，也要注意一些规则： 一个类可以同时实现多个接口 一个类只能继承一个类，但是能实现多个接口 一个接口可以继承另一个接口，这和类之间的继承比较相似 接口的继承上面说到，一个接口可以继承另一个接口，这和类之间的继承比较相似。接口之间的继承也是使用的 extedns 关键字，子接口继承父接口的方法。 12345//父接口public interface Animal &#123; public void eat(); public void sleep();&#125; 1234//猫科动物接口public interface Cat extends Animal&#123; public void ClimbTree();&#125; 1234//虎类接口public interface Tiger extends Cat&#123; public void shape();&#125; 1234567891011121314151617181920212223//东北虎类实现虎类这个接口public class ManchuriaTiger implements Tiger&#123; @Override public void shape() &#123; &#125; @Override public void ClimbTree() &#123; &#125; @Override public void eat() &#123; &#125; @Override public void sleep() &#123; &#125;&#125; 现在有一个父接口 Animal ，猫科动物接口 Cat 继承 Animal，而 Tiger 接口又继承 Cat 接口，最后ManchuriaTiger实现了 Tiger 接口。这时编译器提示需要实现接口中的方法。 Tiger 接口自己声明了一个方法，从 Cat 接口继承了一个方法，Cat 接口自己声明了一个方法，又从 Animal 接口继承了两个方法。这样，实现 Tiger 接口的 ManchuriaTiger 类需要实现四个方法。 接口的多继承在 Java 中，类的多继承是不合法的，但是接口允许多继承 在接口的多继承中 extends 关键字只需要使用一次，在其后跟着继承接口。 1public interface Tiger extends Cat,Animal 以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Cat 及 Animal 可能定义或者是继承相同的方法。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>多态</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础七--抽象类]]></title>
    <url>%2F2018%2F10%2F18%2FJava%E5%9F%BA%E7%A1%80%E4%B8%83-%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。 在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 抽象类和抽象方法的声明格式1234567abstract class &lt;类名&gt; &#123; 成员变量; 方法()&#123; 方法体 &#125;//一般方法 abstract 方法（）&#123;&#125;//抽象方法&#125; 例如： 123456789abstract public class Animal &#123; public String name; public void eat()&#123; System.out.println("animal eating..."); &#125; abstract public void sleep();&#125; 从例子中可以看出，抽象类是用关键字 abstract 修饰的。抽象类中有一种特殊方法，即用 abstract 关键字来修饰的方法，称为”抽象方法“。 抽象类和抽象方法的特点 抽象方法不允许直接实例化，换句话说抽象类不能创建对象，他只能作为其他类的父类。但可以通过向上转型，指向实例化。 抽象方法只有声明，不能实现，也就是说仅有方法头，而没有方法体和操作实现。 如：abstract void sleep()； 抽象类的意义 为其子类提供一个公共的类型（父类引用指向子类） 1Animal a = new Cat(); 封装子类中重复内容（成员变量和方法） 将父类设计成抽象类后，既可借由父子继承关系限制子类的设计随意性，在一定程度上避免了无意义父类的实例化 重点注意 含有抽象方法的类，只能被定义成抽象类 123456789public class Animal &#123;//这里报错了 public String name; public void eat()&#123; System.out.println("animal eating..."); &#125; abstract public void sleep();&#125; 抽象类不一定包含抽象方法 12345public class Animal &#123; public void eat()&#123; System.out.println("animal eating...");//一般方法 &#125;&#125; 在抽象类中的成员方法可以包括一般方法和抽象方法 12345678abstract public class Animal &#123; public String name; public void eat()&#123; System.out.println("animal eating..."); &#125; abstract public void sleep();&#125; 抽象类不能实例化，及时抽象类里不包含抽象方法 ，这个抽象类 也不能创建实例，抽象类的构造方法主要是用于被其子类调用 例子： Animal 抽象类中不包含抽象方法 1234567abstract public class Animal &#123; public String name; public void eat()&#123; System.out.println("animal eating..."); &#125;&#125; 测试类中实例化 Animal ，编译器会报错 12345public class Main &#123; public static void main(String[] args) &#123; Animal a = new Animal();//这里报错了 &#125;&#125; 一个类继承抽象类后，必须实现其所有抽象方法，否则也是抽象类，不同的子类对父类的抽象方法可以有不同的实现 如父类： 123456789abstract public class Animal &#123; public String name; public void eat()&#123; System.out.println("animal eating..."); &#125; abstract public void sleep();&#125; 则其子类 Cat 有两种做法 方案一：重写抽象方法 sleep()，使方法得以实现 123456789public class Cat extends Animal&#123; public void sleep()&#123; System.out.println("猫要睡大觉！"); &#125; public void run()&#123; System.out.println("我不想跑"); &#125;&#125; 方案二：子类 Cat 类也定义为抽象类 123456abstract public class Cat extends Animal&#123;//没有实现父类中的抽象方法，所以是抽象类 public void run()&#123; System.out.println("我不想跑"); &#125;&#125; 即使父类是具体的，但其子类也可以是抽象的，如 Object 是具体的，但可以创建抽象子类 abstract 方法不能用 static 和 private 修饰；对于类，不能同时用 final 和 abstract 修饰，因为 final 关键字使得类不可继承，而 abstract 修饰的类如果不可以继承将没有任何意义。两者放一起回起冲突 一个完整的抽象类的例子父类： 1234abstract public class Shape &#123; //抽象父类 Shape abstract double area();//抽象方法&#125; 子类: 1234567891011121314151617181920212223public class Circle extends Shape &#123; public double r; Circle()&#123; &#125; //创建带参构造函数 public Circle(double r)&#123; this.r = r; &#125; public double getR() &#123; return r; &#125; public void setR(double r) &#123; this.r = r; &#125; @Override double area() &#123; return (3.14*r*r); &#125;&#125; 测试类: 123456public class Main &#123; public static void main(String[] args) &#123; Circle c = new Circle(3.5); System.out.println("圆的面积为："+c.area()); &#125;&#125; 运行结果： 圆的面积为：38.465 小结 抽象类不能被实例化，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>多态</tag>
        <tag>抽象类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础七--多态]]></title>
    <url>%2F2018%2F10%2F18%2FJava%E5%9F%BA%E7%A1%80%E4%B8%83%2F</url>
    <content type="text"><![CDATA[多态是同一个行为具有多个不同表现形式或形态的能力。 多态的分类 编译时多态（设计时多态）：方法重载 运行时多态：Java 运行时系统根据调用该方法的实例的类型来决定选择调用哪个方法则被称为运行时多态 我们平时说的多态，多指运行时多态 多态的实现方法 重写 这个内容写过了，可以访问 Java基础六 中的重写 &amp; 重载。 接口 生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。 java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 Java基础七-接口 这一章节的内容 抽象类和抽象方法 详情请看Java基础七-抽象类 。 向上转型 &amp; 向下转型要转型，首先要有继承。 向上类型转换（Upcast）：将子类对象转换为父类，父类可以是接口 隐式/自动类型转换，是小类型到大类型的转换。 向下类型转换（Downcast）：将父类型转换为子类型 强制类型转换，是大类型到小类型。 通过 instanceof 运算符，来解决引用对象的类型，避免类型转换的安全性问题，提高代码的健壮性。 向上转型举一个大家都知道的例子： 12345public class Animal &#123; public void eat()&#123; System.out.println("animal eating..."); &#125;&#125; 12345public class Cat extends Animal&#123; public void eat()&#123; System.out.println("猫吃鱼"); &#125;&#125; 123456789public class Dog extends Animal &#123; public void eat()&#123; System.out.println("狗吃肉"); &#125; public void run()&#123; System.out.println("狗爱跑"); &#125;&#125; 12345678public class Main &#123; public static void main(String[] args) &#123; Animal animal = new Cat();//向上转型 animal.eat(); animal = new Dog(); animal.eat(); &#125;&#125; 执行结果： 猫吃鱼狗吃肉 这就是向上转型，向上转型是安全的，因为任何子类都继承并接受了父类的方法。从例子中也可以看出猫和狗都属于他们的父类——Animal，这是可行的。但是向下转型就不行，若所所有的动物都是猫或者都是狗就不成立的。（所以向下转型要通过强制类型转换） Animal animal = new Cat(); 将子类对象 Cat 转换为父类对象 Animal 。这个时候 animal 这个引用调用的方法是子类方法。 转型过程中需要注意的问题 向上转型时，子类单独定义的方法会丢失。比如上面 Dog 类中定义的 run 方法，当 animal 引用指向 Dog 类实例时是访问不到 run 方法的，animal.run()；会报错。 子类引用引用不能指向父类对象。Cat c = (Cat)new Animal()这样是不行的。 向上转型的应用 当一个子类对象向上转型父类类型后，就被当成了父类的对象，所能调用的方法会减少，只能调用子类重写了父类的方法以及父类派生的方法（如 set(),get()方法），而不能调用子类独有的方法。 继续用上面的例子： 12345678910public class Main &#123; public static void main(String[] args) &#123; Animal animal = new Cat();//向上转型 animal.eat(); animal = new Dog(); animal.eat(); //如果调用 Dog 类中的 run() 方法。 animal.run();//这个会报错，编译不通过 &#125;&#125; 可以调用子类重写父类的方法 eat()，但调用子类独有的方法 run() 时就是无效的 父类中的静态方法是不允许被子类重写的 如父类 Animal 中含有静态方法 sleep() 12345678public class Animal &#123; public void eat()&#123; System.out.println("animal eating..."); &#125; public static void sleep()&#123; System.out.println("animal sleep..."); &#125;&#125; 当子类 Cat 中也定义同名方法时，此时 sleep() 算 Cat 类自己独有的方法 12345678public class Cat extends Animal&#123; public void eat()&#123; System.out.println("猫吃鱼"); &#125; public static void sleep()&#123; System.out.println("猫要睡大觉！"); &#125;&#125; 1234567public class Main &#123; public static void main(String[] args) &#123; Animal animal = new Cat(); animal.eat(); animal.sleep(); &#125;&#125; 执行结果： 猫吃鱼animal sleep… 实际上调用的是父类的静态方法 sleep() 这是因为父类的静态方法可以被子类继承，但是不能重写。 向上转型的好处 减少重复代码，使代码变得简介 提高系统扩展性 举个例子：比如，我现在有很多种类的动物，要喂它们吃东西。如果不用向上转型，那我需要这样写： 1234567891011public void eat(Cat c)&#123; c.eat();&#125;public void eat(Dog d)&#123; d.eat();&#125;...eat(new Cat());eat(new Dog());... 一种动物写一个方法，如果我有一万种动物，我不得写一万个方法？假设你很厉害，耐着性子写完了，突然又来一个新的动物，你是不是又要单独为它写一个 eat() 方法？ 那如果我用向上转型呢？ 12345678public void eat(Animal a)&#123; a.eat();&#125;eat(new Cat());eat(new Cat());eat(new Dog());//..... 这样代码是不是简洁了许多？而且这个时候，如果我又有一种新的动物加进来，我只需要实现它自己的类，让他继承Animal就可以了，而不需要为它单独写一个eat方法。是不是提高了扩展性？ 扩展多态的实现可以通过向上转型和动态绑定机制来完成，向上转型实现了将子类对象向上转型为父类类型，而动态绑定机制能识别出对象转型前的类型，从而自动调用该类的方法，两者相辅相成。 绑定就是将一个方法调用同一个方法所在的类连接到一起就是绑定。绑定分为静态绑定和动态绑定两种。 静态绑定在程序运行之前进行绑定（由编译器和链接程序完成的），也叫作前期绑定。 动态绑定在程序运行期间由 JVM 根据对象的类型自动的判断应该调用那个方法，也叫做后期绑定。 静态绑定的例子如有一个父类 Human，它派生出来三个字类 Chinese 类、American 类、British类，三个子类中都重写了父类中的 speak() 方法，在测试类中用静态绑定的方式调用方法 speak()。 12345public class Human &#123; public void speak()&#123; System.out.println("Human speak..."); &#125;&#125; 12345public class Chinese extends Human&#123; public void speak() &#123; System.out.println("speak chinese."); &#125;&#125; 12345public class American extends Human&#123; public void speak() &#123; System.out.println("speak American English."); &#125;&#125; 12345public class British extends Human&#123; public void speak() &#123; System.out.println("speak English."); &#125;&#125; 12345678910public class Main &#123; public static void main(String[] args) &#123; Chinese c = new Chinese(); c.speak(); American a = new American(); a.speak(); British b = new British(); b.speak(); &#125;&#125; 这种调用方式是在代码里指定的，编译时编译器就知道 c 调动的是 Chinese 中的 speak() 方法，a 调用的是 American 的 speak() 方法。 动态绑定的例子如果我们在测试类中做如下改动 12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; //生成父类对象数组，数组长度为5。 Human[] humans = new Human[5]; int n; for (int i = 0; i &lt; humans.length; i++) &#123; n = (int) (Math.random()*3);//随机生成从0到2中的一个数 switch(n)&#123; case 0: humans[i] = new Chinese(); break; case 1: humans[i] = new American(); break; case 2: humans[i] = new British(); break; &#125; &#125; //循环输出，循环体中每个对象分别调用 speak() 方法 for (int i = 0; i &lt; humans.length; i++) &#123; humans[i].speak(); &#125; &#125;&#125; 运行结果： speak English.speak chinese.speak English.speak American English.speak English. 此时，Human 类中随机生成 Chinese 类、American 类和 British 类的对象，编译器不能根据代码直接确定调用那个类中的 speak() 方法，直到运行时才能根据产生的随机数 n 的值来确定 humans[i]到底代表哪一个子类的对象，这样才能最终确定调用的是哪个类中的 speak() 方法，这就是动态绑定。 向下转型与向上转型相对应的就是向下转型了。向下转型是把父类对象转为子类对象。(请注意！这里是有坑的。)它是用子类引用指向父类实例。 下图，在进行转换是会报错 12Animal a = new Cat();Cat c = a； 这就告诉我们向下转型不能自动转换，我们需要强转，所以乡下转型又叫做强制类型转换。 正确的语句是： 1234//还是上面的animal和cat dogAnimal a = new Cat();Cat c = (Cat) a;c.eat(); 输出结果： 猫吃鱼 12Dog d = (Dog) a;d.eat(); 报错：java.lang.ClassCastException: Cat cannot be cast to Dog 123Animal a1 = new Animal();Cat c1 = (Cat) a1;c1.eat(); 报错：java.lang.ClassCastException: Animal cannot be cast to Cat 为什么第一段代码不报错呢？相比你也知道了，因为a本身就是 Cat 对象，所以它理所当然的可以向下转型为Cat，也理所当然的不能转为 Dog，你见过一条狗突然就变成一只猫这种现象？ 而a1为 Animal 对象，它也不能被向下转型为任何子类对象。比如你去考古，发现了一个新生物，知道它是一种动物，但是你不能直接说，啊，它是猫，或者说它是狗。 向下转型注意事项 向下转型的前提是父类对象指向的是子类对象（也就是说，在向下转型之前，它得先向上转型） 向下转型只能转型为本类对象，兄弟类之间不能进行强制类型转换。（猫是不能变成狗的）。 大概你会说，我特么有病啊，我先向上转型再向下转型？？ 声明上转型对象是为了可以直接调用子类中重写的方法，但是不能调用子类新增的方法。而下转型对象可以调用子类新增的方法 我们回到上面的问题：喂动物吃饭，吃了饭做点什么呢？不同的动物肯定做不同的事，怎么做呢？ 12345678910111213141516171819public void eat(Animal a)&#123; if(a instanceof Dog)&#123; Dog d = (Dog)a; d.eat(); d.run();//狗有一个跑的方法 &#125; if(a instanceof Cat)&#123; Cat c = (Cat)a; c.eat(); System.out.println("我也想跑，但是不会"); //猫会抱怨 &#125; a.eat();//其他动物只会吃&#125;.....eat(new Cat());eat(new Cat());eat(new Dog());..... 现在，你懂了么？这就是向下转型的简单应用，可能举得例子不恰当，但是也可以说明一些问题。 敲黑板，划重点！看到那个 instanceof 了么？ instanceof 运算符instanceof 运算符用来判断对象是否可满足某个特定类型实例特征，简单的来说，就是判断其左边对象是否为其右边类的实例，返回boolean类型的数据。可以用来判断继承中的子类的实例是否为父类的实现。 1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; //对象实例化 Animal c = new Cat(); Animal d = new Dog(); //用 instanceof 运算符判断对象是否满足某个特定对象实例特征 System.out.println(c instanceof Animal); System.out.println(c instanceof Cat); System.out.println(c instanceof Dog); System.out.println(c instanceof Object); System.out.println(d instanceof Animal); System.out.println(d instanceof Cat); System.out.println(d instanceof Dog); System.out.println(d instanceof Object); &#125;&#125; 运行结果： truetruefalsetruetruefalsetruetrue 抽象类 &amp; 抽象方法应用场景某个父类只是限定其子类应该包括怎样的方法，但不需要准确知道这些子类如何实现这些方法。 抽象类 Java 中使用抽象类，限制实例化 123public abstract class Animal&#123; &#125; 抽象方法abstract 也可用于方法——抽象方法 1public abstract void eat(); 注意 抽象类不能直接实例化，必须借助子类完成相应的实例化操作 子类如果没有重写父类中所有的抽象方法，则也要定义为抽象类 抽象方法所在的类一定是抽象类 抽象类中可以没有抽象方法 接口 接口定义了某一批类所需要遵守的规范 接口不关心这些类的内部数据，也不关心这些类里方法的实现细节，它只规定这些类里必须提供某些方法 语法123456[修饰符] interface 接口[extends 父接口1，父接口2..]&#123; 零到多个常量定义... 零到多个抽象方法的定义... 零到多个默认方法的定义...（jdk1.8 新增） 零到多个静态方法的定义...（jdk1.8 新增）&#125; 注意 接口可以实现多继承，即一个子接口可以同时继承多个父接口 实现接口的类如果不能实现接口中所有待重写的方法，则必须设置为抽象类 一个类可以继承自一个父类，同时实现多个接口 内部类 在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类 与之对应，包含内部类的类被称为外部类]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>多态</tag>
        <tag>向上转型&amp;向下转型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础六--继承]]></title>
    <url>%2F2018%2F10%2F17%2FJava%E5%9F%BA%E7%A1%80%E5%85%AD%2F</url>
    <content type="text"><![CDATA[继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 继承的概念 继承是类与类之间的一种关系 使用已存在的类的定义作为基础建立新的类 新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。 当两个类之间满足 “A is a B” 的关系，我们就说它们满足继承关系 继承的特点 利于代码复用 缩短开发周期 语法 使用 extends 实现继承 Java 只支持单继承，一个类只能有一个父类（也称为超类、基类） 继承后的初始化顺序父类的静态成员 子类静态成员 父类对象构建【属性（赋值）、构造代码块、构造方法】 子类对象构建【属性（赋值）、构造代码块、构造方法】 Super关键字如何区分调用的是继承父类的方法还是子类自己重写的方法? 访问父类成员方法 1super.print(); 访问父类属性 1super.name; 子类对象实例化时，能否选择父类的构造形式（调用指定的构造方法）？ 访问父类构造方法 12super();//无参的构造方法super("name");//有参的构造方法 子类的构造过程中必须调用其父类的构造方法，默认调用无参的构造方法 如果子类构造方法中既没有显示标注，而父类有没有无参的构造方法，则编译出错 使用 super 调用父类指定构造方法，必须在子类的构造方法的第一行 this 关键字 &amp; super 关键字 this 关键字——当前类对象的引用 super 关键字——父类对象的引用 访问当前类的成员方法访问当前类的成员属性访问当前类的构造方法不能再静态方法中使用 访问父类的成员方法访问父类的成员属性访问父类的构造方法不能再静态方法中使用 构造方法调用时，super 和 this 不能同时出现 重写 &amp; 重载 方法重写 方法重载 在满足继承关系的子类中方法名、参数个数、顺序、返回值与父类相同返回值类型与父类的返回值类型向下兼容访问修饰符的限定范围大于等于父类方法 在同一个类中方法名相同参数个数、顺序、类型不同返回值类型、访问修饰符任意 方法重写存在，属性重写不存在 Object 类 Object 类是所有类的父类 一个类没有使用 extends 关键字明确标识继承关系，则默认继承 Object 类（包括数组） Java 中的每个类都可以使用 Object 中定义的方法 Object 类的常用方法 方法 说明 toString() 返回当前对象本身的有关信息，按字符串对象返回 equals() 比较两个对象是否是同一个对象，是则返回true hashCode() 返回该对象的哈希代码值 getClass() 获取当前对象所属的类信息，返回Class对象 final关键字final 表示“最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。 被 final 修饰的类表示不允许被继承 被 final 修饰的方法表示不允许被子类重写 final 修饰的方法可以被继承 不能修饰构造方法 被 final 修饰的变量表示不允许被修改 方法内部的局部变量 —&gt; 在使用之前被初始化赋值即可 类中的成员变量 —&gt; 只能在定义时或者构造代码块、构造方法中进行初始化设置 基本数据类型的变量 —&gt; 初始赋值之后不能更改 引用类型的变量—&gt;初始化之后不能再指向另一个对象，但指向的对象的内容时可变的 不能修饰构造方法 可配合 static 使用，表示静态的、不允许被修改的信息 使用 final 修饰可以提高性能，但会降低可扩展性 注解可以声明在包、类、属性、方法、局部变量、方法参数等的前面，用来对这些元素进行说明、注释 按照运行机制分 源码注解 编译时注解 运行时注解 按照来源分 来自 JDK 的注解 来自第三方的注解 自定义注解]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>继承</tag>
        <tag>super关键字</tag>
        <tag>this关键字</tag>
        <tag>final关键字</tag>
        <tag>重写&amp;重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构概述]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[算法 + 数据结构 = 编程 什么是数据结构？ 通俗的来说，数据结构是计算机存储、组织数据的方式。 常用的数据机构有： 数组 栈 队列 链表 树 图 字典树（这是一种高效的树形结构，但值得单独说明） 散列表（哈希表） 数组数组是最简单、也是使用最广泛的数据结构。栈、队列等其他数据结构均是由数组演变过来的。 下图是一个包含元素（1、2、3、4）的简单数组，数组长度为4。 每个数据元素都关联一个正数值，我们称之为索引，它表明数组中每个元素所在的位置。大部分语言将初始索引定义为零。 数组的两种类型： 一维数组 多维数组 数组的基本操作 Insert——在指定索引位置插入一个元素 Get——返回指定索引位置的元素 Delete——删除指定索引位置的元素 Size——得到数组所有元素的数量 面试中关于数组的常见问题 寻找数组中第二小的元素 找到数组中第一个不重复出现的整数 合并两个有序数组 重新排列数组中的正值和负值 栈著名的撤销操作几乎遍布任意一个应用。但是你有没有想过他是如何实现的？这个问题的解决思路是按照将最后的状态排列在前的顺序，在内存中存储历史工作状态。这没办法用数组实现，但是有了栈，这就变得很方便了。 可以把栈想象成一摞书，为了拿到中间的书，你需要移除放置在这上面的所有书。这就是LIFO（后进先出）的工作原理。 下图是包含三个数据元素（1、2、3）的栈，其中顶部的3将被最先移除： 栈的基本操作 Push——在顶部插入一个元素 Pop——返回并移除栈顶元素 isEmpty——如果栈为空，则返回true Top——返回顶部元素，但并不移除它 面试中关于栈的常见问题 使用栈计算后缀表达式 对栈的元素进行排序 判断表达式是否括号平衡 队列与栈类似，队列是另一种顺序存储元素的线性数据结构。栈与队列的最大差别在于栈是LIFO（后进先出），而队列是FIFO（先进先出） 常见的队列：排队上车，如果有新人加入，他需要到队尾排队，而非队首。排在前面的人会先上车，然后离开队伍。 下图是包含四个元素（1，2，3，4）的队列，其中在顶部的1将被最先移除： 移除先入队的元素、插入新元素 队列的基本操作 Enqueue() —— 在队列尾部插入元素 Dequeue() ——移除队列头部的元素 isEmpty()——如果队列为空，则返回true Top() ——返回队列的第一个元素 面试中关于队列的常见问题 使用队列表示栈 对队列的前k个元素倒序 使用队列生成从1到n的二进制数 链表链表是另一个重要的数据结构，乍一看可能有点像数组，但在内存分配，内部结构以及数据插入和删除的基本操作方面均有所不同。 链表就像一个节点链，其中每个节点包含着数据和指向后续节点的指针。链表还包含一个头指针，它指向链表的第一个元素，但当列表为空时，它指向null或无具体内容。 链表一般用于实现文件系统、哈希表和邻接表。 这是链表内部结构的展示： 链表包括以下类型： 单链表 双向链表 链表的基本操作： InsertAtEnd - 在链表的末尾插入指定元素 InsertAtHead - 在链接列表的开头/头部插入指定元素 Delete - 从链接列表中删除指定元素 DeleteAtHead - 删除链接列表的第一个元素 Search - 从链表中返回指定元素 isEmpty - 如果链表为空，则返回true 面试中关于链表的常见问题 反转链表 检测链表中的循环 返回链表倒数第N个节点 删除链表中的重复项 图图是一组以网络形式相互连接的节点，节点也称为顶点。一对节点（x，y）称为边（edge），表示顶点x连接到顶点y。边可以包含权重/成本，显示从顶点x到y所需的成本。 图的类型 无向图 有向图 在程序语言中，图可以用两种形式表示 邻接矩阵 邻接表 常见的图遍历算法 广度优先搜索 深度优先搜索 面试中关于图的常见问题 实现广度和深度优先搜索 检查图是否为树 计算图的边数 找到两个顶点之间的最短路径 树树形结构是一种层级式的数据结构，由顶点（节点）和连接他们的边组成。数类似于图，但区分树和图的重要特征是树种不存在环路。 这是一个简单树的示意图，以及树数据结构中使用的基本术语： Root - 根节点 Parent - 父节点 Child - 子节点 Leaf - 叶子节点 Sibling - 兄弟节点 树形结构的主要类型 N元树 平衡树 二叉树 二叉搜索树 AVL树 红黑树 2-3树 B 树 B+ 树 其中，二叉树和二叉搜索树是最常用的树。 面试中关于树结构的常见问题 求二叉树的高度 在二叉搜索树中查找第k个最大值 查找与根节点距离k的节点 在二叉树中查找给定节点的祖先节点 字典树字典树，也称为“前缀树”，是一种特殊的树形数据结构，对于解决字符串相关问题非常有效。他能够提供快速减速，主要用于搜索字典中的单词，在搜索引擎中自动提供建议，甚至被用于 IP 的路由。 以下是在字典树中存储三个单词“top”，“thus”和“their”的例子： 这些单词以顶部到底部的方式存储，其中绿色节点“p”，“s”和“r”分别表示“top”，“thus”和“their”的底部。 面试中关于字典树的常见问题 计算字典树中的总单词数 打印存储在字典树中的所有单词 使用字典树对数组的元素进行排序 使用字典树从字典中形成单词 构建T9字典（字典树+ DFS ） 哈希表哈希法（Hashing）是一个用于唯一标识对象并将每个对象存储在一些预先计算的唯一索引（称为“键key”）中的过程。因此，对象以键值对的形式存储，这些键值对集合被称为“字典”。可以使用键搜索每个对象。基于哈希法有很多不同的数据结构，但最常用的数据结构是哈希表。 哈希表通常用数组实现。 散列数据结构的性能取决于以下三个因素： 哈希函数 哈希表的大小 碰撞处理方法 下图为如何在数组中映射哈希键值对的说明。该数组的索引是通过哈希函数计算的。 面试中关于哈希结构的常见问题： 在数组中查找对称键值对 追踪遍历的完整路径 查找数组是否是另一个数组的子集 检查给定的数组是否不相交]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础五--封装]]></title>
    <url>%2F2018%2F10%2F14%2FJava%E5%9F%BA%E7%A1%80%E4%BA%94%2F</url>
    <content type="text"><![CDATA[什么是封装？ 通过该类提供的方法来实现对隐藏信息的操作和访问 隐藏对象的信息 留出访问的接口 封装的优点 良好的封装能减少耦合 类内部的结构可以自由修改 可以对成员变量进行更精确的控制 隐藏信息，实现细节 实现Java封装的步骤 隐藏对象 修改属性的可见性——设置为 private 1234public class Person&#123; private String name; private int age;&#125; 这段代码中，将 name 和 age 属性设置为私有的，只有本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。 留出接口 创建 getter / setter 方法——设置为 public 用于属性的读写 在 getter / setter 方法中加入属性控制语句——对属性值的合法性进行判断 1234567891011121314151617181920public class Person&#123; private String name; private int age; public int getAge()&#123; return age; &#125; public String getName()&#123; return name; &#125; public void setAge(int age)&#123; this.age = age; &#125; public void setName(String name)&#123; this.name = name; &#125;&#125; 采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name）之间发生的同名的冲突。 包作用 管理 Java 文件 解决同名文件冲突 定义包语法：package 包名; 注意： 1.必须放在 Java 源文件中的第一行 2.一个 Java 源文件中只能有一个 package 语句 3.包名全部英文小写 4.命名方式：域名倒序 + 模块 + 功能 eg：package com.nuc.zigbee; 导入包语法： import 包名.类名; eg: import com.nuc.*; import com.nuc.zigbee; 常用系统包java.lang 包含 Java 语言基础的类 java.util 包含 Java 语言中的各种工具类 java.io 包含输入、输出相关功能的类 static 关键字static 翻译为静态，从面向对象的角度讲，当一个类中的变量或方法用 static 修饰时，这些变量和方法就成了类本身的，他们和对象的关系并不大。但是从直观的角度讲，这些被修饰的量确实被该类所有对象所拥有，并且被这个类的所有对象所共享，求其是当使用该类对象进行引用他们时。其实当使用对象进行引用 static 修饰成员时，在底层代码的实现中，其实还是转换为类名进行引用，这表明这个成员属于类。 static + 属性——静态属性、类属性 static + 方法——静态方法、类方法 static + 类——不存在，不能加载类前 static + 方法内局部变量——不能加载局部变量前 static + 代码块——静态代码块 代码块 通过{}可以形成代码块 方法内的代码块称为：普通代码块 类内的代码块称为：构造代码块 构造代码块前 + static：静态代码块 注意 初学这个关键字时，书上有个重点，那就是一个类中， static 修饰的成员不能访问势力成员，只能访问静态成员。这个很好理解，static 修饰的成员叫做类成员，属于类本身的属性，随着类的编译进行初始化，而此时实例成员未必进行初始化，这就会带来很多错误，所以类成员访问实例成员是不能通过编译的。 静态方法中不可以定义 this，super 关键字，因为静态元素优先于对象存在。 静态成员的声明周期静态成员随着类的加载而产生，销毁时释放，生命周期伴随着类的整个的生命周期，生命周期长，这就意味着对内存资源的占用也会相对比较长。 静态方法中的成员调用 可以直接调用同类中的静态成员。 不可以直接调用同类中的非静态成员。 只能通过对象实例化后，对象.成员方法 的方式访问非静态成员。 各种代码块的执行顺序无论实例产生多少对象，静态代码块只执行一次。 构造代码块在每次对象构造的时候调用。 方法中的普通代码块则是在每次调用方法的时候顺序调用。 什么时候定义静态变量当对象中出现共享数据时，该数据被修饰成静态，对象中的特有数据，修饰为非静态，存在于堆内存中。 什么时候定义静态方法当功能内部没有访问到非静态数据（对象中特有的数据），该函数可以定义为静态的。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>封装</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础四--面向对象基础]]></title>
    <url>%2F2018%2F10%2F13%2FJava%E5%9F%BA%E7%A1%80%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[如果你现实中没有对象，至少你在java世界里会有茫茫多的对象，听起来是不是很激动呢？ 对象对象是类的一个实例，有状态和行为。 我们所在的世界，周围的一切事物都是对象，车、人、狗等等。这些对象都有自己的状态和行为。 我们用一只猫来举例，它的状态有：名字、品种、颜色，行为由：跑，叫，睡觉。 软件的对象也有状态和行为。软件对象的状态称为属性，行为通过方法体现。 那么什么是面向对象？关注现实存在的事物的各方面的信息，从对象的角度出发，根据事物的特征进行程序设计 类类是一个模子，确定对象将会拥有的特性（属性）和行为（方法） 类的特点： 类是对象的类型 具有相同属性和方法的一组对象的集合 对象是类的实例表现 属性对象具有的静态特征。对象“有什么”。 方法对象具有的各种动态行为。对象“能做什么”。 变量一个类中可以包含以下类型变量： 局部变量 在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都在方法中，方法结束后，变量就会自动销毁 成员变量 成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问 类变量 类变量也声明在类中，方法体之外，但必须声明为static类型 类和对象的关系类是抽象的概念，仅仅是模板 对象是一个你能看得见，摸得着的具体实体 类是对象的类型 对象是特定类型的数据 对象实例化实例化对象的过程可以分为两部分: - 声明对象 Cat one - 实例化对象 new Cat() - Cat one = new Cat();//类名 对象名 = new 构造方法(); 声明对象，就是在内存的栈区域开辟一块空间，此时这个空间里的值是空的 实例化对象，在内存的堆区域开辟一块空间，完成初始化操作 经过赋值操作，我们将堆空间中的地址，传递到了栈当中的内存空间里。此后，我们就可以通过对象名去调用对象的属性和方法了。 每次 new 对象就会产生新的实例化方法 - Cat one = new Cat(); - Cat two = new Cat(); 多个对象也可以指向同一块实例化空间 - Cat one = new Cat(); - Cat two = one; 对象实例化对象必须被实例化之后才能使用 对象间的引用传递，实际上传递的是堆内存空间的使用权 构造方法 构造方法与类同名且没有返回值 只能在对象实例化的时候调用 一个类可以有多个构造方法—构造方法重载 当没有指定构造方法时，系统会自动调用无参的构造方法 当有指定构造方法，无论是有参、无参的构造方法，都不会自动调用无参的构造方法。 构造方法不可被重写 this 关键字this: 当前对象的默认引用 this 的使用 - 调用成员属性，解决成员属性和局部变量同名冲突 123456String name;int age;public Cat(String name)&#123; this.name = name; System.out.println("我是单参构造");&#125; - 调用成员方法 1234567public void run()&#123; this.eat(); System.out.println("小猫快跑");&#125;public void eat()&#123; System.out.println("猫吃鱼");&#125; - 调用重载的构造方法 12345678public Cat()&#123; System.out.println("我是无参构造");&#125;public Cat(String name)&#123; this();//通过this()调用构造方法，必须放在方法体内的第一行。 this.name = name; System.out.println("我是单参构造");&#125; 源文件声明规则当在一个源文件中定义多个类，并且还有 import 语句和 package 语句时，要特别注意这些规则 一个源文件中只能有一个 public 类 一个源文件可以有多个非public类 源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为 Employee.java 如果一个类定义在某个包中，那么 package 语句应该在源文件的首行 如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么import 语句应该在源文件中最前面 import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础三--运算符]]></title>
    <url>%2F2018%2F10%2F13%2FJava%E5%9F%BA%E7%A1%80%E4%B8%89%2F</url>
    <content type="text"><![CDATA[在 Java 中运算符有一下几组 算数运算符 关系运算符 位运算符 逻辑运算符 赋值运算符 其他运算符 算数运算符算数运算符用在数学表达式中，作用和在数学中的作用一样。 在表格中 A = 10, B = 20 操作符 描述 例子 + 加法 A + B = 30 - 减法 A - B = -10 * 乘法 A * B = 200 / 除法 B / A = 2 % 取余 B % A = 0 ++ 自增 A++ 或 ++A 等于11 – 自减 B– 或者 –B 等于19 i++ 和 ++i 的区别 ++i 先进行自增操作，在进行表达式运算 i++ 先进行表达式运算，在进行自增操作 简单的来说，i++ 与 ++i 在单独使用的时候，都代表了 i = i + 1; 表达式 a = ++i; 等价于 i = i + 1;a = i; 表达式 a = i++; 等价于 a = i;i = i + 1; 关系运算符A = 10, B = 20 运算符 描述 例子 == 检查两个操作数的值是否相等，如果相等则返回true (A = B) false != 检查两个操作数的值是否相等，如果不相等则返回true (A != B) true &gt; 检查左操作数的值是否大于右操作数的值，如果是，返回true (A &gt; B) false &lt; 检查左操作数的值是否小于右操作数的值，如果是，返回true (A &lt; B) true &gt;= 检查左操作数的值是否大于或者等于右操作数的值，如果是，返回true (A &gt;= B) false &lt;= 检查左操作数的值是否小于或者等于右操作数的值，如果是，返回true (A &lt;= B) true 位运算符位运算应用于整数类型（int），长整型（long），短整型（short），字符型（char）和字节型（byte）等类型。 位运算符作用在所有的位上，并且按位运算。假设 A = 60, B = 13,则二进制表示如下 A = 0011 1100 B = 0000 1101 运算符 描述 例子 &amp; 按位与运算符，如果相对应位都是1，则结果为1，否则为0 (A &amp; B) = 0000 1100 即12 丨 按位或运算符，如果相对应位都是0，则结果为0，否则为1 (A 丨 B) = 0011 1101 即61 ^ 按位异或运算符，如果相对应位值相同，则结果为0，否则为1 (A ^ B) = 0011 0001 即49 ~ 取反运算符，按位取反运算符翻转操作数的每一位，即0变成1，1变成0 (~ A) = 1100 0011 即-61 &lt;&lt; 按位左移运算符。左操作数按位左移右操作数指定的位数 (A &lt;&lt; 2) = 1111 0000 即240 &gt;&gt; 按位右移运算符。左操作数按位右移右操作数指定的位数 (A &gt;&gt; 2) = 1111 即15 &gt;&gt;&gt; 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充 (A &gt;&gt;&gt; 2) = 00001111 即15 逻辑运算符假设 A = true, B = false 操作符 描述 例子 &amp;&amp; 逻辑与运算符。当且仅当两个操作数都为真，条件才为真。 (A &amp;&amp; B) = false 丨丨 逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 (A 丨丨 B) = true ！ 逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 ! (A &amp;&amp; B)= true 短路逻辑运算符当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。 短路逻辑与 12345678public class Main&#123; public static void main(String[] args) &#123; int a = 5; boolean b = (a &lt; 4) &amp;&amp; (a++&lt;10); System.out.println("使用短路逻辑运算符的结果为"+b); System.out.println("a的结果为"+a); &#125;&#125; 使用短路逻辑运算符的结果为falsea的结果为5 解析：该程序使用到了短路逻辑运算符(&amp;&amp;)，首先判断 a&lt;4 的结果为 false，则 b 的结果必定是 false，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。 短路逻辑或 12345678public class Main&#123; public static void main(String[] args) &#123; int a = 5; boolean b = (a &gt; 4) || (a++&lt;10); System.out.println("使用短路逻辑运算符的结果为"+b); System.out.println("a的结果为"+a); &#125;&#125; 使用短路逻辑运算符的结果为truea的结果为5 解析：该程序使用到了短路逻辑运算符(||)，首先判断 a &gt; 4 的结果为 true，则 b 的结果必定是 true，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。 赋值运算 操作符 描述 例子 = 简单的赋值运算符，将右操作数的值赋给左侧操作数 C = A + B将把A + B得到的值赋给C += 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数 C += A等价于C = C + A -= 减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数 C -= A等价于C = C - A *= 乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数 C = A等价于C = C A /= 除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数 C / = A等价于C = C / A (％)= 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 C％= A等价于C = C％A &lt;&lt; = 左移位赋值运算符 C &lt;&lt; = 2等价于C = C &lt;&lt; 2 &gt;&gt; = 右移位赋值运算符 C &gt;&gt; = 2等价于C = C &gt;&gt; 2 &amp;= 按位与赋值运算符 C＆= 2等价于C = C＆2 ^ = 按位异或赋值操作符 C ^ = 2等价于C = C ^ 2 丨= 按位或赋值操作符 C 丨 = 2等价于C = C 丨 2 其他运算符条件运算符条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。 对于条件表达式b ? x : y，先计算条件b，然后进行判断。如果b的值为true，计算x的值，运算结果为x的值；否则，计算y的值，运算结果为y的值。一个条件表达式绝不会既计算x，又计算y。条件运算符是右结合的，也就是说，从右向左分组计算。例如，a ? b : c ? d : e将按a ? b : (c ? d : e)执行。 instanceof 运算符该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。 用法：result = object instanceof class 12String name = "James";boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回 true Java 运算符优先级 类别 操作符 关联性 后缀 () [] . (点操作符) 左到右 一元 + - ! ~ 从右到左 乘性 * / ％ 左到右 加性 + - 左到右 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 左到右 关系 &gt; &gt;= &lt; &lt;= 左到右 相等 == != 左到右 按位与 ＆ 左到右 按位异或 ^ 左到右 按位或 丨 左到右 逻辑与 &amp;&amp; 左到右 逻辑或 丨丨 左到右 条件 ？： 从右到左 赋值 = += -= *= /= ％= &gt;&gt;= &lt;&lt;= &amp;= ^= 丨= 从右到左 逗号 ， 左到右]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础二--修饰符]]></title>
    <url>%2F2018%2F10%2F13%2FJava%E5%9F%BA%E7%A1%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Java 中主要有两类修饰符： 访问修饰符 非访问修饰符 访问修饰符 访问修饰符 当前类 同一包内 子类 其他包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × public : 公开,所有类可见 protected :继承访问权限（本包中的子类非子类均可访问，不同包中的子类可以访问，不是子类不能访问） default :包访问权限（本包中的子类非子类均可访问，不同包中的类及子类均不能访问） private :私有,在同一类内可见 [注]：protected的可见性在于两点： 父类的 protected 成员是包内可见的，并且对子类可见； 若子类与父类不在同一包中，那么在子类中，子类实例可以访问其从父类继承而来的protected方法，而不能访问父类实例的protected方法。 访问控制和继承 父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。 父类中声明为 private 的方法，不能够被继承。 Java 非访问修饰符Java 中的非访问修饰符有： static 修饰符，用来修饰类方法和类变量 final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract 修饰符，用来创建抽象类和抽象方法。 synchronized 和 volatile 修饰符，主要用于线程的编程。 Static 修饰符所谓静态就是指在编译后所分配的内存会一直存在，直到程序退出内存才会释放这个空间，也就是只要程序在运行，那么这块内存就会一直存在。 静态变量： static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。 静态方法： static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 final 修饰符final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。 final 修饰符通常和 static 修饰符一起使用来创建类常量。 类中的 final 方法可以被子类继承，但是不能被子类修改。声明 final 方法的主要目的是防止该方法的内容被修改。 final 类不能被继承，没有类能够继承 final 类的任何特性。 abstract 修饰符 抽象类： 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。 一个类不能同时被 abstract 和 final 修饰[被 final 修饰后就不能被继承了]。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。 抽象类可以包含抽象方法和非抽象方法。 抽象方法： 抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。 抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 抽象方法的声明以分号结尾。 synchronized 修饰符synchronized 关键字声明的方法同一时间只能被一个线程访问。 transient 修饰符序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。 该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。 volatile 修饰符volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 一个 volatile 对象引用可能是 null。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础一--基本数据类型&类型转换]]></title>
    <url>%2F2018%2F10%2F13%2FJava%E5%9F%BA%E7%A1%80%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Java 中有两大数据类型： 内置数据类型 引用数据类型 内置数据类型Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 基本类型 大小 最小值 最大值 默认值 包装类 例子 byte 8 bit -128 +127 0 Byte byte a = 100 short 16 bit -2^15 +2^15 - 1 0 Short short s = 1000 int 32 bit -2^31 +2^31 - 1 0 Integer int a = 100000 long 64 bit -2^63 +2^63 -1 0L Long long a = 100000L float 32 bit IEEE754 IEEE754 0.0f Float float f1 = 234.5f double 64 bit IEEE754 IEEE754 0.0d Double double d1 = 123.4 char 16 bit Unicode 0 Unicode 2^16-1 空 Character char letter = ‘A’ boolean - - - false Boolean boolean one = true 包装类虽然 Java 语言是典型的面向对象编程语言，但其中的八种基本数据类型并不支持面向对象编程，基本类型的数据不具备“对象”的特性——不携带属性、没有方法可调用。 沿用它们只是为了迎合人类根深蒂固的习惯，并的确能简单、有效地进行常规数据处理。 基本数据类型的不足 不具有对象的特性 无法进行对象化交互 解决办法——包装类 这种借助于非面向对象技术的做法有时也会带来不便，比如引用类型数据均继承了 Object 类的特性，要转换为 String 类型（经常有这种需要）时只要简单调用 Object 类中定义的 toString() 即可，而基本数据类型转换为 String 类型则要麻烦得多。为解决此类问题 ，Java 为每种基本数据类型分别设计了对应的类，称之为包装类(Wrapper Classes)。这样便可以把这些基本类型转换为对象来处理了。 每个包装类的对象可以封装一个相应的基本类型的数据，并提供了其它一些有用的方法。包装类对象一经创建，其内容（所封装的基本类型数据值）不可改变。 包装类有哪些？Java 中常用的包装类可以分为三类：Character、Number、Boolean 包装类与基本数据类型 装箱：把基本数据类型转换成包装类 自动装箱 手动装箱 拆箱：把包装类转换成基本数据类型 自动拆箱 手动拆箱 装箱&amp;拆箱什么是自动拆箱装箱？很简单，下面两局代码就可以看到装箱和拆箱的过程 1234//自动装箱Integer total = 99;//自动拆箱int totalprim = total; 简单的来说，自动装箱是 Java 编译器在 Java 基本数据类型和对应的对象包装类型上做的自动转换。例如把 int 转换成 Integer ，double 转换成 Double 等等 如果反过来，就是自动拆箱，这也是编译器为我们做的事。 通常我们要创建一个类的对象实例的时候，我们会这样：Class c = new Class(parameter); 当我们创建一个 Integer 对象是，却可以这样：Integer i = 100; 实际上，执行上面那句代码的时候，系统为我们执行了：Integer i = Integer.valueOf(100); 此即基本数据类型的自动装箱功能。 当我们将 Integer 对象赋值给 int 类型时： Integer i = 10; int t = i; 实际上，执行上面那句代码的时候，系统为我们执行了：int i = i.intValue();&gt; 接下来，我们来看这样的代码 12345678910public class Main&#123; public static void main(String args[]) &#123; Integer i1 = 32; Integer x1 = 32; System.out.println(i1 == x1); Integer i2 = 132; Integer x2 = 132; System.out.println(i2 == x2); &#125;&#125; 运行结果 truefalse 解释如下： 初始值在 -128 – 127 之间的值，它们被装箱为Integer对象后，会在内存中被重用。超过这个值的时候每次装箱是会产生新的对象。 为重载带来的问题 1234567891011121314151617public class Main&#123; public static void method(Integer x) &#123; System.out.println("Integer"); &#125; public static void method(long x) &#123; System.out.println("long"); &#125; public static void method(Long x) &#123; System.out.println("Long"); &#125; public static void main(String[] args) &#123; method(5); &#125;&#125; 运行结果 long 在这种情况下编译器选择的是加宽操作，而不是装箱。 测试结果（优先级排序）： int&gt;long &gt; float &gt; Integer &gt; Long(运行出错) &gt; char(编译报错) 这里说一下为什么转 Long 会出错。 因为 int 不能直接转为 Long 类型，int 是基本数据类型，而 Long 是包装类。int 转 Integer 可以通过装箱实现，而 Long 不是 int 的包装类，所以不行。 那么如果想将 int 转为 Long 呢？ 可以通过一下步骤 1234567public class Main&#123; public static void main(String[] args) &#123; int a = 5; long l = a;//先将 int 转为 long 类型 Long l1 = l;//再将 long 装箱 &#125;&#125; 字符串与基本数据类型 基本数据类型转换为字符串 使用包装类的 toString() 方法 字符串转换为基本数据类型 自动拆箱调用包装类的 parseXXX() 静态方法 调用包装类的 valueOf() 方法转换为基本类型的包装类，自动拆箱 基本类型与包装类型的异同 在 Java 中，一切皆对象，但是八大基本类型却不是对象 声明方式的不同，基本类型无须通过 new 关键字来创建，而包装类型需要 new 关键字 存储方式及位置的不同，基本数据类型是将变量的值保存在栈中，这样可以更高效的存取，包装类型需要通过引用指向实例，具体的实例保存在堆中 初始值的不同，包装类型的初始值为 null ，基本类型的初始值视具体的类型而定，比如 int 的初始值为0；boolean 的初始值为 false 使用方法的不同，比如与集合类合作使用时(泛型)，只能使用包装类型 引用类型 在 Java 中，引用类型的变量非常类似于 C/C++ 的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了 引用数据类型包括：类、接口类型、数组类型、枚举类型、注解类型，字符串型； 所有引用类型的默认值都是 null 类型转换什么是类型转换？ 整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。 转换从低级到高级 低————————————————————&gt;高 byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 数据类型转换必须满足如下规则： 不能对boolean类型进行类型转换。 不能把对象类型转换成不相关类的对象。 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。 转换过程中可能导致溢出或损失精度，例如： 12int i =128; byte b = (byte)i; 因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如： 12(int)23.7 == 23; (int)-45.89f == -45 类型转换分为： 自动类型转换 强制类型转换 自动类型转换必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。 12345678910public class ZiDongLeiZhuan&#123; public static void main(String[] args)&#123; char c1='a';//定义一个char类型 int i1 = c1;//char自动类型转换为int System.out.println("char自动类型转换为int后的值等于"+i1); char c2 = 'A';//定义一个char类型 int i2 = c2+1;//char 类型和 int 类型计算 System.out.println("char类型和int计算后的值等于"+i2); &#125;&#125; 结果为： 12char自动类型转换为int后的值等于97char类型和int计算后的值等于66 解析：c1 的值为字符 a ,查 ASCII 码表可知对应的 int 类型值为 97， A 对应值为 65，所以 i2=65+1=66。 强制类型转换将高级别类型赋值给低级别类型时，必须进行强制类型转换。 条件是转换的数据类型必须是兼容的。 格式：(type)value type是要强制类型转换后的数据类型。 小结 Java 中有两大数据类型，基本数据类型和引用数据类型。 基本数据类型在被创建时，在栈上给其划分一块内存，将数据直接存储在栈上. 引用数据类型在被创建时，首先要在栈上给其引用分配一块内存，而对象的具体信息都存储在堆上，然后由栈上面的引用指向堆中对象的地址。 简答的说小类型可自动转换为大类型，大类型转小类型需要强制转换。 箭头指向的方向表示可以自动转换，箭头的相反方向需要强制转换，虚线所指向的内容可能发生精度的丢失。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
</search>
