<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F18%2FJava%E5%9F%BA%E7%A1%80%E4%B8%83-%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F18%2FJava%E5%9F%BA%E7%A1%80%E4%B8%83-%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F18%2FJava%E5%9F%BA%E7%A1%80%E4%B8%83-%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java基础七--多态]]></title>
    <url>%2F2018%2F10%2F18%2FJava%E5%9F%BA%E7%A1%80%E4%B8%83%2F</url>
    <content type="text"><![CDATA[多态多态是同一个行为具有多个不同表现形式或形态的能力。 多态的分类 编译时多态（设计时多态）：方法重载 运行时多态：Java 运行时系统根据调用该方法的实例的类型来决定选择调用哪个方法则被称为运行时多态 我们平时说的多态，多指运行时多态 多态的实现方法 重写 这个内容写过了，可以访问: 接口 生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。 java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看Java基础七-接口这一章节的内容 抽象类和抽象方法 详情请看Java基础七-抽象类 。 向上转型 &amp; 向下转型要转型，首先要有继承。 向上类型转换（Upcast）：将子类对象转换为父类，父类可以是接口 隐式/自动类型转换，是小类型到大类型的转换。 向下类型转换（Downcast）：将父类型转换为子类型 强制类型转换，是大类型到小类型。 通过 instanceof 运算符，来解决引用对象的类型，避免类型转换的安全性问题，提高代码的健壮性。 向上转型举一个大家都知道的例子： 12345public class Animal &#123; public void eat()&#123; System.out.println("animal eating..."); &#125;&#125; 12345public class Cat extends Animal&#123; public void eat()&#123; System.out.println("猫吃鱼"); &#125;&#125; 123456789public class Dog extends Animal &#123; public void eat()&#123; System.out.println("狗吃肉"); &#125; public void run()&#123; System.out.println("狗爱跑"); &#125;&#125; 12345678public class Main &#123; public static void main(String[] args) &#123; Animal animal = new Cat();//向上转型 animal.eat(); animal = new Dog(); animal.eat(); &#125;&#125; 执行结果： 猫吃鱼狗吃肉 这就是向上转型，向上转型是安全的，因为任何子类都继承并接受了父类的方法。从例子中也可以看出猫和狗都属于他们的父类——Animal，这是可行的。但是向下转型就不行，若所所有的动物都是猫或者都是狗就不成立的。（所以向下转型要通过强制类型转换） Animal animal = new Cat(); 将子类对象 Cat 转换为父类对象 Animal 。这个时候 animal 这个引用调用的方法是子类方法。 转型过程中需要注意的问题 向上转型时，子类单独定义的方法会丢失。比如上面 Dog 类中定义的 run 方法，当 animal 引用指向 Dog 类实例时是访问不到 run 方法的，animal.run()；会报错。 子类引用引用不能指向父类对象。Cat c = (Cat)new Animal()这样是不行的。 向上转型的应用 当一个子类对象向上转型父类类型后，就被当成了父类的对象，所能调用的方法会减少，只能调用子类重写了父类的方法以及父类派生的方法（如 set(),get()方法），而不能调用子类独有的方法。 继续用上面的例子： 12345678910public class Main &#123; public static void main(String[] args) &#123; Animal animal = new Cat();//向上转型 animal.eat(); animal = new Dog(); animal.eat(); //如果调用 Dog 类中的 run() 方法。 animal.run();//这个会报错，编译不通过 &#125;&#125; 可以调用子类重写父类的方法 eat()，但调用子类独有的方法 run() 时就是无效的 父类中的静态方法是不允许被子类重写的 如父类 Animal 中含有静态方法 sleep() 12345678public class Animal &#123; public void eat()&#123; System.out.println("animal eating..."); &#125; public static void sleep()&#123; System.out.println("animal sleep..."); &#125;&#125; 当子类 Cat 中也定义同名方法时，此时 sleep() 算 Cat 类自己独有的方法 12345678public class Cat extends Animal&#123; public void eat()&#123; System.out.println("猫吃鱼"); &#125; public static void sleep()&#123; System.out.println("猫要睡大觉！"); &#125;&#125; 1234567public class Main &#123; public static void main(String[] args) &#123; Animal animal = new Cat(); animal.eat(); animal.sleep(); &#125;&#125; 执行结果： 猫吃鱼animal sleep… 实际上调用的是父类的静态方法 sleep() 这是因为父类的静态方法可以被子类继承，但是不能重写。 向上转型的好处 减少重复代码，使代码变得简介 提高系统扩展性 举个例子：比如，我现在有很多种类的动物，要喂它们吃东西。如果不用向上转型，那我需要这样写： 1234567891011public void eat(Cat c)&#123; c.eat();&#125;public void eat(Dog d)&#123; d.eat();&#125;...eat(new Cat());eat(new Dog());... 一种动物写一个方法，如果我有一万种动物，我不得写一万个方法？假设你很厉害，耐着性子写完了，突然又来一个新的动物，你是不是又要单独为它写一个 eat() 方法？ 那如果我用向上转型呢？ 12345678public void eat(Animal a)&#123; a.eat();&#125;eat(new Cat());eat(new Cat());eat(new Dog());//..... 这样代码是不是简洁了许多？而且这个时候，如果我又有一种新的动物加进来，我只需要实现它自己的类，让他继承Animal就可以了，而不需要为它单独写一个eat方法。是不是提高了扩展性？ 扩展多态的实现可以通过向上转型和动态绑定机制来完成，向上转型实现了将子类对象向上转型为父类类型，而动态绑定机制能识别出对象转型前的类型，从而自动调用该类的方法，两者相辅相成。 绑定就是将一个方法调用同一个方法所在的类连接到一起就是绑定。绑定分为静态绑定和动态绑定两种。 静态绑定在程序运行之前进行绑定（由编译器和链接程序完成的），也叫作前期绑定。 动态绑定在程序运行期间由 JVM 根据对象的类型自动的判断应该调用那个方法，也叫做后期绑定。 静态绑定的例子如有一个父类 Human，它派生出来三个字类 Chinese 类、American 类、British类，三个子类中都重写了父类中的 speak() 方法，在测试类中用静态绑定的方式调用方法 speak()。 12345public class Human &#123; public void speak()&#123; System.out.println("Human speak..."); &#125;&#125; 12345public class Chinese extends Human&#123; public void speak() &#123; System.out.println("speak chinese."); &#125;&#125; 12345public class American extends Human&#123; public void speak() &#123; System.out.println("speak American English."); &#125;&#125; 12345public class British extends Human&#123; public void speak() &#123; System.out.println("speak English."); &#125;&#125; 12345678910public class Main &#123; public static void main(String[] args) &#123; Chinese c = new Chinese(); c.speak(); American a = new American(); a.speak(); British b = new British(); b.speak(); &#125;&#125; 这种调用方式是在代码里指定的，编译时编译器就知道 c 调动的是 Chinese 中的 speak() 方法，a 调用的是 American 的 speak() 方法。 动态绑定的例子如果我们在测试类中做如下改动 12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; //生成父类对象数组，数组长度为5。 Human[] humans = new Human[5]; int n; for (int i = 0; i &lt; humans.length; i++) &#123; n = (int) (Math.random()*3);//随机生成从0到2中的一个数 switch(n)&#123; case 0: humans[i] = new Chinese(); break; case 1: humans[i] = new American(); break; case 2: humans[i] = new British(); break; &#125; &#125; //循环输出，循环体中每个对象分别调用 speak() 方法 for (int i = 0; i &lt; humans.length; i++) &#123; humans[i].speak(); &#125; &#125;&#125; 运行结果： speak English.speak chinese.speak English.speak American English.speak English. 此时，Human 类中随机生成 Chinese 类、American 类和 British 类的对象，编译器不能根据代码直接确定调用那个类中的 speak() 方法，直到运行时才能根据产生的随机数 n 的值来确定 humans[i]到底代表哪一个子类的对象，这样才能最终确定调用的是哪个类中的 speak() 方法，这就是动态绑定。 向下转型与向上转型相对应的就是向下转型了。向下转型是把父类对象转为子类对象。(请注意！这里是有坑的。)它是用子类引用指向父类实例。 下图，在进行转换是会报错 12Animal a = new Cat();Cat c = a； 这就告诉我们向下转型不能自动转换，我们需要强转，所以乡下转型又叫做强制类型转换。 正确的语句是： 1234//还是上面的animal和cat dogAnimal a = new Cat();Cat c = (Cat) a;c.eat(); 输出结果： 猫吃鱼 12Dog d = (Dog) a;d.eat(); 报错：java.lang.ClassCastException: Cat cannot be cast to Dog 123Animal a1 = new Animal();Cat c1 = (Cat) a1;c1.eat(); 报错：java.lang.ClassCastException: Animal cannot be cast to Cat 为什么第一段代码不报错呢？相比你也知道了，因为a本身就是 Cat 对象，所以它理所当然的可以向下转型为Cat，也理所当然的不能转为 Dog，你见过一条狗突然就变成一只猫这种现象？ 而a1为 Animal 对象，它也不能被向下转型为任何子类对象。比如你去考古，发现了一个新生物，知道它是一种动物，但是你不能直接说，啊，它是猫，或者说它是狗。 向下转型注意事项 向下转型的前提是父类对象指向的是子类对象（也就是说，在向下转型之前，它得先向上转型） 向下转型只能转型为本类对象，兄弟类之间不能进行强制类型转换。（猫是不能变成狗的）。 大概你会说，我特么有病啊，我先向上转型再向下转型？？ 声明上转型对象是为了可以直接调用子类中重写的方法，但是不能调用子类新增的方法。而下转型对象可以调用子类新增的方法 我们回到上面的问题：喂动物吃饭，吃了饭做点什么呢？不同的动物肯定做不同的事，怎么做呢？ 12345678910111213141516171819public void eat(Animal a)&#123; if(a instanceof Dog)&#123; Dog d = (Dog)a; d.eat(); d.run();//狗有一个跑的方法 &#125; if(a instanceof Cat)&#123; Cat c = (Cat)a; c.eat(); System.out.println("我也想跑，但是不会"); //猫会抱怨 &#125; a.eat();//其他动物只会吃&#125;.....eat(new Cat());eat(new Cat());eat(new Dog());..... 现在，你懂了么？这就是向下转型的简单应用，可能举得例子不恰当，但是也可以说明一些问题。 敲黑板，划重点！看到那个 instanceof 了么？ instanceof 运算符instanceof 运算符用来判断对象是否可满足某个特定类型实例特征，简单的来说，就是判断其左边对象是否为其右边类的实例，返回boolean类型的数据。可以用来判断继承中的子类的实例是否为父类的实现。 1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; //对象实例化 Animal c = new Cat(); Animal d = new Dog(); //用 instanceof 运算符判断对象是否满足某个特定对象实例特征 System.out.println(c instanceof Animal); System.out.println(c instanceof Cat); System.out.println(c instanceof Dog); System.out.println(c instanceof Object); System.out.println(d instanceof Animal); System.out.println(d instanceof Cat); System.out.println(d instanceof Dog); System.out.println(d instanceof Object); &#125;&#125; 运行结果： truetruefalsetruetruefalsetruetrue 抽象类 &amp; 抽象方法应用场景：某个父类只是限定其子类应该包括怎样的方法，但不需要准确知道这些子类如何实现这些方法。 抽象类 Java 中使用抽象类，限制实例化 123public abstract class Animal&#123; &#125; 抽象方法abstract 也可用于方法——抽象方法 1public abstract void eat(); 注意 抽象类不能直接实例化，必须借助子类完成相应的实例化操作 子类如果没有重写父类中所有的抽象方法，则也要定义为抽象类 抽象方法所在的类一定是抽象类 抽象类中可以没有抽象方法 接口 接口定义了某一批类所需要遵守的规范 接口不关心这些类的内部数据，也不关心这些类里方法的实现细节，它只规定这些类里必须提供某些方法 语法123456[修饰符] interface 接口[extends 父接口1，父接口2..]&#123; 零到多个常亮定义... 零到多个抽象方法的定义... 零到多个默认方法的定义...（jdk1.8 新增） 零到多个静态方法的定义...（jdk1.8 新增）&#125; 注意 接口可以实现多继承，即一个子接口可以同时继承多个父接口 实现接口的类如果不能实现接口中所有待重写的方法，则必须设置为抽象类 一个类可以继承自一个父类，同时实现多个接口 内部类 在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类 与之对应，包含内部类的类被称为外部类]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>多态</tag>
        <tag>向上转型&amp;向下转型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础六--继承]]></title>
    <url>%2F2018%2F10%2F17%2FJava%E5%9F%BA%E7%A1%80%E5%85%AD%2F</url>
    <content type="text"><![CDATA[继承继承的概念 继承是类与类之间的一种关系 使用已存在的类的定义作为基础建立新的类 新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。 当两个类之间满足 “A is a B” 的关系，我们就说它们满足继承关系 继承的特点 利于代码复用 缩短开发周期 语法 使用 extends 实现继承 Java 只支持单继承，一个类只能有一个父类（也称为超类、基类） 继承后的初始化顺序父类的静态成员 子类静态成员 父类对象构建【属性（赋值）、构造代码块、构造方法】 子类对象构建【属性（赋值）、构造代码块、构造方法】 Super关键字如何区分调用的是继承父类的方法还是子类自己重写的方法? 访问父类成员方法 1super.print(); 访问父类属性 1super.name; 子类对象实例化时，能否选择父类的构造形式（调用指定的构造方法）？ 访问父类构造方法 12super();//无参的构造方法super("name");//有参的构造方法 子类的构造过程中必须调用其父类的构造方法，默认调用无参的构造方法 如果子类构造方法中既没有显示标注，而父类有没有无参的构造方法，则编译出错 使用 super 调用父类指定构造方法，必须在子类的构造方法的第一行 this 关键字 &amp; super 关键字 this 关键字——当前类对象的引用 super 关键字——父类对象的引用 访问当前类的成员方法访问当前类的成员属性访问当前类的构造方法不能再静态方法中使用 访问父类的成员方法访问父类的成员属性访问父类的构造方法不能再静态方法中使用 构造方法调用时，super 和 this 不能同时出现 重写 &amp; 重载 方法重写 方法重载 在满足继承关系的子类中方法名、参数个数、顺序、返回值与父类相同返回值类型与父类的返回值类型向下兼容访问修饰符的限定范围大于等于父类方法 在同一个类中方法名相同参数个数、顺序、类型不同返回值类型、访问修饰符任意 方法重写存在，属性重写不存在 Object 类 Object 类是所有类的父类 一个类没有使用 extends 关键字明确标识继承关系，则默认继承 Object 类（包括数组） Java 中的每个类都可以使用 Object 中定义的方法 Object 类的常用方法 方法 说明 toString() 返回当前对象本身的有关信息，按字符串对象返回 equals() 比较两个对象是否是同一个对象，是则返回true hashCode() 返回该对象的哈希代码值 getClass() 获取当前对象所属的类信息，返回Class对象 final关键字final 表示“最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。 被 final 修饰的类表示不允许被继承 被 final 修饰的方法表示不允许被子类重写 final 修饰的方法可以被继承 不能修饰构造方法 被 final 修饰的变量表示不允许被修改 方法内部的局部变量 —&gt; 在使用之前被初始化赋值即可 类中的成员变量 —&gt; 只能在定义时或者构造代码块、构造方法中进行初始化设置 基本数据类型的变量 —&gt; 初始赋值之后不能更改 引用类型的变量—&gt;初始化之后不能再指向另一个对象，但指向的对象的内容时可变的 不能修饰构造方法 可配合 static 使用，表示静态的、不允许被修改的信息 使用 final 修饰可以提高性能，但会降低可扩展性 注解可以声明在包、类、属性、方法、局部变量、方法参数等的前面，用来对这些元素进行说明、注释 按照运行机制分 源码注解 编译时注解 运行时注解 按照来源分 来自 JDK 的注解 来自第三方的注解 自定义注解]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>继承</tag>
        <tag>super关键字</tag>
        <tag>this关键字</tag>
        <tag>final关键字</tag>
        <tag>重写&amp;重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构概述]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[数据结构算法 + 数据结构 = 编程 什么是数据结构？ 通俗的来说，数据结构是计算机存储、组织数据的方式。 常用的数据机构有： 数组 栈 队列 链表 树 图 字典树（这是一种高效的树形结构，但值得单独说明） 散列表（哈希表） 数组数组是最简单、也是使用最广泛的数据结构。栈、队列等其他数据结构均是由数组演变过来的。 下图是一个包含元素（1、2、3、4）的简单数组，数组长度为4。 每个数据元素都关联一个正数值，我们称之为索引，它表明数组中每个元素所在的位置。大部分语言将初始索引定义为零。 数组的两种类型： 一维数组 多维数组 数组的基本操作 Insert——在指定索引位置插入一个元素 Get——返回指定索引位置的元素 Delete——删除指定索引位置的元素 Size——得到数组所有元素的数量 面试中关于数组的常见问题 寻找数组中第二小的元素 找到数组中第一个不重复出现的整数 合并两个有序数组 重新排列数组中的正值和负值 栈著名的撤销操作几乎遍布任意一个应用。但是你有没有想过他是如何实现的？这个问题的解决思路是按照将最后的状态排列在前的顺序，在内存中存储历史工作状态。这没办法用数组实现，但是有了栈，这就变得很方便了。 可以把栈想象成一摞书，为了拿到中间的书，你需要移除放置在这上面的所有书。这就是LIFO（后进先出）的工作原理。 下图是包含三个数据元素（1、2、3）的栈，其中顶部的3将被最先移除： 栈的基本操作 Push——在顶部插入一个元素 Pop——返回并移除栈顶元素 isEmpty——如果栈为空，则返回true Top——返回顶部元素，但并不移除它 面试中关于栈的常见问题 使用栈计算后缀表达式 对栈的元素进行排序 判断表达式是否括号平衡 队列与栈类似，队列是另一种顺序存储元素的线性数据结构。栈与队列的最大差别在于栈是LIFO（后进先出），而队列是FIFO（先进先出） 常见的队列：排队上车，如果有新人加入，他需要到队尾排队，而非队首。排在前面的人会先上车，然后离开队伍。 下图是包含四个元素（1，2，3，4）的队列，其中在顶部的1将被最先移除： 移除先入队的元素、插入新元素 队列的基本操作 Enqueue() —— 在队列尾部插入元素 Dequeue() ——移除队列头部的元素 isEmpty()——如果队列为空，则返回true Top() ——返回队列的第一个元素 面试中关于队列的常见问题 使用队列表示栈 对队列的前k个元素倒序 使用队列生成从1到n的二进制数 链表链表是另一个重要的数据结构，乍一看可能有点像数组，但在内存分配，内部结构以及数据插入和删除的基本操作方面均有所不同。 链表就像一个节点链，其中每个节点包含着数据和指向后续节点的指针。链表还包含一个头指针，它指向链表的第一个元素，但当列表为空时，它指向null或无具体内容。 链表一般用于实现文件系统、哈希表和邻接表。 这是链表内部结构的展示： 链表包括以下类型： 单链表 双向链表 链表的基本操作： InsertAtEnd - 在链表的末尾插入指定元素 InsertAtHead - 在链接列表的开头/头部插入指定元素 Delete - 从链接列表中删除指定元素 DeleteAtHead - 删除链接列表的第一个元素 Search - 从链表中返回指定元素 isEmpty - 如果链表为空，则返回true 面试中关于链表的常见问题 反转链表 检测链表中的循环 返回链表倒数第N个节点 删除链表中的重复项 图图是一组以网络形式相互连接的节点，节点也称为顶点。一对节点（x，y）称为边（edge），表示顶点x连接到顶点y。边可以包含权重/成本，显示从顶点x到y所需的成本。 图的类型 无向图 有向图 在程序语言中，图可以用两种形式表示 邻接矩阵 邻接表 常见的图遍历算法 广度优先搜索 深度优先搜索 面试中关于图的常见问题 实现广度和深度优先搜索 检查图是否为树 计算图的边数 找到两个顶点之间的最短路径 树树形结构是一种层级式的数据结构，由顶点（节点）和连接他们的边组成。数类似于图，但区分树和图的重要特征是树种不存在环路。 这是一个简单树的示意图，以及树数据结构中使用的基本术语： Root - 根节点 Parent - 父节点 Child - 子节点 Leaf - 叶子节点 Sibling - 兄弟节点 树形结构的主要类型 N元树 平衡树 二叉树 二叉搜索树 AVL树 红黑树 2-3树 B 树 B+ 树 其中，二叉树和二叉搜索树是最常用的树。 面试中关于树结构的常见问题 求二叉树的高度 在二叉搜索树中查找第k个最大值 查找与根节点距离k的节点 在二叉树中查找给定节点的祖先节点 字典树字典树，也称为“前缀树”，是一种特殊的树形数据结构，对于解决字符串相关问题非常有效。他能够提供快速减速，主要用于搜索字典中的单词，在搜索引擎中自动提供建议，甚至被用于 IP 的路由。 以下是在字典树中存储三个单词“top”，“thus”和“their”的例子： 这些单词以顶部到底部的方式存储，其中绿色节点“p”，“s”和“r”分别表示“top”，“thus”和“their”的底部。 面试中关于字典树的常见问题 计算字典树中的总单词数 打印存储在字典树中的所有单词 使用字典树对数组的元素进行排序 使用字典树从字典中形成单词 构建T9字典（字典树+ DFS ） 哈希表哈希法（Hashing）是一个用于唯一标识对象并将每个对象存储在一些预先计算的唯一索引（称为“键key”）中的过程。因此，对象以键值对的形式存储，这些键值对集合被称为“字典”。可以使用键搜索每个对象。基于哈希法有很多不同的数据结构，但最常用的数据结构是哈希表。 哈希表通常用数组实现。 散列数据结构的性能取决于以下三个因素： 哈希函数 哈希表的大小 碰撞处理方法 下图为如何在数组中映射哈希键值对的说明。该数组的索引是通过哈希函数计算的。 面试中关于哈希结构的常见问题： 在数组中查找对称键值对 追踪遍历的完整路径 查找数组是否是另一个数组的子集 检查给定的数组是否不相交]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础五--封装]]></title>
    <url>%2F2018%2F10%2F14%2FJava%E5%9F%BA%E7%A1%80%E4%BA%94%2F</url>
    <content type="text"><![CDATA[封装什么是封装？ 通过该类提供的方法来实现对隐藏信息的操作和访问 隐藏对象的信息 留出访问的接口 封装的优点 良好的封装能减少耦合 类内部的结构可以自由修改 可以对成员变量进行更精确的控制 隐藏信息，实现细节 实现Java封装的步骤 隐藏对象 修改属性的可见性——设置为 private 1234public class Person&#123; private String name; private int age;&#125; 这段代码中，将 name 和 age 属性设置为私有的，只有本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。 留出接口 创建 getter / setter 方法——设置为 public 用于属性的读写 在 getter / setter 方法中加入属性控制语句——对属性值的合法性进行判断 1234567891011121314151617181920public class Person&#123; private String name; private int age; public int getAge()&#123; return age; &#125; public String getName()&#123; return name; &#125; public void setAge(int age)&#123; this.age = age; &#125; public void setName(String name)&#123; this.name = name; &#125;&#125; 采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name）之间发生的同名的冲突。 包作用 管理 Java 文件 解决同名文件冲突 定义包语法：package 包名; 注意： 1.必须放在 Java 源文件中的第一行 2.一个 Java 源文件中只能有一个 package 语句 3.包名全部英文小写 4.命名方式：域名倒序 + 模块 + 功能 eg：package com.nuc.zigbee; 导入包语法： import 包名.类名; eg: import com.nuc.*; import com.nuc.zigbee; 常用系统包java.lang 包含 Java 语言基础的类 java.util 包含 Java 语言中的各种工具类 java.io 包含输入、输出相关功能的类 static 关键字static 翻译为静态，从面向对象的角度讲，当一个类中的变量或方法用 static 修饰时，这些变量和方法就成了类本身的，他们和对象的关系并不大。但是从直观的角度讲，这些被修饰的量确实被该类所有对象所拥有，并且被这个类的所有对象所共享，求其是当使用该类对象进行引用他们时。其实当使用对象进行引用 static 修饰成员时，在底层代码的实现中，其实还是转换为类名进行引用，这表明这个成员属于类。 static + 属性——静态属性、类属性 static + 方法——静态方法、类方法 static + 类——不存在，不能加载类前 static + 方法内局部变量——不能加载局部变量前 static + 代码块——静态代码块 代码块 通过{}可以形成代码块 方法内的代码块称为：普通代码块 类内的代码块称为：构造代码块 构造代码块前 + static：静态代码块 注意 初学这个关键字时，书上有个重点，那就是一个类中， static 修饰的成员不能访问势力成员，只能访问静态成员。这个很好理解，static 修饰的成员叫做类成员，属于类本身的属性，随着类的编译进行初始化，而此时实例成员未必进行初始化，这就会带来很多错误，所以类成员访问实例成员是不能通过编译的。 静态方法中不可以定义 this，super 关键字，因为静态元素优先于对象存在。 静态成员的声明周期静态成员随着类的加载而产生，销毁时释放，生命周期伴随着类的整个的生命周期，生命周期长，这就意味着对内存资源的占用也会相对比较长。 静态方法中的成员调用 可以直接调用同类中的静态成员。 不可以直接调用同类中的非静态成员。 只能通过对象实例化后，对象.成员方法 的方式访问非静态成员。 各种代码块的执行顺序无论实例产生多少对象，静态代码块只执行一次。 构造代码块在每次对象构造的时候调用。 方法中的普通代码块则是在每次调用方法的时候顺序调用。 什么时候定义静态变量当对象中出现共享数据时，该数据被修饰成静态，对象中的特有数据，修饰为非静态，存在于堆内存中。 什么时候定义静态方法当功能内部没有访问到非静态数据（对象中特有的数据），该函数可以定义为静态的。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>封装</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础四--面向对象基础]]></title>
    <url>%2F2018%2F10%2F13%2FJava%E5%9F%BA%E7%A1%80%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[如果你现实中没有对象，至少你在java世界里会有茫茫多的对象，听起来是不是很激动呢？ 对象对象是类的一个实例，有状态和行为。 我们所在的世界，周围的一切事物都是对象，车、人、狗等等。这些对象都有自己的状态和行为。 我们用一只猫来举例，它的状态有：名字、品种、颜色，行为由：跑，叫，睡觉。 软件的对象也有状态和行为。软件对象的状态称为属性，行为通过方法体现。 那么什么是面向对象？关注现实存在的事物的各方面的信息，从对象的角度出发，根据事物的特征进行程序设计 类类是一个模子，确定对象将会拥有的特性（属性）和行为（方法） 类的特点： 类是对象的类型 具有相同属性和方法的一组对象的集合 对象是类的实例表现 属性对象具有的静态特征。对象“有什么”。 方法对象具有的各种动态行为。对象“能做什么”。 变量一个类中可以包含以下类型变量： 局部变量 在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都在方法中，方法结束后，变量就会自动销毁 成员变量 成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问 类变量 类变量也声明在类中，方法体之外，但必须声明为static类型 类和对象的关系类是抽象的概念，仅仅是模板 对象是一个你能看得见，摸得着的具体实体 类是对象的类型 对象是特定类型的数据 对象实例化实例化对象的过程可以分为两部分: - 声明对象 Cat one - 实例化对象 new Cat() - Cat one = new Cat();//类名 对象名 = new 构造方法(); 声明对象，就是在内存的栈区域开辟一块空间，此时这个空间里的值是空的 实例化对象，在内存的堆区域开辟一块空间，完成初始化操作 经过赋值操作，我们将堆空间中的地址，传递到了栈当中的内存空间里。此后，我们就可以通过对象名去调用对象的属性和方法了。 每次 new 对象就会产生新的实例化方法 - Cat one = new Cat(); - Cat two = new Cat(); 多个对象也可以指向同一块实例化空间 - Cat one = new Cat(); - Cat two = one; 对象实例化对象必须被实例化之后才能使用 对象间的引用传递，实际上传递的是堆内存空间的使用权 构造方法 构造方法与类同名且没有返回值 只能在对象实例化的时候调用 一个类可以有多个构造方法—构造方法重载 当没有指定构造方法时，系统会自动调用无参的构造方法 当有指定构造方法，无论是有参、无参的构造方法，都不会自动调用无参的构造方法。 构造方法不可被重写 this 关键字this: 当前对象的默认引用 this 的使用 - 调用成员属性，解决成员属性和局部变量同名冲突 123456String name;int age;public Cat(String name)&#123; this.name = name; System.out.println("我是单参构造");&#125; - 调用成员方法 1234567public void run()&#123; this.eat(); System.out.println("小猫快跑");&#125;public void eat()&#123; System.out.println("猫吃鱼");&#125; - 调用重载的构造方法 12345678public Cat()&#123; System.out.println("我是无参构造");&#125;public Cat(String name)&#123; this();//通过this()调用构造方法，必须放在方法体内的第一行。 this.name = name; System.out.println("我是单参构造");&#125; 源文件声明规则当在一个源文件中定义多个类，并且还有 import 语句和 package 语句时，要特别注意这些规则 一个源文件中只能有一个 public 类 一个源文件可以有多个非public类 源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为 Employee.java 如果一个类定义在某个包中，那么 package 语句应该在源文件的首行 如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么import 语句应该在源文件中最前面 import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础三--运算符]]></title>
    <url>%2F2018%2F10%2F13%2FJava%E5%9F%BA%E7%A1%80%E4%B8%89%2F</url>
    <content type="text"><![CDATA[在 Java 中运算符有一下几组 算数运算符 关系运算符 位运算符 逻辑运算符 赋值运算符 其他运算符 算数运算符算数运算符用在数学表达式中，作用和在数学中的作用一样。 在表格中 A = 10, B = 20 操作符 描述 例子 + 加法 A + B = 30 - 减法 A - B = -10 * 乘法 A * B = 200 / 除法 B / A = 2 % 取余 B % A = 0 ++ 自增 A++ 或 ++A 等于11 – 自减 B– 或者 –B 等于19 i++ 和 ++i 的区别 ++i 先进行自增操作，在进行表达式运算 i++ 先进行表达式运算，在进行自增操作 简单的来说，i++ 与 ++i 在单独使用的时候，都代表了 i = i + 1; 表达式 a = ++i; 等价于 i = i + 1;a = i; 表达式 a = i++; 等价于 a = i;i = i + 1; 关系运算符A = 10, B = 20 运算符 描述 例子 == 检查两个操作数的值是否相等，如果相等则返回true (A = B) false != 检查两个操作数的值是否相等，如果不相等则返回true (A != B) true &gt; 检查左操作数的值是否大于右操作数的值，如果是，返回true (A &gt; B) false &lt; 检查左操作数的值是否小于右操作数的值，如果是，返回true (A &lt; B) true &gt;= 检查左操作数的值是否大于或者等于右操作数的值，如果是，返回true (A &gt;= B) false &lt;= 检查左操作数的值是否小于或者等于右操作数的值，如果是，返回true (A &lt;= B) true 位运算符位运算应用于整数类型（int），长整型（long），短整型（short），字符型（char）和字节型（byte）等类型。 位运算符作用在所有的位上，并且按位运算。假设 A = 60, B = 13,则二进制表示如下 A = 0011 1100 B = 0000 1101 运算符 描述 例子 &amp; 按位与运算符，如果相对应位都是1，则结果为1，否则为0 (A &amp; B) = 0000 1100 即12 丨 按位或运算符，如果相对应位都是0，则结果为0，否则为1 (A 丨 B) = 0011 1101 即61 ^ 按位异或运算符，如果相对应位值相同，则结果为0，否则为1 (A ^ B) = 0011 0001 即49 ~ 取反运算符，按位取反运算符翻转操作数的每一位，即0变成1，1变成0 (~ A) = 1100 0011 即-61 &lt;&lt; 按位左移运算符。左操作数按位左移右操作数指定的位数 (A &lt;&lt; 2) = 1111 0000 即240 &gt;&gt; 按位右移运算符。左操作数按位右移右操作数指定的位数 (A &gt;&gt; 2) = 1111 即15 &gt;&gt;&gt; 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充 (A &gt;&gt;&gt; 2) = 00001111 即15 逻辑运算符假设 A = true, B = false 操作符 描述 例子 &amp;&amp; 逻辑与运算符。当且仅当两个操作数都为真，条件才为真。 (A &amp;&amp; B) = false 丨丨 逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 (A 丨丨 B) = true ！ 逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 ! (A &amp;&amp; B)= true 短路逻辑运算符当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。 短路逻辑与 12345678public class Main&#123; public static void main(String[] args) &#123; int a = 5; boolean b = (a &lt; 4) &amp;&amp; (a++&lt;10); System.out.println("使用短路逻辑运算符的结果为"+b); System.out.println("a的结果为"+a); &#125;&#125; 使用短路逻辑运算符的结果为falsea的结果为5 解析：该程序使用到了短路逻辑运算符(&amp;&amp;)，首先判断 a&lt;4 的结果为 false，则 b 的结果必定是 false，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。 短路逻辑或 12345678public class Main&#123; public static void main(String[] args) &#123; int a = 5; boolean b = (a &gt; 4) || (a++&lt;10); System.out.println("使用短路逻辑运算符的结果为"+b); System.out.println("a的结果为"+a); &#125;&#125; 使用短路逻辑运算符的结果为truea的结果为5 解析：该程序使用到了短路逻辑运算符(||)，首先判断 a &gt; 4 的结果为 true，则 b 的结果必定是 true，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。 赋值运算 操作符 描述 例子 = 简单的赋值运算符，将右操作数的值赋给左侧操作数 C = A + B将把A + B得到的值赋给C += 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数 C += A等价于C = C + A -= 减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数 C -= A等价于C = C - A *= 乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数 C = A等价于C = C A /= 除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数 C / = A等价于C = C / A (％)= 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 C％= A等价于C = C％A &lt;&lt; = 左移位赋值运算符 C &lt;&lt; = 2等价于C = C &lt;&lt; 2 &gt;&gt; = 右移位赋值运算符 C &gt;&gt; = 2等价于C = C &gt;&gt; 2 &amp;= 按位与赋值运算符 C＆= 2等价于C = C＆2 ^ = 按位异或赋值操作符 C ^ = 2等价于C = C ^ 2 丨= 按位或赋值操作符 C 丨 = 2等价于C = C 丨 2 其他运算符条件运算符条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。 对于条件表达式b ? x : y，先计算条件b，然后进行判断。如果b的值为true，计算x的值，运算结果为x的值；否则，计算y的值，运算结果为y的值。一个条件表达式绝不会既计算x，又计算y。条件运算符是右结合的，也就是说，从右向左分组计算。例如，a ? b : c ? d : e将按a ? b : (c ? d : e)执行。 instanceof 运算符该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。 用法：result = object instanceof class 12String name = "James";boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回 true Java 运算符优先级 类别 操作符 关联性 后缀 () [] . (点操作符) 左到右 一元 + - ! ~ 从右到左 乘性 * / ％ 左到右 加性 + - 左到右 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 左到右 关系 &gt; &gt;= &lt; &lt;= 左到右 相等 == != 左到右 按位与 ＆ 左到右 按位异或 ^ 左到右 按位或 丨 左到右 逻辑与 &amp;&amp; 左到右 逻辑或 丨丨 左到右 条件 ？： 从右到左 赋值 = += -= *= /= ％= &gt;&gt;= &lt;&lt;= &amp;= ^= 丨= 从右到左 逗号 ， 左到右]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础二--修饰符]]></title>
    <url>%2F2018%2F10%2F13%2FJava%E5%9F%BA%E7%A1%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Java 中主要有两类修饰符： 访问修饰符 非访问修饰符 Java 访问修饰符 访问修饰符 当前类 同一包内 子类 其他包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × public : 公开,所有类可见 protected :继承访问权限（本包中的子类非子类均可访问，不同包中的子类可以访问，不是子类不能访问） default :包访问权限（本包中的子类非子类均可访问，不同包中的类及子类均不能访问） private :私有,在同一类内可见 [注]：protected的可见性在于两点： 父类的 protected 成员是包内可见的，并且对子类可见； 若子类与父类不在同一包中，那么在子类中，子类实例可以访问其从父类继承而来的protected方法，而不能访问父类实例的protected方法。 访问控制和继承 父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。 父类中声明为 private 的方法，不能够被继承。 Java 非访问修饰符Java 中的非访问修饰符有： static 修饰符，用来修饰类方法和类变量 final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract 修饰符，用来创建抽象类和抽象方法。 synchronized 和 volatile 修饰符，主要用于线程的编程。 Static 修饰符所谓静态就是指在编译后所分配的内存会一直存在，直到程序退出内存才会释放这个空间，也就是只要程序在运行，那么这块内存就会一直存在。 静态变量： static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。 静态方法： static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 final 修饰符final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。 final 修饰符通常和 static 修饰符一起使用来创建类常量。 类中的 final 方法可以被子类继承，但是不能被子类修改。声明 final 方法的主要目的是防止该方法的内容被修改。 final 类不能被继承，没有类能够继承 final 类的任何特性。 abstract 修饰符 抽象类： 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。 一个类不能同时被 abstract 和 final 修饰[被 final 修饰后就不能被继承了]。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。 抽象类可以包含抽象方法和非抽象方法。 抽象方法： 抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。 抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 抽象方法的声明以分号结尾。 synchronized 修饰符synchronized 关键字声明的方法同一时间只能被一个线程访问。 transient 修饰符序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。 该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。 volatile 修饰符volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 一个 volatile 对象引用可能是 null。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础一--基本数据类型&类型转换]]></title>
    <url>%2F2018%2F10%2F13%2FJava%E5%9F%BA%E7%A1%80%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Java 中有两大数据类型： 内置数据类型 引用数据类型 内置数据类型Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 基本类型 大小 最小值 最大值 默认值 包装类 例子 byte 8 bit -2^7 2^7-1 0 Byte byte a = 100 short 16 bit -2^15 2^15 - 1 0 Short short s = 1000 int 32 bit -2^31 2^31 - 1 0 Integer int a = 100000 long 64 bit -2^63 2^63 -1 0L Long long a = 100000L float 32 bit IEEE754 IEEE754 0.0f Float float f1 = 234.5f double 64 bit IEEE754 IEEE754 0.0d Double double d1 = 123.4 char 16 bit \u0000 \uffff 空 Character char letter = ‘A’ boolean - - - false Boolean boolean one = true 引用类型 在 Java 中，引用类型的变量非常类似于 C/C++ 的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了 引用数据类型包括：类、接口类型、数组类型、枚举类型、注解类型，字符串型； 所有引用类型的默认值都是 null 类型转换什么是类型转换？ 整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。 转换从低级到高级 低————————————————————&gt;高 byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 数据类型转换必须满足如下规则： 不能对boolean类型进行类型转换。 不能把对象类型转换成不相关类的对象。 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。 转换过程中可能导致溢出或损失精度，例如： 12int i =128; byte b = (byte)i; 因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如： 12(int)23.7 == 23; (int)-45.89f == -45 类型转换分为： 自动类型转换 强制类型转换 自动类型转换必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。 12345678910public class ZiDongLeiZhuan&#123; public static void main(String[] args)&#123; char c1='a';//定义一个char类型 int i1 = c1;//char自动类型转换为int System.out.println("char自动类型转换为int后的值等于"+i1); char c2 = 'A';//定义一个char类型 int i2 = c2+1;//char 类型和 int 类型计算 System.out.println("char类型和int计算后的值等于"+i2); &#125;&#125; 结果为： 12char自动类型转换为int后的值等于97char类型和int计算后的值等于66 解析：c1 的值为字符 a ,查 ASCII 码表可知对应的 int 类型值为 97， A 对应值为 65，所以 i2=65+1=66。 强制类型转换将高级别类型赋值给低级别类型时，必须进行强制类型转换。 条件是转换的数据类型必须是兼容的。 格式：(type)value type是要强制类型转换后的数据类型。 小结 Java 中有两大数据类型，基本数据类型和引用数据类型。 基本数据类型在被创建时，在栈上给其划分一块内存，将数据直接存储在栈上. 引用数据类型在被创建时，首先要在栈上给其引用分配一块内存，而对象的具体信息都存储在堆上，然后由栈上面的引用指向堆中对象的地址。 简答的说小类型可自动转换为大类型，大类型转小类型需要强制转换。 箭头指向的方向表示可以自动转换，箭头的相反方向需要强制转换，虚线所指向的内容可能发生精度的丢失。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
</search>
