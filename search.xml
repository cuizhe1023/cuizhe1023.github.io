<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java基础二--修饰符]]></title>
    <url>%2F2018%2F10%2F10%2FJava%E5%9F%BA%E7%A1%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Java 中主要有两类修饰符： 访问修饰符 非访问修饰符 Java 访问修饰符 访问修饰符 当前类 同一包内 子类 其他包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × public : 公开,所有类可见 protected :继承访问权限（本包中的子类非子类均可访问，不同包中的子类可以访问，不是子类不能访问） default :包访问权限（本包中的子类非子类均可访问，不同包中的类及子类均不能访问） private :私有,在同一类内可见 [注]：protected的可见性在于两点： 父类的 protected 成员是包内可见的，并且对子类可见； 若子类与父类不在同一包中，那么在子类中，子类实例可以访问其从父类继承而来的protected方法，而不能访问父类实例的protected方法。 访问控制和继承 父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。 父类中声明为 private 的方法，不能够被继承。 Java 非访问修饰符Java 中的非访问修饰符有： static 修饰符，用来修饰类方法和类变量 final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract 修饰符，用来创建抽象类和抽象方法。 synchronized 和 volatile 修饰符，主要用于线程的编程。 Static 修饰符所谓静态就是指在编译后所分配的内存会一直存在，直到程序退出内存才会释放这个空间，也就是只要程序在运行，那么这块内存就会一直存在。 静态变量： static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。 静态方法： static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 final 修饰符final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。 final 修饰符通常和 static 修饰符一起使用来创建类常量。 类中的 final 方法可以被子类继承，但是不能被子类修改。声明 final 方法的主要目的是防止该方法的内容被修改。 final 类不能被继承，没有类能够继承 final 类的任何特性。 abstract 修饰符 抽象类： 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。 一个类不能同时被 abstract 和 final 修饰[被 final 修饰后就不能被继承了]。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。 抽象类可以包含抽象方法和非抽象方法。 抽象方法： 抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。 抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 抽象方法的声明以分号结尾。 synchronized 修饰符synchronized 关键字声明的方法同一时间只能被一个线程访问。 transient 修饰符序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。 该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。 volatile 修饰符volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 一个 volatile 对象引用可能是 null。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础一--基本数据类型&类型转换]]></title>
    <url>%2F2018%2F10%2F10%2FJava%E5%9F%BA%E7%A1%80%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Java 中有两大数据类型： 内置数据类型 引用数据类型 内置数据类型Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 基本类型 大小 最小值 最大值 默认值 包装类 例子 byte 8 bit -2^7 2^7-1 0 Byte byte a = 100 short 16 bit -2^15 2^15 - 1 0 Short short s = 1000 int 32 bit -2^31 2^31 - 1 0 Integer int a = 100000 long 64 bit -2^63 2^63 -1 0L Long long a = 100000L float 32 bit IEEE754 IEEE754 0.0f Float float f1 = 234.5f double 64 bit IEEE754 IEEE754 0.0d Double double d1 = 123.4 char 16 bit \u0000 \uffff 空 Character char letter = ‘A’ boolean - - - false Boolean boolean one = true 引用类型 在 Java 中，引用类型的变量非常类似于 C/C++ 的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了 引用数据类型包括：类、接口类型、数组类型、枚举类型、注解类型，字符串型； 所有引用类型的默认值都是 null 类型转换什么是类型转换？ 整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。 转换从低级到高级 低————————————————————&gt;高 byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 数据类型转换必须满足如下规则： 不能对boolean类型进行类型转换。 不能把对象类型转换成不相关类的对象。 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。 转换过程中可能导致溢出或损失精度，例如： 12int i =128; byte b = (byte)i; 因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如： 12(int)23.7 == 23; (int)-45.89f == -45 类型转换分为： 自动类型转换 强制类型转换 自动类型转换必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。 12345678910public class ZiDongLeiZhuan&#123; public static void main(String[] args)&#123; char c1='a';//定义一个char类型 int i1 = c1;//char自动类型转换为int System.out.println("char自动类型转换为int后的值等于"+i1); char c2 = 'A';//定义一个char类型 int i2 = c2+1;//char 类型和 int 类型计算 System.out.println("char类型和int计算后的值等于"+i2); &#125;&#125; 结果为： 12char自动类型转换为int后的值等于97char类型和int计算后的值等于66 解析：c1 的值为字符 a ,查 ASCII 码表可知对应的 int 类型值为 97， A 对应值为 65，所以 i2=65+1=66。 强制类型转换将高级别类型赋值给低级别类型时，必须进行强制类型转换。 条件是转换的数据类型必须是兼容的。 格式：(type)value type是要强制类型转换后的数据类型。 小结 Java 中有两大数据类型，基本数据类型和引用数据类型。 基本数据类型在被创建时，在栈上给其划分一块内存，将数据直接存储在栈上. 引用数据类型在被创建时，首先要在栈上给其引用分配一块内存，而对象的具体信息都存储在堆上，然后由栈上面的引用指向堆中对象的地址。 简答的说小类型可自动转换为大类型，大类型转小类型需要强制转换。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
</search>
