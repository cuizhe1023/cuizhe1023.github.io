<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java基础三--运算符]]></title>
    <url>%2F2018%2F10%2F13%2FJava%E5%9F%BA%E7%A1%80%E4%B8%89%2F</url>
    <content type="text"><![CDATA[在 Java 中运算符有一下几组 算数运算符 关系运算符 位运算符 逻辑运算符 赋值运算符 其他运算符 算数运算符算数运算符用在数学表达式中，作用和在数学中的作用一样。 在表格中 A = 10, B = 20 操作符 描述 例子 + 加法 A + B = 30 - 减法 A - B = -10 * 乘法 A * B = 200 / 除法 B / A = 2 % 取余 B % A = 0 ++ 自增 A++ 或 ++A 等于11 – 自减 B– 或者 –B 等于19 i++ 和 ++i 的区别 ++i 先进行自增操作，在进行表达式运算 i++ 先进行表达式运算，在进行自增操作 简单的来说，i++ 与 ++i 在单独使用的时候，都代表了 i = i + 1; 表达式 a = ++i; 等价于 i = i + 1;a = i; 表达式 a = i++; 等价于 a = i;i = i + 1; 关系运算符A = 10, B = 20 运算符 描述 例子 == 检查两个操作数的值是否相等，如果相等则返回true (A = B) false != 检查两个操作数的值是否相等，如果不相等则返回true (A != B) true &gt; 检查左操作数的值是否大于右操作数的值，如果是，返回true (A &gt; B) false &lt; 检查左操作数的值是否小于右操作数的值，如果是，返回true (A &lt; B) true &gt;= 检查左操作数的值是否大于或者等于右操作数的值，如果是，返回true (A &gt;= B) false &lt;= 检查左操作数的值是否小于或者等于右操作数的值，如果是，返回true (A &lt;= B) true 位运算符位运算应用于整数类型（int），长整型（long），短整型（short），字符型（char）和字节型（byte）等类型。 位运算符作用在所有的位上，并且按位运算。假设 A = 60, B = 13,则二进制表示如下 A = 0011 1100 B = 0000 1101 运算符 描述 例子 &amp; 按位与运算符，如果相对应位都是1，则结果为1，否则为0 (A &amp; B) = 0000 1100 即12 丨 按位或运算符，如果相对应位都是0，则结果为0，否则为1 (A 丨 B) = 0011 1101 即61 ^ 按位异或运算符，如果相对应位值相同，则结果为0，否则为1 (A ^ B) = 0011 0001 即49 ~ 取反运算符，按位取反运算符翻转操作数的每一位，即0变成1，1变成0 (~ A) = 1100 0011 即-61 &lt;&lt; 按位左移运算符。左操作数按位左移右操作数指定的位数 (A &lt;&lt; 2) = 1111 0000 即240 &gt;&gt; 按位右移运算符。左操作数按位右移右操作数指定的位数 (A &gt;&gt; 2) = 1111 即15 &gt;&gt;&gt; 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充 (A &gt;&gt;&gt; 2) = 00001111 即15 逻辑运算符假设 A = true, B = false 操作符 描述 例子 &amp;&amp; 逻辑与运算符。当且仅当两个操作数都为真，条件才为真。 (A &amp;&amp; B) = false 丨丨 逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 (A 丨丨 B) = true ！ 逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 ! (A &amp;&amp; B)= true 短路逻辑运算符当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。 短路逻辑与 12345678public class Main&#123; public static void main(String[] args) &#123; int a = 5; boolean b = (a &lt; 4) &amp;&amp; (a++&lt;10); System.out.println("使用短路逻辑运算符的结果为"+b); System.out.println("a的结果为"+a); &#125;&#125; 使用短路逻辑运算符的结果为falsea的结果为5 解析：该程序使用到了短路逻辑运算符(&amp;&amp;)，首先判断 a&lt;4 的结果为 false，则 b 的结果必定是 false，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。 短路逻辑或 12345678public class Main&#123; public static void main(String[] args) &#123; int a = 5; boolean b = (a &gt; 4) || (a++&lt;10); System.out.println("使用短路逻辑运算符的结果为"+b); System.out.println("a的结果为"+a); &#125;&#125; 使用短路逻辑运算符的结果为truea的结果为5 解析：该程序使用到了短路逻辑运算符(||)，首先判断 a &gt; 4 的结果为 true，则 b 的结果必定是 true，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。 赋值运算 操作符 描述 例子 = 简单的赋值运算符，将右操作数的值赋给左侧操作数 C = A + B将把A + B得到的值赋给C += 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数 C += A等价于C = C + A -= 减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数 C -= A等价于C = C - A *= 乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数 C = A等价于C = C A /= 除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数 C / = A等价于C = C / A (％)= 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 C％= A等价于C = C％A &lt;&lt; = 左移位赋值运算符 C &lt;&lt; = 2等价于C = C &lt;&lt; 2 &gt;&gt; = 右移位赋值运算符 C &gt;&gt; = 2等价于C = C &gt;&gt; 2 &amp;= 按位与赋值运算符 C＆= 2等价于C = C＆2 ^ = 按位异或赋值操作符 C ^ = 2等价于C = C ^ 2 丨= 按位或赋值操作符 C 丨 = 2等价于C = C 丨 2 其他运算符条件运算符条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。 对于条件表达式b ? x : y，先计算条件b，然后进行判断。如果b的值为true，计算x的值，运算结果为x的值；否则，计算y的值，运算结果为y的值。一个条件表达式绝不会既计算x，又计算y。条件运算符是右结合的，也就是说，从右向左分组计算。例如，a ? b : c ? d : e将按a ? b : (c ? d : e)执行。 instanceof 运算符该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。 用法：result = object instanceof class 12String name = "James";boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回 true Java 运算符优先级 类别 操作符 关联性 后缀 () [] . (点操作符) 左到右 一元 + - ! ~ 从右到左 乘性 * / ％ 左到右 加性 + - 左到右 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 左到右 关系 &gt; &gt;= &lt; &lt;= 左到右 相等 == != 左到右 按位与 ＆ 左到右 按位异或 ^ 左到右 按位或 丨 左到右 逻辑与 &amp;&amp; 左到右 逻辑或 丨丨 左到右 条件 ？： 从右到左 赋值 = += -= *= /= ％= &gt;&gt;= &lt;&lt;= &amp;= ^= 丨= 从右到左 逗号 ， 左到右]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础二--修饰符]]></title>
    <url>%2F2018%2F10%2F10%2FJava%E5%9F%BA%E7%A1%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Java 中主要有两类修饰符： 访问修饰符 非访问修饰符 Java 访问修饰符 访问修饰符 当前类 同一包内 子类 其他包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × public : 公开,所有类可见 protected :继承访问权限（本包中的子类非子类均可访问，不同包中的子类可以访问，不是子类不能访问） default :包访问权限（本包中的子类非子类均可访问，不同包中的类及子类均不能访问） private :私有,在同一类内可见 [注]：protected的可见性在于两点： 父类的 protected 成员是包内可见的，并且对子类可见； 若子类与父类不在同一包中，那么在子类中，子类实例可以访问其从父类继承而来的protected方法，而不能访问父类实例的protected方法。 访问控制和继承 父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。 父类中声明为 private 的方法，不能够被继承。 Java 非访问修饰符Java 中的非访问修饰符有： static 修饰符，用来修饰类方法和类变量 final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract 修饰符，用来创建抽象类和抽象方法。 synchronized 和 volatile 修饰符，主要用于线程的编程。 Static 修饰符所谓静态就是指在编译后所分配的内存会一直存在，直到程序退出内存才会释放这个空间，也就是只要程序在运行，那么这块内存就会一直存在。 静态变量： static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。 静态方法： static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 final 修饰符final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。 final 修饰符通常和 static 修饰符一起使用来创建类常量。 类中的 final 方法可以被子类继承，但是不能被子类修改。声明 final 方法的主要目的是防止该方法的内容被修改。 final 类不能被继承，没有类能够继承 final 类的任何特性。 abstract 修饰符 抽象类： 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。 一个类不能同时被 abstract 和 final 修饰[被 final 修饰后就不能被继承了]。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。 抽象类可以包含抽象方法和非抽象方法。 抽象方法： 抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。 抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 抽象方法的声明以分号结尾。 synchronized 修饰符synchronized 关键字声明的方法同一时间只能被一个线程访问。 transient 修饰符序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。 该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。 volatile 修饰符volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 一个 volatile 对象引用可能是 null。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础一--基本数据类型&类型转换]]></title>
    <url>%2F2018%2F10%2F10%2FJava%E5%9F%BA%E7%A1%80%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Java 中有两大数据类型： 内置数据类型 引用数据类型 内置数据类型Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 基本类型 大小 最小值 最大值 默认值 包装类 例子 byte 8 bit -2^7 2^7-1 0 Byte byte a = 100 short 16 bit -2^15 2^15 - 1 0 Short short s = 1000 int 32 bit -2^31 2^31 - 1 0 Integer int a = 100000 long 64 bit -2^63 2^63 -1 0L Long long a = 100000L float 32 bit IEEE754 IEEE754 0.0f Float float f1 = 234.5f double 64 bit IEEE754 IEEE754 0.0d Double double d1 = 123.4 char 16 bit \u0000 \uffff 空 Character char letter = ‘A’ boolean - - - false Boolean boolean one = true 引用类型 在 Java 中，引用类型的变量非常类似于 C/C++ 的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了 引用数据类型包括：类、接口类型、数组类型、枚举类型、注解类型，字符串型； 所有引用类型的默认值都是 null 类型转换什么是类型转换？ 整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。 转换从低级到高级 低————————————————————&gt;高 byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 数据类型转换必须满足如下规则： 不能对boolean类型进行类型转换。 不能把对象类型转换成不相关类的对象。 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。 转换过程中可能导致溢出或损失精度，例如： 12int i =128; byte b = (byte)i; 因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如： 12(int)23.7 == 23; (int)-45.89f == -45 类型转换分为： 自动类型转换 强制类型转换 自动类型转换必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。 12345678910public class ZiDongLeiZhuan&#123; public static void main(String[] args)&#123; char c1='a';//定义一个char类型 int i1 = c1;//char自动类型转换为int System.out.println("char自动类型转换为int后的值等于"+i1); char c2 = 'A';//定义一个char类型 int i2 = c2+1;//char 类型和 int 类型计算 System.out.println("char类型和int计算后的值等于"+i2); &#125;&#125; 结果为： 12char自动类型转换为int后的值等于97char类型和int计算后的值等于66 解析：c1 的值为字符 a ,查 ASCII 码表可知对应的 int 类型值为 97， A 对应值为 65，所以 i2=65+1=66。 强制类型转换将高级别类型赋值给低级别类型时，必须进行强制类型转换。 条件是转换的数据类型必须是兼容的。 格式：(type)value type是要强制类型转换后的数据类型。 小结 Java 中有两大数据类型，基本数据类型和引用数据类型。 基本数据类型在被创建时，在栈上给其划分一块内存，将数据直接存储在栈上. 引用数据类型在被创建时，首先要在栈上给其引用分配一块内存，而对象的具体信息都存储在堆上，然后由栈上面的引用指向堆中对象的地址。 简答的说小类型可自动转换为大类型，大类型转小类型需要强制转换。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
</search>
