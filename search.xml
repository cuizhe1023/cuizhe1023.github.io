<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java基础三--运算符]]></title>
    <url>%2F2018%2F10%2F13%2FJava%E5%9F%BA%E7%A1%80%E4%B8%89%2F</url>
    <content type="text"><![CDATA[在 Java 中运算符有一下几组 算数运算符 关系运算符 位运算符 逻辑运算符 赋值运算符 其他运算符 算数运算符算数运算符用在数学表达式中，作用和在数学中的作用一样。 在表格中 A = 10, B = 20 操作符 描述 例子 + 加法 A + B = 30 - 减法 A - B = -10 * 乘法 A * B = 200 / 除法 B / A = 2 % 取余 B % A = 0 ++ 自增 A++ 或 ++A 等于11 – 自减 B– 或者 –B 等于19 i++ 和 ++i 的区别 ++i 先进行自增操作，在进行表达式运算 i++ 先进行表达式运算，在进行自增操作 简单的来说，i++ 与 ++i 在单独使用的时候，都代表了 i = i + 1; 表达式 a = ++i; 等价于 i = i + 1;a = i; 表达式 a = i++; 等价于 a = i;i = i + 1; 关系运算符A = 10, B = 20 运算符 描述 例子 == 检查两个操作数的值是否相等，如果相等则返回true (A = B) false != 检查两个操作数的值是否相等，如果不相等则返回true (A != B) true &gt; 检查左操作数的值是否大于右操作数的值，如果是，返回true (A &gt; B) false &lt; 检查左操作数的值是否小于右操作数的值，如果是，返回true (A &lt; B) true &gt;= 检查左操作数的值是否大于或者等于右操作数的值，如果是，返回true (A &gt;= B) false &lt;= 检查左操作数的值是否小于或者等于右操作数的值，如果是，返回true (A &lt;= B) true 位运算符位运算应用于整数类型（int），长整型（long），短整型（short），字符型（char）和字节型（byte）等类型。 位运算符作用在所有的位上，并且按位运算。假设 A = 60, B = 13,则二进制表示如下 A = 0011 1100 B = 0000 1101 运算符 描述 例子 &amp; 按位与运算符，如果相对应位都是1，则结果为1，否则为0 (A &amp; B) = 0000 1100 即12 丨 按位或运算符，如果相对应位都是0，则结果为0，否则为1 (A 丨 B) = 0011 1101 即61 ^ 按位异或运算符，如果相对应位值相同，则结果为0，否则为1 (A ^ B) = 0011 0001 即49 ~ 取反运算符，按位取反运算符翻转操作数的每一位，即0变成1，1变成0 (~ A) = 1100 0011 即-61 &lt;&lt; 按位左移运算符。左操作数按位左移右操作数指定的位数 (A &lt;&lt; 2) = 1111 0000 即240 &gt;&gt; 按位右移运算符。左操作数按位右移右操作数指定的位数 (A &gt;&gt; 2) = 1111 即15 &gt;&gt;&gt; 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充 (A &gt;&gt;&gt; 2) = 00001111 即15 逻辑运算符假设 A = true, B = false 操作符 描述 例子 &amp;&amp; 逻辑与运算符。当且仅当两个操作数都为真，条件才为真。 (A &amp;&amp; B) = false 丨丨 逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 (A 丨丨 B) = true ！ 逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 ! (A &amp;&amp; B)= true 短路逻辑运算符当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。 短路逻辑与 12345678public class Main&#123; public static void main(String[] args) &#123; int a = 5; boolean b = (a &lt; 4) &amp;&amp; (a++&lt;10); System.out.println("使用短路逻辑运算符的结果为"+b); System.out.println("a的结果为"+a); &#125;&#125; 使用短路逻辑运算符的结果为falsea的结果为5 解析：该程序使用到了短路逻辑运算符(&amp;&amp;)，首先判断 a&lt;4 的结果为 false，则 b 的结果必定是 false，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。 短路逻辑或 12345678public class Main&#123; public static void main(String[] args) &#123; int a = 5; boolean b = (a &gt; 4) || (a++&lt;10); System.out.println("使用短路逻辑运算符的结果为"+b); System.out.println("a的结果为"+a); &#125;&#125; 使用短路逻辑运算符的结果为truea的结果为5 解析：该程序使用到了短路逻辑运算符(||)，首先判断 a &gt; 4 的结果为 true，则 b 的结果必定是 true，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。 赋值运算 操作符 描述 例子 = 简单的赋值运算符，将右操作数的值赋给左侧操作数 C = A + B将把A + B得到的值赋给C += 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数 C += A等价于C = C + A -= 减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数 C -= A等价于C = C - A *= 乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数 C = A等价于C = C A /= 除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数 C / = A等价于C = C / A (％)= 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 C％= A等价于C = C％A &lt;&lt; = 左移位赋值运算符 C &lt;&lt; = 2等价于C = C &lt;&lt; 2 &gt;&gt; = 右移位赋值运算符 C &gt;&gt; = 2等价于C = C &gt;&gt; 2 &amp;= 按位与赋值运算符 C＆= 2等价于C = C＆2 ^ = 按位异或赋值操作符 C ^ = 2等价于C = C ^ 2 丨= 按位或赋值操作符 C 丨 = 2等价于C = C 丨 2 其他运算符条件运算符条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。 对于条件表达式b ? x : y，先计算条件b，然后进行判断。如果b的值为true，计算x的值，运算结果为x的值；否则，计算y的值，运算结果为y的值。一个条件表达式绝不会既计算x，又计算y。条件运算符是右结合的，也就是说，从右向左分组计算。例如，a ? b : c ? d : e将按a ? b : (c ? d : e)执行。 instanceof 运算符该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。 用法：result = object instanceof class 12String name = "James";boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回 true Java 运算符优先级 类别 操作符 关联性 后缀 () [] . (点操作符) 左到右 一元 + - ! ~ 从右到左 乘性 * / ％ 左到右 加性 + - 左到右 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 左到右 关系 &gt; &gt;= &lt; &lt;= 左到右 相等 == != 左到右 按位与 ＆ 左到右 按位异或 ^ 左到右 按位或 丨 左到右 逻辑与 &amp;&amp; 左到右 逻辑或 丨丨 左到右 条件 ？： 从右到左 赋值 = += -= *= /= ％= &gt;&gt;= &lt;&lt;= &amp;= ^= 丨= 从右到左 逗号 ， 左到右]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础二--修饰符]]></title>
    <url>%2F2018%2F10%2F10%2FJava%E5%9F%BA%E7%A1%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Java 中主要有两类修饰符： 访问修饰符 非访问修饰符 Java 访问修饰符 访问修饰符 当前类 同一包内 子类 其他包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × public : 公开,所有类可见 protected :继承访问权限（本包中的子类非子类均可访问，不同包中的子类可以访问，不是子类不能访问） default :包访问权限（本包中的子类非子类均可访问，不同包中的类及子类均不能访问） private :私有,在同一类内可见 [注]：protected的可见性在于两点： 父类的 protected 成员是包内可见的，并且对子类可见； 若子类与父类不在同一包中，那么在子类中，子类实例可以访问其从父类继承而来的protected方法，而不能访问父类实例的protected方法。 访问控制和继承 父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。 父类中声明为 private 的方法，不能够被继承。 Java 非访问修饰符Java 中的非访问修饰符有： static 修饰符，用来修饰类方法和类变量 final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract 修饰符，用来创建抽象类和抽象方法。 synchronized 和 volatile 修饰符，主要用于线程的编程。 Static 修饰符所谓静态就是指在编译后所分配的内存会一直存在，直到程序退出内存才会释放这个空间，也就是只要程序在运行，那么这块内存就会一直存在。 静态变量： static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。 静态方法： static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 final 修饰符final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。 final 修饰符通常和 static 修饰符一起使用来创建类常量。 类中的 final 方法可以被子类继承，但是不能被子类修改。声明 final 方法的主要目的是防止该方法的内容被修改。 final 类不能被继承，没有类能够继承 final 类的任何特性。 abstract 修饰符 抽象类： 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。 一个类不能同时被 abstract 和 final 修饰[被 final 修饰后就不能被继承了]。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。 抽象类可以包含抽象方法和非抽象方法。 抽象方法： 抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。 抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 抽象方法的声明以分号结尾。 synchronized 修饰符synchronized 关键字声明的方法同一时间只能被一个线程访问。 transient 修饰符序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。 该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。 volatile 修饰符volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 一个 volatile 对象引用可能是 null。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>修饰符</tag>
      </tags>
  </entry>
</search>
