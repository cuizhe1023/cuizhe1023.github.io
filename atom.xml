<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CuiZhe&#39;s Blog</title>
  
  <subtitle>CuiZhe&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cuizhe1023.github.io/"/>
  <updated>2018-10-13T10:08:23.510Z</updated>
  <id>https://cuizhe1023.github.io/</id>
  
  <author>
    <name>Cui Zhe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础一--基本数据类型&amp;类型转换</title>
    <link href="https://cuizhe1023.github.io/2018/10/13/Java%E5%9F%BA%E7%A1%80%E4%B8%80/"/>
    <id>https://cuizhe1023.github.io/2018/10/13/Java基础一/</id>
    <published>2018-10-13T10:08:00.335Z</published>
    <updated>2018-10-13T10:08:23.510Z</updated>
    
    <content type="html"><![CDATA[<p>Java 中有两大数据类型：</p><ul><li><strong>内置数据类型</strong></li><li><strong>引用数据类型</strong></li></ul><a id="more"></a><h4 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h4><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p><table><thead><tr><th style="text-align:center">基本类型</th><th style="text-align:center">大小</th><th style="text-align:center">最小值</th><th style="text-align:center">最大值</th><th style="text-align:center">默认值</th><th style="text-align:center">包装类</th><th style="text-align:center">例子</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">8 bit</td><td style="text-align:center">-2^7</td><td style="text-align:center">2^7-1</td><td style="text-align:center">0</td><td style="text-align:center">Byte</td><td style="text-align:center">byte a = 100</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">16 bit</td><td style="text-align:center">-2^15</td><td style="text-align:center">2^15 - 1</td><td style="text-align:center">0</td><td style="text-align:center">Short</td><td style="text-align:center">short s = 1000</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">32 bit</td><td style="text-align:center">-2^31</td><td style="text-align:center">2^31 - 1</td><td style="text-align:center">0</td><td style="text-align:center">Integer</td><td style="text-align:center">int a = 100000</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">64 bit</td><td style="text-align:center">-2^63</td><td style="text-align:center">2^63 -1</td><td style="text-align:center">0L</td><td style="text-align:center">Long</td><td style="text-align:center">long a = 100000L</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">32 bit</td><td style="text-align:center">IEEE754</td><td style="text-align:center">IEEE754</td><td style="text-align:center">0.0f</td><td style="text-align:center">Float</td><td style="text-align:center">float f1 = 234.5f</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">64 bit</td><td style="text-align:center">IEEE754</td><td style="text-align:center">IEEE754</td><td style="text-align:center">0.0d</td><td style="text-align:center">Double</td><td style="text-align:center">double d1 = 123.4</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">16 bit</td><td style="text-align:center">\u0000</td><td style="text-align:center">\uffff</td><td style="text-align:center">空</td><td style="text-align:center">Character</td><td style="text-align:center">char letter = ‘A’</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">false</td><td style="text-align:center">Boolean</td><td style="text-align:center">boolean one = true</td></tr></tbody></table><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul><li>在 Java 中，引用类型的变量非常类似于 C/C++ 的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了</li><li>引用数据类型包括：类、接口类型、数组类型、枚举类型、注解类型，字符串型；</li><li>所有引用类型的默认值都是 null</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>什么是类型转换？</p><p><strong>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></p><p>转换从低级到高级</p><blockquote><p>低————————————————————&gt;高</p><p>byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double </p></blockquote><p>数据类型转换必须满足如下规则：</p><ul><li><p>不能对boolean类型进行类型转换。</p></li><li><p>不能把对象类型转换成不相关类的对象。</p></li><li><p>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p></li><li><p>转换过程中可能导致溢出或损失精度，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">128</span>;   </span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;</span><br></pre></td></tr></table></figure><p>因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p></li><li><p>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span>)<span class="number">23.7</span> == <span class="number">23</span>;        </span><br><span class="line">(<span class="keyword">int</span>)-<span class="number">45.89f</span> == -<span class="number">45</span></span><br></pre></td></tr></table></figure></li></ul><p>类型转换分为：</p><ul><li><strong>自动类型转换</strong></li><li><strong>强制类型转换</strong></li></ul><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZiDongLeiZhuan</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">            <span class="keyword">char</span> c1=<span class="string">'a'</span>;<span class="comment">//定义一个char类型</span></span><br><span class="line">            <span class="keyword">int</span> i1 = c1;<span class="comment">//char自动类型转换为int</span></span><br><span class="line">            System.out.println(<span class="string">"char自动类型转换为int后的值等于"</span>+i1);</span><br><span class="line">            <span class="keyword">char</span> c2 = <span class="string">'A'</span>;<span class="comment">//定义一个char类型</span></span><br><span class="line">            <span class="keyword">int</span> i2 = c2+<span class="number">1</span>;<span class="comment">//char 类型和 int 类型计算</span></span><br><span class="line">            System.out.println(<span class="string">"char类型和int计算后的值等于"</span>+i2);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>自动类型转换为<span class="keyword">int</span>后的值等于<span class="number">97</span></span><br><span class="line"><span class="keyword">char</span>类型和<span class="keyword">int</span>计算后的值等于<span class="number">66</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong>：c1 的值为字符 <strong>a</strong> ,查 ASCII 码表可知对应的 int 类型值为 97， A 对应值为 65，所以 i2=65+1=66。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>将高级别类型赋值给低级别类型时，必须进行强制类型转换。</p><ul><li>条件是转换的数据类型必须是兼容的。</li><li>格式：(type)value type是要强制类型转换后的数据类型。</li></ul><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p>Java 中有两大数据类型，基本数据类型和引用数据类型。</p><ul><li>基本数据类型在被创建时，在栈上给其划分一块内存，将<strong>数据直接存储在栈</strong>上.</li><li>引用数据类型在被创建时，首先要在栈上给其引用分配一块内存，而<strong>对象的具体信息都存储在堆</strong>上，然后由栈上面的引用指向堆中对象的地址。</li></ul></li><li><p>简答的说小类型可<strong>自动转换</strong>为大类型，大类型转小类型需要<strong>强制转换</strong>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 中有两大数据类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内置数据类型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引用数据类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数据类型" scheme="https://cuizhe1023.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java基础三--运算符</title>
    <link href="https://cuizhe1023.github.io/2018/10/13/Java%E5%9F%BA%E7%A1%80%E4%B8%89/"/>
    <id>https://cuizhe1023.github.io/2018/10/13/Java基础三/</id>
    <published>2018-10-13T02:17:31.631Z</published>
    <updated>2018-10-13T10:03:17.404Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 中运算符有一下几组</p><ul><li>算数运算符</li><li>关系运算符</li><li>位运算符</li><li>逻辑运算符</li><li>赋值运算符</li><li>其他运算符</li></ul><!--mroe--><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p>算数运算符用在数学表达式中，作用和在数学中的作用一样。</p><p>在表格中 A = 10, B = 20</p><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">描述</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">+</td><td style="text-align:left">加法</td><td style="text-align:left">A + B = 30</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">减法</td><td style="text-align:left">A - B = -10</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">乘法</td><td style="text-align:left">A * B = 200</td></tr><tr><td style="text-align:left">/</td><td style="text-align:left">除法</td><td style="text-align:left">B / A = 2</td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">取余</td><td style="text-align:left">B % A = 0</td></tr><tr><td style="text-align:left">++</td><td style="text-align:left">自增</td><td style="text-align:left">A++ 或 ++A 等于11</td></tr><tr><td style="text-align:left">–</td><td style="text-align:left">自减</td><td style="text-align:left">B– 或者 –B 等于19</td></tr></tbody></table><h3 id="i-和-i-的区别"><a href="#i-和-i-的区别" class="headerlink" title="i++ 和 ++i 的区别"></a>i++ 和 ++i 的区别</h3><ul><li>++i 先进行自增操作，在进行表达式运算</li><li>i++ 先进行表达式运算，在进行自增操作</li></ul><p>简单的来说，i++ 与 ++i 在单独使用的时候，都代表了 i = i + 1;</p><p>表达式 a = ++i; 等价于 i = i + 1;a = i;</p><p>表达式 a = i++; 等价于 a = i;i = i + 1;</p><hr><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>A = 10, B = 20</p><table><thead><tr><th style="text-align:left">运算符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td style="text-align:left">==</td><td>检查两个操作数的值是否相等，如果相等则返回true</td><td>(A = B) false</td></tr><tr><td style="text-align:left">!=</td><td>检查两个操作数的值是否相等，如果不相等则返回true</td><td>(A != B) true</td></tr><tr><td style="text-align:left">&gt;</td><td>检查左操作数的值是否大于右操作数的值，如果是，返回true</td><td>(A &gt; B) false</td></tr><tr><td style="text-align:left">&lt;</td><td>检查左操作数的值是否小于右操作数的值，如果是，返回true</td><td>(A &lt; B) true</td></tr><tr><td style="text-align:left">&gt;=</td><td>检查左操作数的值是否大于或者等于右操作数的值，如果是，返回true</td><td>(A &gt;= B) false</td></tr><tr><td style="text-align:left">&lt;=</td><td>检查左操作数的值是否小于或者等于右操作数的值，如果是，返回true</td><td>(A &lt;= B) true</td></tr></tbody></table><hr><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算应用于整数类型（int），长整型（long），短整型（short），字符型（char）和字节型（byte）等类型。</p><p>位运算符作用在所有的位上，并且按位运算。假设 A = 60, B = 13,则二进制表示如下</p><blockquote><p>A = 0011 1100</p><p>B = 0000 1101</p></blockquote><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与运算符，如果相对应位都是1，则结果为1，否则为0</td><td>(A &amp; B) = 0000 1100 即12</td></tr><tr><td>丨</td><td>按位或运算符，如果相对应位都是0，则结果为0，否则为1</td><td>(A 丨 B) = 0011 1101 即61</td></tr><tr><td>^</td><td>按位异或运算符，如果相对应位值相同，则结果为0，否则为1</td><td>(A ^ B) = 0011 0001 即49</td></tr><tr><td>~</td><td>取反运算符，按位取反运算符翻转操作数的每一位，即0变成1，1变成0</td><td>(~ A) = 1100 0011 即-61</td></tr><tr><td>&lt;&lt;</td><td>按位左移运算符。左操作数按位左移右操作数指定的位数</td><td>(A &lt;&lt; 2) = 1111 0000 即240</td></tr><tr><td>&gt;&gt;</td><td>按位右移运算符。左操作数按位右移右操作数指定的位数</td><td>(A &gt;&gt; 2) = 1111 即15</td></tr><tr><td>&gt;&gt;&gt;</td><td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充</td><td>(A &gt;&gt;&gt; 2) = 00001111 即15</td></tr></tbody></table><hr><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>假设 A = true, B = false</p><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td><td>(A &amp;&amp; B) = false</td></tr><tr><td>丨丨</td><td>逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td><td>(A 丨丨 B) = true</td></tr><tr><td>！</td><td>逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td><td>! (A &amp;&amp; B)=  true</td></tr></tbody></table><h3 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h3><p>当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。</p><ul><li>短路逻辑与</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b = (a &lt; <span class="number">4</span>) &amp;&amp; (a++&lt;<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"使用短路逻辑运算符的结果为"</span>+b);</span><br><span class="line">        System.out.println(<span class="string">"a的结果为"</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用短路逻辑运算符的结果为false<br>a的结果为5</p></blockquote><p><strong>解析</strong>：该程序使用到了短路逻辑运算符(&amp;&amp;)，首先判断 a&lt;4 的结果为 false，则 b 的结果必定是 false，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。</p><ul><li>短路逻辑或</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b = (a &gt; <span class="number">4</span>) || (a++&lt;<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"使用短路逻辑运算符的结果为"</span>+b);</span><br><span class="line">        System.out.println(<span class="string">"a的结果为"</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用短路逻辑运算符的结果为true<br>a的结果为5</p></blockquote><p><strong>解析</strong>：该程序使用到了短路逻辑运算符(||)，首先判断 a &gt; 4 的结果为 true，则 b 的结果必定是 true，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。</p><hr><h2 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h2><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符，将右操作数的值赋给左侧操作数</td><td>C = A + B将把A + B得到的值赋给C</td></tr><tr><td>+=</td><td>加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td><td>C += A等价于C = C + A</td></tr><tr><td>-=</td><td>减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td><td>C -= A等价于C = C -  A</td></tr><tr><td>*=</td><td>乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td><td>C <em>= A等价于C = C </em> A</td></tr><tr><td>/=</td><td>除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td><td>C / = A等价于C = C / A</td></tr><tr><td>(％)=</td><td>取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td><td>C％= A等价于C = C％A</td></tr><tr><td>&lt;&lt; =</td><td>左移位赋值运算符</td><td>C &lt;&lt; = 2等价于C = C &lt;&lt; 2</td></tr><tr><td>&gt;&gt; =</td><td>右移位赋值运算符</td><td>C &gt;&gt; = 2等价于C = C &gt;&gt; 2</td></tr><tr><td>&amp;=</td><td>按位与赋值运算符</td><td>C＆= 2等价于C = C＆2</td></tr><tr><td>^ =</td><td>按位异或赋值操作符</td><td>C ^ = 2等价于C = C ^ 2</td></tr><tr><td>丨=</td><td>按位或赋值操作符</td><td>C 丨 = 2等价于C = C 丨 2</td></tr></tbody></table><hr><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><p>条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p><p>对于条件表达式b ? x : y，先计算条件b，然后进行判断。如果b的值为true，计算x的值，运算结果为x的值；否则，计算y的值，运算结果为y的值。一个条件表达式绝不会既计算x，又计算y。条件运算符是右结合的，也就是说，从右向左分组计算。例如，a ? b : c ? d : e将按a ? b : (c ? d : e)执行。</p><h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p><p>用法：<br>result = object instanceof class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">"James"</span>;</span><br><span class="line"><span class="keyword">boolean</span> result = name <span class="keyword">instanceof</span> String; <span class="comment">// 由于 name 是 String 类型，所以返回 true</span></span><br></pre></td></tr></table></figure><hr><h2 id="Java-运算符优先级"><a href="#Java-运算符优先级" class="headerlink" title="Java 运算符优先级"></a>Java 运算符优先级</h2><table><thead><tr><th>类别</th><th>操作符</th><th>关联性</th></tr></thead><tbody><tr><td>后缀</td><td>() [] . (点操作符)</td><td>左到右</td></tr><tr><td>一元</td><td>+ - ! ~</td><td>从右到左</td></tr><tr><td>乘性</td><td>* / ％</td><td>左到右</td></tr><tr><td>加性</td><td>+ -</td><td>左到右</td></tr><tr><td>移位</td><td>&gt;&gt; &gt;&gt;&gt;  &lt;&lt;</td><td>左到右</td></tr><tr><td>关系</td><td>&gt; &gt;= &lt; &lt;=</td><td>左到右</td></tr><tr><td>相等</td><td>==  !=</td><td>左到右</td></tr><tr><td>按位与</td><td>＆</td><td>左到右</td></tr><tr><td>按位异或</td><td>^</td><td>左到右</td></tr><tr><td>按位或</td><td>丨</td><td>左到右</td></tr><tr><td>逻辑与</td><td>&amp;&amp;</td><td>左到右</td></tr><tr><td>逻辑或</td><td>丨丨</td><td>左到右</td></tr><tr><td>条件</td><td>？：</td><td>从右到左</td></tr><tr><td>赋值</td><td>= += -= *= /= ％= &gt;&gt;= &lt;&lt;= &amp;= ^= 丨=</td><td>从右到左</td></tr><tr><td>逗号</td><td>，</td><td>左到右</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Java 中运算符有一下几组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算数运算符&lt;/li&gt;
&lt;li&gt;关系运算符&lt;/li&gt;
&lt;li&gt;位运算符&lt;/li&gt;
&lt;li&gt;逻辑运算符&lt;/li&gt;
&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;li&gt;其他运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;!--mroe--&gt;
&lt;h2 
      
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="运算符" scheme="https://cuizhe1023.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>Java基础二--修饰符</title>
    <link href="https://cuizhe1023.github.io/2018/10/10/Java%E5%9F%BA%E7%A1%80%E4%BA%8C/"/>
    <id>https://cuizhe1023.github.io/2018/10/10/Java基础二/</id>
    <published>2018-10-10T14:24:24.871Z</published>
    <updated>2018-10-11T01:38:06.942Z</updated>
    
    <content type="html"><![CDATA[<p>Java 中主要有两类修饰符：</p><ul><li><strong>访问修饰符</strong></li><li><strong>非访问修饰符</strong></li></ul><a id="more"></a><h2 id="Java-访问修饰符"><a href="#Java-访问修饰符" class="headerlink" title="Java 访问修饰符"></a>Java 访问修饰符</h2><table><thead><tr><th style="text-align:center">访问修饰符</th><th style="text-align:center">当前类</th><th style="text-align:center">同一包内</th><th style="text-align:center">子类</th><th style="text-align:center">其他包</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><p>public : 公开,所有类可见</p><p>protected :继承访问权限（本包中的子类非子类均可访问，不同包中的子类可以访问，不是子类不能访问）</p><p>default :包访问权限（本包中的子类非子类均可访问，不同包中的类及子类均不能访问）</p><p>private :私有,在同一类内可见</p><p><strong>[注]</strong>：protected的可见性在于两点：</p><ul><li>父类的 protected 成员是包内可见的，并且对子类可见；</li><li>若子类与父类不在同一包中，那么在子类中，子类实例可以访问其从父类继承而来的protected方法，而不能访问父类实例的protected方法。</li></ul><h3 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h3><ul><li>父类中声明为 public 的方法在子类中也必须为 public。</li><li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li><li>父类中声明为 private 的方法，不能够被继承。</li></ul><hr><h2 id="Java-非访问修饰符"><a href="#Java-非访问修饰符" class="headerlink" title="Java 非访问修饰符"></a>Java 非访问修饰符</h2><p>Java 中的非访问修饰符有：</p><ul><li>static 修饰符，用来修饰类方法和类变量</li><li>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</li><li>abstract 修饰符，用来创建抽象类和抽象方法。</li><li>synchronized 和 volatile 修饰符，主要用于线程的编程。</li></ul><h3 id="Static-修饰符"><a href="#Static-修饰符" class="headerlink" title="Static 修饰符"></a>Static 修饰符</h3><p>所谓静态就是指在编译后所分配的内存会一直存在，直到程序退出内存才会释放这个空间，也就是只要程序在运行，那么这块内存就会一直存在。</p><ul><li><p><strong>静态变量：</strong></p><p>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</p></li><li><p><strong>静态方法：</strong></p><p>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p></li></ul><h3 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h3><p>final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</p><ul><li>final 修饰符通常和 static 修饰符一起使用来创建类常量。</li><li>类中的 final 方法可以被子类继承，但是不能被子类修改。声明 final 方法的主要目的是防止该方法的内容被修改。</li><li>final 类不能被继承，没有类能够继承 final 类的任何特性。</li></ul><h3 id="abstract-修饰符"><a href="#abstract-修饰符" class="headerlink" title="abstract 修饰符"></a>abstract 修饰符</h3><ul><li><p><strong>抽象类：</strong></p><p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</p><p>一个类不能同时被 abstract 和 final 修饰<strong>[被 final 修饰后就不能被继承了]</strong>。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p><p>抽象类可以包含抽象方法和非抽象方法。</p></li><li><p><strong>抽象方法：</strong></p><p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。</p><p>抽象方法不能被声明成 final 和 static。</p><p>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p><p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p><p>抽象方法的声明以分号结尾。</p></li></ul><h3 id="synchronized-修饰符"><a href="#synchronized-修饰符" class="headerlink" title="synchronized 修饰符"></a>synchronized 修饰符</h3><p>synchronized 关键字声明的方法同一时间只能被一个线程访问。</p><h3 id="transient-修饰符"><a href="#transient-修饰符" class="headerlink" title="transient 修饰符"></a>transient 修饰符</h3><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。</p><p>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</p><h3 id="volatile-修饰符"><a href="#volatile-修饰符" class="headerlink" title="volatile 修饰符"></a>volatile 修饰符</h3><p>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p><p>一个 volatile 对象引用可能是 null。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 中主要有两类修饰符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;访问修饰符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非访问修饰符&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="修饰符" scheme="https://cuizhe1023.github.io/tags/%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    
  </entry>
  
</feed>
