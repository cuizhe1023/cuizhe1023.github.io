<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CuiZhe&#39;s Blog</title>
  
  <subtitle>CuiZhe&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cuizhe1023.github.io/"/>
  <updated>2018-10-11T01:38:06.942Z</updated>
  <id>https://cuizhe1023.github.io/</id>
  
  <author>
    <name>Cui Zhe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础二--修饰符</title>
    <link href="https://cuizhe1023.github.io/2018/10/10/Java%E5%9F%BA%E7%A1%80%E4%BA%8C/"/>
    <id>https://cuizhe1023.github.io/2018/10/10/Java基础二/</id>
    <published>2018-10-10T14:24:24.871Z</published>
    <updated>2018-10-11T01:38:06.942Z</updated>
    
    <content type="html"><![CDATA[<p>Java 中主要有两类修饰符：</p><ul><li><strong>访问修饰符</strong></li><li><strong>非访问修饰符</strong></li></ul><a id="more"></a><h2 id="Java-访问修饰符"><a href="#Java-访问修饰符" class="headerlink" title="Java 访问修饰符"></a>Java 访问修饰符</h2><table><thead><tr><th style="text-align:center">访问修饰符</th><th style="text-align:center">当前类</th><th style="text-align:center">同一包内</th><th style="text-align:center">子类</th><th style="text-align:center">其他包</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><p>public : 公开,所有类可见</p><p>protected :继承访问权限（本包中的子类非子类均可访问，不同包中的子类可以访问，不是子类不能访问）</p><p>default :包访问权限（本包中的子类非子类均可访问，不同包中的类及子类均不能访问）</p><p>private :私有,在同一类内可见</p><p><strong>[注]</strong>：protected的可见性在于两点：</p><ul><li>父类的 protected 成员是包内可见的，并且对子类可见；</li><li>若子类与父类不在同一包中，那么在子类中，子类实例可以访问其从父类继承而来的protected方法，而不能访问父类实例的protected方法。</li></ul><h3 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h3><ul><li>父类中声明为 public 的方法在子类中也必须为 public。</li><li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li><li>父类中声明为 private 的方法，不能够被继承。</li></ul><hr><h2 id="Java-非访问修饰符"><a href="#Java-非访问修饰符" class="headerlink" title="Java 非访问修饰符"></a>Java 非访问修饰符</h2><p>Java 中的非访问修饰符有：</p><ul><li>static 修饰符，用来修饰类方法和类变量</li><li>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</li><li>abstract 修饰符，用来创建抽象类和抽象方法。</li><li>synchronized 和 volatile 修饰符，主要用于线程的编程。</li></ul><h3 id="Static-修饰符"><a href="#Static-修饰符" class="headerlink" title="Static 修饰符"></a>Static 修饰符</h3><p>所谓静态就是指在编译后所分配的内存会一直存在，直到程序退出内存才会释放这个空间，也就是只要程序在运行，那么这块内存就会一直存在。</p><ul><li><p><strong>静态变量：</strong></p><p>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</p></li><li><p><strong>静态方法：</strong></p><p>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p></li></ul><h3 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h3><p>final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</p><ul><li>final 修饰符通常和 static 修饰符一起使用来创建类常量。</li><li>类中的 final 方法可以被子类继承，但是不能被子类修改。声明 final 方法的主要目的是防止该方法的内容被修改。</li><li>final 类不能被继承，没有类能够继承 final 类的任何特性。</li></ul><h3 id="abstract-修饰符"><a href="#abstract-修饰符" class="headerlink" title="abstract 修饰符"></a>abstract 修饰符</h3><ul><li><p><strong>抽象类：</strong></p><p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</p><p>一个类不能同时被 abstract 和 final 修饰<strong>[被 final 修饰后就不能被继承了]</strong>。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p><p>抽象类可以包含抽象方法和非抽象方法。</p></li><li><p><strong>抽象方法：</strong></p><p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。</p><p>抽象方法不能被声明成 final 和 static。</p><p>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p><p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p><p>抽象方法的声明以分号结尾。</p></li></ul><h3 id="synchronized-修饰符"><a href="#synchronized-修饰符" class="headerlink" title="synchronized 修饰符"></a>synchronized 修饰符</h3><p>synchronized 关键字声明的方法同一时间只能被一个线程访问。</p><h3 id="transient-修饰符"><a href="#transient-修饰符" class="headerlink" title="transient 修饰符"></a>transient 修饰符</h3><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。</p><p>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</p><h3 id="volatile-修饰符"><a href="#volatile-修饰符" class="headerlink" title="volatile 修饰符"></a>volatile 修饰符</h3><p>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p><p>一个 volatile 对象引用可能是 null。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 中主要有两类修饰符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;访问修饰符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非访问修饰符&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="修饰符" scheme="https://cuizhe1023.github.io/tags/%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>Java基础一--基本数据类型&amp;类型转换</title>
    <link href="https://cuizhe1023.github.io/2018/10/10/Java%E5%9F%BA%E7%A1%80%E4%B8%80/"/>
    <id>https://cuizhe1023.github.io/2018/10/10/Java基础一/</id>
    <published>2018-10-10T12:30:55.203Z</published>
    <updated>2018-10-11T01:36:25.065Z</updated>
    
    <content type="html"><![CDATA[<p>Java 中有两大数据类型：</p><ul><li><strong>内置数据类型</strong></li><li><strong>引用数据类型</strong></li></ul><a id="more"></a><h4 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h4><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p><table><thead><tr><th style="text-align:center">基本类型</th><th style="text-align:center">大小</th><th style="text-align:center">最小值</th><th style="text-align:center">最大值</th><th style="text-align:center">默认值</th><th style="text-align:center">包装类</th><th style="text-align:center">例子</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">8 bit</td><td style="text-align:center">-2^7</td><td style="text-align:center">2^7-1</td><td style="text-align:center">0</td><td style="text-align:center">Byte</td><td style="text-align:center">byte a = 100</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">16 bit</td><td style="text-align:center">-2^15</td><td style="text-align:center">2^15 - 1</td><td style="text-align:center">0</td><td style="text-align:center">Short</td><td style="text-align:center">short s = 1000</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">32 bit</td><td style="text-align:center">-2^31</td><td style="text-align:center">2^31 - 1</td><td style="text-align:center">0</td><td style="text-align:center">Integer</td><td style="text-align:center">int a = 100000</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">64 bit</td><td style="text-align:center">-2^63</td><td style="text-align:center">2^63 -1</td><td style="text-align:center">0L</td><td style="text-align:center">Long</td><td style="text-align:center">long a = 100000L</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">32 bit</td><td style="text-align:center">IEEE754</td><td style="text-align:center">IEEE754</td><td style="text-align:center">0.0f</td><td style="text-align:center">Float</td><td style="text-align:center">float f1 = 234.5f</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">64 bit</td><td style="text-align:center">IEEE754</td><td style="text-align:center">IEEE754</td><td style="text-align:center">0.0d</td><td style="text-align:center">Double</td><td style="text-align:center">double d1 = 123.4</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">16 bit</td><td style="text-align:center">\u0000</td><td style="text-align:center">\uffff</td><td style="text-align:center">空</td><td style="text-align:center">Character</td><td style="text-align:center">char letter = ‘A’</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">false</td><td style="text-align:center">Boolean</td><td style="text-align:center">boolean one = true</td></tr></tbody></table><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul><li>在 Java 中，引用类型的变量非常类似于 C/C++ 的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了</li><li>引用数据类型包括：类、接口类型、数组类型、枚举类型、注解类型，字符串型；</li><li>所有引用类型的默认值都是 null</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>什么是类型转换？</p><p><strong>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></p><p>转换从低级到高级</p><blockquote><p>低————————————————————&gt;高</p><p>byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double </p></blockquote><p>数据类型转换必须满足如下规则：</p><ul><li><p>不能对boolean类型进行类型转换。</p></li><li><p>不能把对象类型转换成不相关类的对象。</p></li><li><p>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p></li><li><p>转换过程中可能导致溢出或损失精度，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">128</span>;   </span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;</span><br></pre></td></tr></table></figure><p>因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p></li><li><p>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span>)<span class="number">23.7</span> == <span class="number">23</span>;        </span><br><span class="line">(<span class="keyword">int</span>)-<span class="number">45.89f</span> == -<span class="number">45</span></span><br></pre></td></tr></table></figure></li></ul><p>类型转换分为：</p><ul><li><strong>自动类型转换</strong></li><li><strong>强制类型转换</strong></li></ul><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZiDongLeiZhuan</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">            <span class="keyword">char</span> c1=<span class="string">'a'</span>;<span class="comment">//定义一个char类型</span></span><br><span class="line">            <span class="keyword">int</span> i1 = c1;<span class="comment">//char自动类型转换为int</span></span><br><span class="line">            System.out.println(<span class="string">"char自动类型转换为int后的值等于"</span>+i1);</span><br><span class="line">            <span class="keyword">char</span> c2 = <span class="string">'A'</span>;<span class="comment">//定义一个char类型</span></span><br><span class="line">            <span class="keyword">int</span> i2 = c2+<span class="number">1</span>;<span class="comment">//char 类型和 int 类型计算</span></span><br><span class="line">            System.out.println(<span class="string">"char类型和int计算后的值等于"</span>+i2);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>自动类型转换为<span class="keyword">int</span>后的值等于<span class="number">97</span></span><br><span class="line"><span class="keyword">char</span>类型和<span class="keyword">int</span>计算后的值等于<span class="number">66</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong>：c1 的值为字符 <strong>a</strong> ,查 ASCII 码表可知对应的 int 类型值为 97， A 对应值为 65，所以 i2=65+1=66。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>将高级别类型赋值给低级别类型时，必须进行强制类型转换。</p><ul><li>条件是转换的数据类型必须是兼容的。</li><li>格式：(type)value type是要强制类型转换后的数据类型。</li></ul><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p>Java 中有两大数据类型，基本数据类型和引用数据类型。</p><ul><li>基本数据类型在被创建时，在栈上给其划分一块内存，将<strong>数据直接存储在栈</strong>上.</li><li>引用数据类型在被创建时，首先要在栈上给其引用分配一块内存，而<strong>对象的具体信息都存储在堆</strong>上，然后由栈上面的引用指向堆中对象的地址。</li></ul></li><li><p>简答的说小类型可<strong>自动转换</strong>为大类型，大类型转小类型需要<strong>强制转换</strong>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 中有两大数据类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内置数据类型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引用数据类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数据类型" scheme="https://cuizhe1023.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
</feed>
