<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CuiZhe&#39;s Blog</title>
  
  <subtitle>CuiZhe&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cuizhe1023.github.io/"/>
  <updated>2018-10-17T12:13:49.471Z</updated>
  <id>https://cuizhe1023.github.io/</id>
  
  <author>
    <name>Cui Zhe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础六--继承</title>
    <link href="https://cuizhe1023.github.io/2018/10/17/Java%E5%9F%BA%E7%A1%80%E5%85%AD/"/>
    <id>https://cuizhe1023.github.io/2018/10/17/Java基础六/</id>
    <published>2018-10-17T00:16:32.885Z</published>
    <updated>2018-10-17T12:13:49.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h2><ul><li>继承是类与类之间的一种关系</li><li>使用已存在的类的定义作为基础建立新的类</li><li>新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</li><li>当两个类之间满足 “A is a B” 的关系，我们就说它们满足继承关系</li></ul><a id="more"></a><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>利于代码复用</li><li>缩短开发周期</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>使用 extends 实现继承</li><li>Java 只支持单继承，一个类只能有一个父类（也称为超类、基类） </li></ul><h2 id="继承后的初始化顺序"><a href="#继承后的初始化顺序" class="headerlink" title="继承后的初始化顺序"></a>继承后的初始化顺序</h2><p>父类的静态成员</p><p>子类静态成员</p><p>父类对象构建【属性（赋值）、构造代码块、构造方法】</p><p>子类对象构建【属性（赋值）、构造代码块、构造方法】</p><hr><h1 id="Super关键字"><a href="#Super关键字" class="headerlink" title="Super关键字"></a>Super关键字</h1><h2 id="如何区分调用的是继承父类的方法还是子类自己重写的方法"><a href="#如何区分调用的是继承父类的方法还是子类自己重写的方法" class="headerlink" title="如何区分调用的是继承父类的方法还是子类自己重写的方法?"></a>如何区分调用的是继承父类的方法还是子类自己重写的方法?</h2><ul><li><p>访问父类成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.print();</span><br></pre></td></tr></table></figure></li><li><p>访问父类属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.name;</span><br></pre></td></tr></table></figure></li></ul><h2 id="子类对象实例化时，能否选择父类的构造形式（调用指定的构造方法）？"><a href="#子类对象实例化时，能否选择父类的构造形式（调用指定的构造方法）？" class="headerlink" title="子类对象实例化时，能否选择父类的构造形式（调用指定的构造方法）？"></a>子类对象实例化时，能否选择父类的构造形式（调用指定的构造方法）？</h2><ul><li><p>访问父类构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>();<span class="comment">//无参的构造方法</span></span><br><span class="line"><span class="keyword">super</span>(<span class="string">"name"</span>);<span class="comment">//有参的构造方法</span></span><br></pre></td></tr></table></figure></li><li><p>子类的构造过程中必须调用其父类的构造方法，默认调用无参的构造方法</p></li><li><p>如果子类构造方法中既没有显示标注，而父类有没有无参的构造方法，则编译出错</p></li><li><p>使用 super 调用父类指定构造方法，必须在子类的构造方法的第一行</p></li></ul><hr><h1 id="this-关键字-amp-super-关键字"><a href="#this-关键字-amp-super-关键字" class="headerlink" title="this 关键字 &amp; super 关键字"></a>this 关键字 &amp; super 关键字</h1><table><thead><tr><th>this 关键字——当前类对象的引用</th><th>super 关键字——父类对象的引用</th></tr></thead><tbody><tr><td>访问当前类的成员方法<br>访问当前类的成员属性<br>访问当前类的构造方法<br>不能再静态方法中使用</td><td>访问父类的成员方法<br>访问父类的成员属性<br>访问父类的构造方法<br>不能再静态方法中使用</td></tr></tbody></table><p>构造方法调用时，super 和 this 不能同时出现</p><h1 id="重写-amp-重载"><a href="#重写-amp-重载" class="headerlink" title="重写 &amp; 重载"></a>重写 &amp; 重载</h1><table><thead><tr><th>方法重写</th><th>方法重载</th></tr></thead><tbody><tr><td>在满足继承关系的子类中<br>方法名、参数个数、顺序、返回值与父类相同<br>返回值类型与父类的返回值类型向下兼容<br>访问修饰符的限定范围大于等于父类方法</td><td>在同一个类中<br>方法名相同<br>参数个数、顺序、类型不同<br>返回值类型、访问修饰符任意</td></tr></tbody></table><p><strong>方法重写存在，属性重写不存在</strong></p><hr><h1 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h1><ul><li><p>Object 类是所有类的父类</p></li><li><p>一个类没有使用 extends 关键字明确标识继承关系，则默认继承 Object 类（包括数组）</p></li><li><p>Java 中的每个类都可以使用 Object 中定义的方法</p><p>Object  类的常用方法</p><p>| 方法       | 说明                                         |<br>| ———- | ——————————————– |<br>| toString() | 返回当前对象本身的有关信息，按字符串对象返回 |<br>| equals()   | 比较两个对象是否是同一个对象，是则返回true   |<br>| hashCode() | 返回该对象的哈希代码值                       |<br>| getClass() | 获取当前对象所属的类信息，返回Class对象      |</p></li></ul><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><p>final 表示“最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</p><ul><li>被 final 修饰的类表示不允许被继承</li><li>被 final 修饰的方法表示不允许被子类重写<ul><li>final 修饰的方法可以被继承</li><li>不能修饰构造方法</li></ul></li><li>被 final 修饰的变量表示不允许被修改<ul><li>方法内部的局部变量 —&gt; 在使用之前被初始化赋值即可</li><li>类中的成员变量 —&gt; 只能在定义时或者构造代码块、构造方法中进行初始化设置</li><li>基本数据类型的变量 —&gt; 初始赋值之后不能更改</li><li>引用类型的变量—&gt;初始化之后不能再指向另一个对象，但指向的对象的内容时可变的</li><li>不能修饰构造方法</li></ul></li><li>可配合 static 使用，表示静态的、不允许被修改的信息</li><li>使用 final 修饰可以提高性能，但会降低可扩展性</li></ul><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>可以声明在包、类、属性、方法、局部变量、方法参数等的前面，用来对这些元素进行说明、注释</p><h2 id="按照运行机制分"><a href="#按照运行机制分" class="headerlink" title="按照运行机制分"></a>按照运行机制分</h2><ul><li>源码注解</li><li>编译时注解</li><li>运行时注解</li></ul><h2 id="按照来源分"><a href="#按照来源分" class="headerlink" title="按照来源分"></a>按照来源分</h2><ul><li><p>来自 JDK 的注解</p></li><li><p>来自第三方的注解</p></li><li><p>自定义注解</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h1&gt;&lt;h2 id=&quot;继承的概念&quot;&gt;&lt;a href=&quot;#继承的概念&quot; class=&quot;headerlink&quot; title=&quot;继承的概念&quot;&gt;&lt;/a&gt;继承的概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;继承是类与类之间的一种关系&lt;/li&gt;
&lt;li&gt;使用已存在的类的定义作为基础建立新的类&lt;/li&gt;
&lt;li&gt;新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。&lt;/li&gt;
&lt;li&gt;当两个类之间满足 “A is a B” 的关系，我们就说它们满足继承关系&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="继承" scheme="https://cuizhe1023.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="super关键字" scheme="https://cuizhe1023.github.io/tags/super%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
      <category term="this关键字" scheme="https://cuizhe1023.github.io/tags/this%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
      <category term="final关键字" scheme="https://cuizhe1023.github.io/tags/final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
      <category term="重写&amp;重载" scheme="https://cuizhe1023.github.io/tags/%E9%87%8D%E5%86%99-%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>数据结构概述</title>
    <link href="https://cuizhe1023.github.io/2018/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
    <id>https://cuizhe1023.github.io/2018/10/14/数据结构概述/</id>
    <published>2018-10-14T03:08:40.000Z</published>
    <updated>2018-10-15T02:41:36.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>算法 + 数据结构 = 编程</p><p>什么是数据结构？</p><p>通俗的来说，数据结构是计算机存储、组织数据的方式。</p><p>常用的数据机构有：</p><ul><li>数组</li><li>栈</li><li>队列</li><li>链表</li><li>树</li><li>图</li><li>字典树（这是一种高效的树形结构，但值得单独说明）</li><li>散列表（哈希表）</li></ul><a id="more"></a><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是最简单、也是使用最广泛的数据结构。栈、队列等其他数据结构均是由数组演变过来的。</p><p>下图是一个包含元素（1、2、3、4）的简单数组，数组长度为4。</p><p><img src="/2018/10/14/数据结构概述/数组.jpg" alt="数组"></p><p>每个数据元素都关联一个正数值，我们称之为索引，它表明数组中每个元素所在的位置。大部分语言将初始索引定义为零。</p><h2 id="数组的两种类型："><a href="#数组的两种类型：" class="headerlink" title="数组的两种类型："></a>数组的两种类型：</h2><ul><li>一维数组</li><li>多维数组</li></ul><h2 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h2><ul><li>Insert——在指定索引位置插入一个元素</li><li>Get——返回指定索引位置的元素</li><li>Delete——删除指定索引位置的元素</li><li>Size——得到数组所有元素的数量</li></ul><h2 id="面试中关于数组的常见问题"><a href="#面试中关于数组的常见问题" class="headerlink" title="面试中关于数组的常见问题"></a>面试中关于数组的常见问题</h2><ul><li>寻找数组中第二小的元素</li><li>找到数组中第一个不重复出现的整数</li><li>合并两个有序数组</li><li>重新排列数组中的正值和负值</li></ul><hr><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>著名的撤销操作几乎遍布任意一个应用。但是你有没有想过他是如何实现的？这个问题的解决思路是按照将最后的状态排列在前的顺序，在内存中存储历史工作状态。这没办法用数组实现，但是有了栈，这就变得很方便了。</p><p>可以把栈想象成一摞书，为了拿到中间的书，你需要移除放置在这上面的所有书。这就是LIFO（后进先出）的工作原理。</p><p>下图是包含三个数据元素（1、2、3）的栈，其中顶部的3将被最先移除：</p><p><img src="/2018/10/14/数据结构概述/栈.jpg" alt="栈"></p><h2 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h2><ul><li>Push——在顶部插入一个元素</li><li>Pop——返回并移除栈顶元素</li><li>isEmpty——如果栈为空，则返回true</li><li>Top——返回顶部元素，但并不移除它</li></ul><h2 id="面试中关于栈的常见问题"><a href="#面试中关于栈的常见问题" class="headerlink" title="面试中关于栈的常见问题"></a>面试中关于栈的常见问题</h2><ul><li>使用栈计算后缀表达式</li><li>对栈的元素进行排序</li><li>判断表达式是否括号平衡</li></ul><hr><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>与栈类似，队列是另一种顺序存储元素的线性数据结构。栈与队列的最大差别在于栈是LIFO（后进先出），而队列是FIFO（先进先出）</p><p>常见的队列：排队上车，如果有新人加入，他需要到队尾排队，而非队首。排在前面的人会先上车，然后离开队伍。</p><p>下图是包含四个元素（1，2，3，4）的队列，其中在顶部的1将被最先移除：</p><p><img src="/2018/10/14/数据结构概述/队列.jpg" alt="队列"></p><p>移除先入队的元素、插入新元素</p><h2 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h2><ul><li>Enqueue() —— 在队列尾部插入元素</li><li>Dequeue() ——移除队列头部的元素</li><li>isEmpty()——如果队列为空，则返回true</li><li>Top() ——返回队列的第一个元素</li></ul><h2 id="面试中关于队列的常见问题"><a href="#面试中关于队列的常见问题" class="headerlink" title="面试中关于队列的常见问题"></a>面试中关于队列的常见问题</h2><ul><li>使用队列表示栈</li><li>对队列的前k个元素倒序</li><li>使用队列生成从1到n的二进制数</li></ul><hr><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表是另一个重要的数据结构，乍一看可能有点像数组，但在内存分配，内部结构以及数据插入和删除的基本操作方面均有所不同。</p><p>链表就像一个节点链，其中每个节点包含着数据和指向后续节点的指针。链表还包含一个头指针，它指向链表的第一个元素，但当列表为空时，它指向null或无具体内容。</p><p>链表一般用于实现文件系统、哈希表和邻接表。</p><p>这是链表内部结构的展示：</p><p><img src="/2018/10/14/数据结构概述/链表.jpg" alt="链表"></p><h2 id="链表包括以下类型："><a href="#链表包括以下类型：" class="headerlink" title="链表包括以下类型："></a>链表包括以下类型：</h2><ul><li>单链表</li><li>双向链表</li></ul><h2 id="链表的基本操作："><a href="#链表的基本操作：" class="headerlink" title="链表的基本操作："></a>链表的基本操作：</h2><ul><li>InsertAtEnd - 在链表的末尾插入指定元素</li><li>InsertAtHead - 在链接列表的开头/头部插入指定元素</li><li>Delete  - 从链接列表中删除指定元素</li><li>DeleteAtHead - 删除链接列表的第一个元素</li><li>Search  - 从链表中返回指定元素</li><li>isEmpty - 如果链表为空，则返回true</li></ul><h2 id="面试中关于链表的常见问题"><a href="#面试中关于链表的常见问题" class="headerlink" title="面试中关于链表的常见问题"></a>面试中关于链表的常见问题</h2><ul><li>反转链表</li><li>检测链表中的循环</li><li>返回链表倒数第N个节点</li><li>删除链表中的重复项</li></ul><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>图是一组以网络形式相互连接的节点，节点也称为顶点。一对节点（x，y）称为边（edge），表示顶点x连接到顶点y。边可以包含权重/成本，显示从顶点x到y所需的成本。</p><p><img src="/2018/10/14/数据结构概述/图.jpg" alt="图"></p><h2 id="图的类型"><a href="#图的类型" class="headerlink" title="图的类型"></a>图的类型</h2><ul><li>无向图</li><li>有向图</li></ul><p>在程序语言中，图可以用两种形式表示</p><ul><li>邻接矩阵</li><li>邻接表</li></ul><h2 id="常见的图遍历算法"><a href="#常见的图遍历算法" class="headerlink" title="常见的图遍历算法"></a>常见的图遍历算法</h2><ul><li>广度优先搜索</li><li>深度优先搜索</li></ul><h2 id="面试中关于图的常见问题"><a href="#面试中关于图的常见问题" class="headerlink" title="面试中关于图的常见问题"></a>面试中关于图的常见问题</h2><ul><li>实现广度和深度优先搜索</li><li>检查图是否为树</li><li>计算图的边数</li><li>找到两个顶点之间的最短路径</li></ul><hr><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树形结构是一种层级式的数据结构，由顶点（节点）和连接他们的边组成。数类似于图，但区分树和图的重要特征是树种不存在环路。</p><p>这是一个简单树的示意图，以及树数据结构中使用的基本术语：</p><p><img src="/2018/10/14/数据结构概述/树.jpg" alt="树"></p><p>Root - 根节点</p><p>Parent - 父节点</p><p>Child - 子节点</p><p>Leaf - 叶子节点</p><p>Sibling - 兄弟节点</p><h2 id="树形结构的主要类型"><a href="#树形结构的主要类型" class="headerlink" title="树形结构的主要类型"></a>树形结构的主要类型</h2><ul><li>N元树</li><li>平衡树</li><li>二叉树</li><li>二叉搜索树</li><li>AVL树</li><li>红黑树</li><li>2-3树</li><li>B 树</li><li>B+ 树</li></ul><p>其中，二叉树和二叉搜索树是最常用的树。</p><h2 id="面试中关于树结构的常见问题"><a href="#面试中关于树结构的常见问题" class="headerlink" title="面试中关于树结构的常见问题"></a>面试中关于树结构的常见问题</h2><ul><li>求二叉树的高度</li><li>在二叉搜索树中查找第k个最大值</li><li>查找与根节点距离k的节点</li><li>在二叉树中查找给定节点的祖先节点</li></ul><h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><p>字典树，也称为“前缀树”，是一种特殊的树形数据结构，对于解决字符串相关问题非常有效。他能够提供快速减速，主要用于搜索字典中的单词，在搜索引擎中自动提供建议，甚至被用于 IP 的路由。</p><p>以下是在字典树中存储三个单词“top”，“thus”和“their”的例子：</p><p><img src="/2018/10/14/数据结构概述/字典树.jpg" alt="字典树"></p><p>这些单词以顶部到底部的方式存储，其中绿色节点“p”，“s”和“r”分别表示“top”，“thus”和“their”的底部。</p><h2 id="面试中关于字典树的常见问题"><a href="#面试中关于字典树的常见问题" class="headerlink" title="面试中关于字典树的常见问题"></a>面试中关于字典树的常见问题</h2><ul><li>计算字典树中的总单词数</li><li>打印存储在字典树中的所有单词</li><li>使用字典树对数组的元素进行排序</li><li>使用字典树从字典中形成单词</li><li>构建T9字典（字典树+ DFS ）</li></ul><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希法（Hashing）是一个用于唯一标识对象并将每个对象存储在一些预先计算的唯一索引（称为“键key”）中的过程。因此，对象以键值对的形式存储，这些键值对集合被称为“字典”。可以使用键搜索每个对象。基于哈希法有很多不同的数据结构，但最常用的数据结构是哈希表。</p><p>哈希表通常用数组实现。</p><p>散列数据结构的性能取决于以下三个因素：</p><ul><li>哈希函数</li><li>哈希表的大小</li><li>碰撞处理方法</li></ul><p>下图为如何在数组中映射哈希键值对的说明。该数组的索引是通过哈希函数计算的。</p><p><img src="/2018/10/14/数据结构概述/哈希表.jpg" alt="哈希表"></p><h2 id="面试中关于哈希结构的常见问题："><a href="#面试中关于哈希结构的常见问题：" class="headerlink" title="面试中关于哈希结构的常见问题："></a>面试中关于哈希结构的常见问题：</h2><ul><li>在数组中查找对称键值对</li><li>追踪遍历的完整路径</li><li>查找数组是否是另一个数组的子集</li><li>检查给定的数组是否不相交</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;p&gt;算法 + 数据结构 = 编程&lt;/p&gt;
&lt;p&gt;什么是数据结构？&lt;/p&gt;
&lt;p&gt;通俗的来说，数据结构是计算机存储、组织数据的方式。&lt;/p&gt;
&lt;p&gt;常用的数据机构有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组&lt;/li&gt;
&lt;li&gt;栈&lt;/li&gt;
&lt;li&gt;队列&lt;/li&gt;
&lt;li&gt;链表&lt;/li&gt;
&lt;li&gt;树&lt;/li&gt;
&lt;li&gt;图&lt;/li&gt;
&lt;li&gt;字典树（这是一种高效的树形结构，但值得单独说明）&lt;/li&gt;
&lt;li&gt;散列表（哈希表）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://cuizhe1023.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://cuizhe1023.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java基础五--封装</title>
    <link href="https://cuizhe1023.github.io/2018/10/14/Java%E5%9F%BA%E7%A1%80%E4%BA%94/"/>
    <id>https://cuizhe1023.github.io/2018/10/14/Java基础五/</id>
    <published>2018-10-14T00:35:35.658Z</published>
    <updated>2018-10-16T14:32:25.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>什么是封装？</p><ul><li>通过该类提供的方法来实现对隐藏信息的操作和访问</li><li>隐藏对象的信息</li><li>留出访问的接口</li></ul><a id="more"></a><h2 id="封装的优点"><a href="#封装的优点" class="headerlink" title="封装的优点"></a>封装的优点</h2><ul><li>良好的封装能减少耦合</li><li>类内部的结构可以自由修改</li><li>可以对成员变量进行更精确的控制</li><li>隐藏信息，实现细节</li></ul><h2 id="实现Java封装的步骤"><a href="#实现Java封装的步骤" class="headerlink" title="实现Java封装的步骤"></a>实现Java封装的步骤</h2><ul><li><p>隐藏对象</p><p><strong>修改属性的可见性——设置为 private</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，将 name 和 age 属性设置为私有的，只有本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。</p></li><li><p>留出接口</p><p><strong>创建 getter / setter 方法——设置为 public 用于属性的读写</strong></p><p><strong>在 getter / setter 方法中加入属性控制语句——对属性值的合法性进行判断</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name）之间发生的同名的冲突。</p></li></ul><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>管理 Java 文件</li><li>解决同名文件冲突</li></ul><h3 id="定义包"><a href="#定义包" class="headerlink" title="定义包"></a>定义包</h3><p><strong>语法：</strong>package 包名;</p><p><strong>注意：</strong></p><p>1.必须放在 Java 源文件中的第一行</p><p>2.一个 Java 源文件中只能有一个 package 语句</p><p>3.包名全部英文小写</p><p>4.命名方式：域名倒序 + 模块 + 功能</p><p>eg：package com.nuc.zigbee;</p><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p><strong>语法：</strong></p><p>import 包名.类名;</p><p>eg:</p><p>import com.nuc.*;</p><p>import com.nuc.zigbee;</p><h3 id="常用系统包"><a href="#常用系统包" class="headerlink" title="常用系统包"></a>常用系统包</h3><p>java.lang 包含 Java 语言基础的类</p><p>java.util 包含 Java 语言中的各种工具类</p><p>java.io 包含输入、输出相关功能的类</p><h1 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h1><p>static 翻译为静态，从面向对象的角度讲，当一个类中的变量或方法用 static 修饰时，这些变量和方法就成了类本身的，他们和对象的关系并不大。但是从直观的角度讲，这些被修饰的量确实被该类所有对象所拥有，并且被这个类的所有对象所共享，求其是当使用该类对象进行引用他们时。其实当使用对象进行引用 static 修饰成员时，在底层代码的实现中，其实还是转换为类名进行引用，这表明这个成员属于类。</p><ul><li>static + 属性——静态属性、类属性</li><li>static + 方法——静态方法、类方法</li><li>static + 类——不存在，不能加载类前</li><li>static + 方法内局部变量——不能加载局部变量前</li><li>static + 代码块——静态代码块</li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ul><li>通过{}可以形成代码块</li><li>方法内的代码块称为：普通代码块</li><li>类内的代码块称为：构造代码块</li><li>构造代码块前 + static：静态代码块</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>初学这个关键字时，书上有个重点，那就是一个类中， static 修饰的成员不能访问势力成员，只能访问静态成员。这个很好理解，static 修饰的成员叫做类成员，属于类本身的属性，随着类的编译进行初始化，而此时实例成员未必进行初始化，这就会带来很多错误，所以类成员访问实例成员是不能通过编译的。</li><li>静态方法中不可以定义 this，super 关键字，因为静态元素优先于对象存在。</li></ul><h3 id="静态成员的声明周期"><a href="#静态成员的声明周期" class="headerlink" title="静态成员的声明周期"></a>静态成员的声明周期</h3><p>静态成员随着类的加载而产生，销毁时释放，生命周期伴随着类的整个的生命周期，生命周期长，这就意味着对内存资源的占用也会相对比较长。</p><h3 id="静态方法中的成员调用"><a href="#静态方法中的成员调用" class="headerlink" title="静态方法中的成员调用"></a>静态方法中的成员调用</h3><ul><li>可以直接调用同类中的静态成员。</li><li>不可以直接调用同类中的非静态成员。</li><li>只能通过对象实例化后，对象.成员方法 的方式访问非静态成员。</li></ul><h3 id="各种代码块的执行顺序"><a href="#各种代码块的执行顺序" class="headerlink" title="各种代码块的执行顺序"></a>各种代码块的执行顺序</h3><p>无论实例产生多少对象，静态代码块只执行一次。</p><p>构造代码块在每次对象构造的时候调用。</p><p>方法中的普通代码块则是在每次调用方法的时候顺序调用。</p><h3 id="什么时候定义静态变量"><a href="#什么时候定义静态变量" class="headerlink" title="什么时候定义静态变量"></a>什么时候定义静态变量</h3><p>当对象中出现共享数据时，该数据被修饰成静态，对象中的特有数据，修饰为非静态，存在于堆内存中。</p><h3 id="什么时候定义静态方法"><a href="#什么时候定义静态方法" class="headerlink" title="什么时候定义静态方法"></a>什么时候定义静态方法</h3><p>当功能内部没有访问到非静态数据（对象中特有的数据），该函数可以定义为静态的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h1&gt;&lt;p&gt;什么是封装？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过该类提供的方法来实现对隐藏信息的操作和访问&lt;/li&gt;
&lt;li&gt;隐藏对象的信息&lt;/li&gt;
&lt;li&gt;留出访问的接口&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="封装" scheme="https://cuizhe1023.github.io/tags/%E5%B0%81%E8%A3%85/"/>
    
      <category term="static" scheme="https://cuizhe1023.github.io/tags/static/"/>
    
  </entry>
  
  <entry>
    <title>Java基础四--面向对象基础</title>
    <link href="https://cuizhe1023.github.io/2018/10/13/Java%E5%9F%BA%E7%A1%80%E5%9B%9B/"/>
    <id>https://cuizhe1023.github.io/2018/10/13/Java基础四/</id>
    <published>2018-10-13T10:20:01.898Z</published>
    <updated>2018-10-14T00:25:01.681Z</updated>
    
    <content type="html"><![CDATA[<p>如果你现实中没有对象，至少你在java世界里会有茫茫多的对象，听起来是不是很激动呢？<br><a id="more"></a></p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>对象是类的一个实例，有状态和行为。</p><p>我们所在的世界，周围的一切事物都是对象，车、人、狗等等。这些对象都有自己的状态和行为。</p><p>我们用一只猫来举例，它的状态有：名字、品种、颜色，行为由：跑，叫，睡觉。</p><p>软件的对象也有状态和行为。软件对象的状态称为<strong>属性</strong>，行为通过<strong>方法</strong>体现。</p><h2 id="那么什么是面向对象？"><a href="#那么什么是面向对象？" class="headerlink" title="那么什么是面向对象？"></a>那么什么是面向对象？</h2><p>关注现实存在的事物的各方面的信息，从对象的角度出发，根据事物的特征进行程序设计</p><hr><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类是一个模子，确定对象将会拥有的特性（属性）和行为（方法）</p><p>类的特点：</p><ul><li>类是对象的类型</li><li>具有相同属性和方法的一组对象的集合</li></ul><p>对象是类的实例表现</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>对象具有的静态特征。对象“有什么”。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>对象具有的各种动态行为。对象“能做什么”。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>一个类中可以包含以下类型变量：</p><ul><li><p>局部变量</p><p>在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都在方法中，方法结束后，变量就会自动销毁</p></li><li><p>成员变量</p><p>成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问</p></li><li><p>类变量</p><p>类变量也声明在类中，方法体之外，但必须声明为static类型</p></li></ul><hr><h1 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h1><p>类是抽象的概念，仅仅是模板</p><p>对象是一个你能看得见，摸得着的具体实体</p><p>类是对象的类型</p><p>对象是特定类型的数据</p><hr><h1 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h1><p>实例化对象的过程可以分为两部分:</p><p>- 声明对象 Cat one</p><p>- 实例化对象 new Cat()</p><p>- Cat one = new Cat();//类名 对象名 = new  构造方法();</p><p>声明对象，就是在内存的<strong>栈区域</strong>开辟一块空间，此时这个空间里的值是空的</p><p>实例化对象，在内存的<strong>堆区域</strong>开辟一块空间，完成初始化操作</p><p><img src="/2018/10/13/Java基础四/对象实例化1.png" alt="对象实例化1"></p><p>经过赋值操作，我们将堆空间中的地址，传递到了栈当中的内存空间里。此后，我们就可以通过对象名去调用对象的属性和方法了。</p><p><img src="/2018/10/13/Java基础四/对象实例化2.png" alt="对象实例化2"></p><p>每次 new 对象就会产生新的实例化方法</p><p>- Cat one  = new Cat();</p><p>- Cat two = new Cat();</p><p><img src="/2018/10/13/Java基础四/对象实例化3.png" alt="对象实例化3"></p><p>多个对象也可以指向同一块实例化空间</p><p>- Cat one = new Cat();</p><p>- Cat two = one;</p><p><img src="/2018/10/13/Java基础四/对象实例化4.png" alt="对象实例化4"></p><h2 id="对象实例化-1"><a href="#对象实例化-1" class="headerlink" title="对象实例化"></a>对象实例化</h2><p>对象必须被实例化之后才能使用</p><p>对象间的引用传递，实际上传递的是堆内存空间的使用权</p><hr><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><ul><li>构造方法与类同名且没有返回值</li><li>只能在对象实例化的时候调用</li><li>一个类可以有多个构造方法—构造方法重载</li><li>当没有指定构造方法时，系统会自动调用无参的构造方法</li><li>当有指定构造方法，无论是有参、无参的构造方法，都不会自动调用无参的构造方法。</li><li>构造方法不可被重写</li></ul><hr><h1 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h1><p>this: 当前对象的默认引用</p><p>this 的使用</p><p>- 调用成员属性，解决成员属性和局部变量同名冲突</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  System.out.println(<span class="string">"我是单参构造"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>- 调用成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.eat();</span><br><span class="line">    System.out.println(<span class="string">"小猫快跑"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>- 调用重载的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"我是无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>();<span class="comment">//通过this()调用构造方法，必须放在方法体内的第一行。</span></span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">    System.out.println(<span class="string">"我是单参构造"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h1><p>当在一个源文件中定义多个类，并且还有 import 语句和 package 语句时，要特别注意这些规则</p><ul><li>一个源文件中只能有一个 public 类</li><li>一个源文件可以有多个非public类</li><li>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是  Employee，那么源文件应该命名为 Employee.java</li><li>如果一个类定义在某个包中，那么 package 语句应该在源文件的首行</li><li>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么import 语句应该在源文件中最前面</li><li>import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你现实中没有对象，至少你在java世界里会有茫茫多的对象，听起来是不是很激动呢？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面向对象" scheme="https://cuizhe1023.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java基础三--运算符</title>
    <link href="https://cuizhe1023.github.io/2018/10/13/Java%E5%9F%BA%E7%A1%80%E4%B8%89/"/>
    <id>https://cuizhe1023.github.io/2018/10/13/Java基础三/</id>
    <published>2018-10-13T10:15:29.982Z</published>
    <updated>2018-10-13T10:17:29.744Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 中运算符有一下几组</p><ul><li><strong>算数运算符</strong></li><li><strong>关系运算符</strong></li><li><strong>位运算符</strong></li><li><strong>逻辑运算符</strong></li><li><strong>赋值运算符</strong></li><li><strong>其他运算符</strong></li></ul><a id="more"></a><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p>算数运算符用在数学表达式中，作用和在数学中的作用一样。</p><p>在表格中 A = 10, B = 20</p><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">描述</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">+</td><td style="text-align:left">加法</td><td style="text-align:left">A + B = 30</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">减法</td><td style="text-align:left">A - B = -10</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">乘法</td><td style="text-align:left">A * B = 200</td></tr><tr><td style="text-align:left">/</td><td style="text-align:left">除法</td><td style="text-align:left">B / A = 2</td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">取余</td><td style="text-align:left">B % A = 0</td></tr><tr><td style="text-align:left">++</td><td style="text-align:left">自增</td><td style="text-align:left">A++ 或 ++A 等于11</td></tr><tr><td style="text-align:left">–</td><td style="text-align:left">自减</td><td style="text-align:left">B– 或者 –B 等于19</td></tr></tbody></table><h3 id="i-和-i-的区别"><a href="#i-和-i-的区别" class="headerlink" title="i++ 和 ++i 的区别"></a>i++ 和 ++i 的区别</h3><ul><li>++i 先进行自增操作，在进行表达式运算</li><li>i++ 先进行表达式运算，在进行自增操作</li></ul><p>简单的来说，i++ 与 ++i 在单独使用的时候，都代表了 i = i + 1;</p><p>表达式 a = ++i; 等价于 i = i + 1;a = i;</p><p>表达式 a = i++; 等价于 a = i;i = i + 1;</p><hr><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>A = 10, B = 20</p><table><thead><tr><th style="text-align:left">运算符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td style="text-align:left">==</td><td>检查两个操作数的值是否相等，如果相等则返回true</td><td>(A = B) false</td></tr><tr><td style="text-align:left">!=</td><td>检查两个操作数的值是否相等，如果不相等则返回true</td><td>(A != B) true</td></tr><tr><td style="text-align:left">&gt;</td><td>检查左操作数的值是否大于右操作数的值，如果是，返回true</td><td>(A &gt; B) false</td></tr><tr><td style="text-align:left">&lt;</td><td>检查左操作数的值是否小于右操作数的值，如果是，返回true</td><td>(A &lt; B) true</td></tr><tr><td style="text-align:left">&gt;=</td><td>检查左操作数的值是否大于或者等于右操作数的值，如果是，返回true</td><td>(A &gt;= B) false</td></tr><tr><td style="text-align:left">&lt;=</td><td>检查左操作数的值是否小于或者等于右操作数的值，如果是，返回true</td><td>(A &lt;= B) true</td></tr></tbody></table><hr><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算应用于整数类型（int），长整型（long），短整型（short），字符型（char）和字节型（byte）等类型。</p><p>位运算符作用在所有的位上，并且按位运算。假设 A = 60, B = 13,则二进制表示如下</p><blockquote><p>A = 0011 1100</p><p>B = 0000 1101</p></blockquote><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与运算符，如果相对应位都是1，则结果为1，否则为0</td><td>(A &amp; B) = 0000 1100 即12</td></tr><tr><td>丨</td><td>按位或运算符，如果相对应位都是0，则结果为0，否则为1</td><td>(A 丨 B) = 0011 1101 即61</td></tr><tr><td>^</td><td>按位异或运算符，如果相对应位值相同，则结果为0，否则为1</td><td>(A ^ B) = 0011 0001 即49</td></tr><tr><td>~</td><td>取反运算符，按位取反运算符翻转操作数的每一位，即0变成1，1变成0</td><td>(~ A) = 1100 0011 即-61</td></tr><tr><td>&lt;&lt;</td><td>按位左移运算符。左操作数按位左移右操作数指定的位数</td><td>(A &lt;&lt; 2) = 1111 0000 即240</td></tr><tr><td>&gt;&gt;</td><td>按位右移运算符。左操作数按位右移右操作数指定的位数</td><td>(A &gt;&gt; 2) = 1111 即15</td></tr><tr><td>&gt;&gt;&gt;</td><td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充</td><td>(A &gt;&gt;&gt; 2) = 00001111 即15</td></tr></tbody></table><hr><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>假设 A = true, B = false</p><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td><td>(A &amp;&amp; B) = false</td></tr><tr><td>丨丨</td><td>逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td><td>(A 丨丨 B) = true</td></tr><tr><td>！</td><td>逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td><td>! (A &amp;&amp; B)=  true</td></tr></tbody></table><h3 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h3><p>当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。</p><ul><li>短路逻辑与</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b = (a &lt; <span class="number">4</span>) &amp;&amp; (a++&lt;<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"使用短路逻辑运算符的结果为"</span>+b);</span><br><span class="line">        System.out.println(<span class="string">"a的结果为"</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用短路逻辑运算符的结果为false<br>a的结果为5</p></blockquote><p><strong>解析</strong>：该程序使用到了短路逻辑运算符(&amp;&amp;)，首先判断 a&lt;4 的结果为 false，则 b 的结果必定是 false，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。</p><ul><li>短路逻辑或</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b = (a &gt; <span class="number">4</span>) || (a++&lt;<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"使用短路逻辑运算符的结果为"</span>+b);</span><br><span class="line">        System.out.println(<span class="string">"a的结果为"</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用短路逻辑运算符的结果为true<br>a的结果为5</p></blockquote><p><strong>解析</strong>：该程序使用到了短路逻辑运算符(||)，首先判断 a &gt; 4 的结果为 true，则 b 的结果必定是 true，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。</p><hr><h2 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h2><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符，将右操作数的值赋给左侧操作数</td><td>C = A + B将把A + B得到的值赋给C</td></tr><tr><td>+=</td><td>加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td><td>C += A等价于C = C + A</td></tr><tr><td>-=</td><td>减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td><td>C -= A等价于C = C -  A</td></tr><tr><td>*=</td><td>乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td><td>C <em>= A等价于C = C </em> A</td></tr><tr><td>/=</td><td>除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td><td>C / = A等价于C = C / A</td></tr><tr><td>(％)=</td><td>取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td><td>C％= A等价于C = C％A</td></tr><tr><td>&lt;&lt; =</td><td>左移位赋值运算符</td><td>C &lt;&lt; = 2等价于C = C &lt;&lt; 2</td></tr><tr><td>&gt;&gt; =</td><td>右移位赋值运算符</td><td>C &gt;&gt; = 2等价于C = C &gt;&gt; 2</td></tr><tr><td>&amp;=</td><td>按位与赋值运算符</td><td>C＆= 2等价于C = C＆2</td></tr><tr><td>^ =</td><td>按位异或赋值操作符</td><td>C ^ = 2等价于C = C ^ 2</td></tr><tr><td>丨=</td><td>按位或赋值操作符</td><td>C 丨 = 2等价于C = C 丨 2</td></tr></tbody></table><hr><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><p>条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p><p>对于条件表达式b ? x : y，先计算条件b，然后进行判断。如果b的值为true，计算x的值，运算结果为x的值；否则，计算y的值，运算结果为y的值。一个条件表达式绝不会既计算x，又计算y。条件运算符是右结合的，也就是说，从右向左分组计算。例如，a ? b : c ? d : e将按a ? b : (c ? d : e)执行。</p><h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p><p>用法：<br>result = object instanceof class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">"James"</span>;</span><br><span class="line"><span class="keyword">boolean</span> result = name <span class="keyword">instanceof</span> String; <span class="comment">// 由于 name 是 String 类型，所以返回 true</span></span><br></pre></td></tr></table></figure><hr><h2 id="Java-运算符优先级"><a href="#Java-运算符优先级" class="headerlink" title="Java 运算符优先级"></a>Java 运算符优先级</h2><table><thead><tr><th>类别</th><th>操作符</th><th>关联性</th></tr></thead><tbody><tr><td>后缀</td><td>() [] . (点操作符)</td><td>左到右</td></tr><tr><td>一元</td><td>+ - ! ~</td><td>从右到左</td></tr><tr><td>乘性</td><td>* / ％</td><td>左到右</td></tr><tr><td>加性</td><td>+ -</td><td>左到右</td></tr><tr><td>移位</td><td>&gt;&gt; &gt;&gt;&gt;  &lt;&lt;</td><td>左到右</td></tr><tr><td>关系</td><td>&gt; &gt;= &lt; &lt;=</td><td>左到右</td></tr><tr><td>相等</td><td>==  !=</td><td>左到右</td></tr><tr><td>按位与</td><td>＆</td><td>左到右</td></tr><tr><td>按位异或</td><td>^</td><td>左到右</td></tr><tr><td>按位或</td><td>丨</td><td>左到右</td></tr><tr><td>逻辑与</td><td>&amp;&amp;</td><td>左到右</td></tr><tr><td>逻辑或</td><td>丨丨</td><td>左到右</td></tr><tr><td>条件</td><td>？：</td><td>从右到左</td></tr><tr><td>赋值</td><td>= += -= *= /= ％= &gt;&gt;= &lt;&lt;= &amp;= ^= 丨=</td><td>从右到左</td></tr><tr><td>逗号</td><td>，</td><td>左到右</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Java 中运算符有一下几组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;算数运算符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关系运算符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;位运算符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逻辑运算符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;赋值运算符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他运算符&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="运算符" scheme="https://cuizhe1023.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>Java基础二--修饰符</title>
    <link href="https://cuizhe1023.github.io/2018/10/13/Java%E5%9F%BA%E7%A1%80%E4%BA%8C/"/>
    <id>https://cuizhe1023.github.io/2018/10/13/Java基础二/</id>
    <published>2018-10-13T10:15:18.088Z</published>
    <updated>2018-10-13T10:16:07.109Z</updated>
    
    <content type="html"><![CDATA[<p>Java 中主要有两类修饰符：</p><ul><li><strong>访问修饰符</strong></li><li><strong>非访问修饰符</strong></li></ul><a id="more"></a><h2 id="Java-访问修饰符"><a href="#Java-访问修饰符" class="headerlink" title="Java 访问修饰符"></a>Java 访问修饰符</h2><table><thead><tr><th style="text-align:center">访问修饰符</th><th style="text-align:center">当前类</th><th style="text-align:center">同一包内</th><th style="text-align:center">子类</th><th style="text-align:center">其他包</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><p>public : 公开,所有类可见</p><p>protected :继承访问权限（本包中的子类非子类均可访问，不同包中的子类可以访问，不是子类不能访问）</p><p>default :包访问权限（本包中的子类非子类均可访问，不同包中的类及子类均不能访问）</p><p>private :私有,在同一类内可见</p><p><strong>[注]</strong>：protected的可见性在于两点：</p><ul><li>父类的 protected 成员是包内可见的，并且对子类可见；</li><li>若子类与父类不在同一包中，那么在子类中，子类实例可以访问其从父类继承而来的protected方法，而不能访问父类实例的protected方法。</li></ul><h3 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h3><ul><li>父类中声明为 public 的方法在子类中也必须为 public。</li><li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li><li>父类中声明为 private 的方法，不能够被继承。</li></ul><hr><h2 id="Java-非访问修饰符"><a href="#Java-非访问修饰符" class="headerlink" title="Java 非访问修饰符"></a>Java 非访问修饰符</h2><p>Java 中的非访问修饰符有：</p><ul><li>static 修饰符，用来修饰类方法和类变量</li><li>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</li><li>abstract 修饰符，用来创建抽象类和抽象方法。</li><li>synchronized 和 volatile 修饰符，主要用于线程的编程。</li></ul><h3 id="Static-修饰符"><a href="#Static-修饰符" class="headerlink" title="Static 修饰符"></a>Static 修饰符</h3><p>所谓静态就是指在编译后所分配的内存会一直存在，直到程序退出内存才会释放这个空间，也就是只要程序在运行，那么这块内存就会一直存在。</p><ul><li><p><strong>静态变量：</strong></p><p>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</p></li><li><p><strong>静态方法：</strong></p><p>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p></li></ul><h3 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h3><p>final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</p><ul><li>final 修饰符通常和 static 修饰符一起使用来创建类常量。</li><li>类中的 final 方法可以被子类继承，但是不能被子类修改。声明 final 方法的主要目的是防止该方法的内容被修改。</li><li>final 类不能被继承，没有类能够继承 final 类的任何特性。</li></ul><h3 id="abstract-修饰符"><a href="#abstract-修饰符" class="headerlink" title="abstract 修饰符"></a>abstract 修饰符</h3><ul><li><p><strong>抽象类：</strong></p><p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</p><p>一个类不能同时被 abstract 和 final 修饰<strong>[被 final 修饰后就不能被继承了]</strong>。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p><p>抽象类可以包含抽象方法和非抽象方法。</p></li><li><p><strong>抽象方法：</strong></p><p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。</p><p>抽象方法不能被声明成 final 和 static。</p><p>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p><p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p><p>抽象方法的声明以分号结尾。</p></li></ul><h3 id="synchronized-修饰符"><a href="#synchronized-修饰符" class="headerlink" title="synchronized 修饰符"></a>synchronized 修饰符</h3><p>synchronized 关键字声明的方法同一时间只能被一个线程访问。</p><h3 id="transient-修饰符"><a href="#transient-修饰符" class="headerlink" title="transient 修饰符"></a>transient 修饰符</h3><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。</p><p>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</p><h3 id="volatile-修饰符"><a href="#volatile-修饰符" class="headerlink" title="volatile 修饰符"></a>volatile 修饰符</h3><p>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p><p>一个 volatile 对象引用可能是 null。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 中主要有两类修饰符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;访问修饰符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非访问修饰符&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="修饰符" scheme="https://cuizhe1023.github.io/tags/%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>Java基础一--基本数据类型&amp;类型转换</title>
    <link href="https://cuizhe1023.github.io/2018/10/13/Java%E5%9F%BA%E7%A1%80%E4%B8%80/"/>
    <id>https://cuizhe1023.github.io/2018/10/13/Java基础一/</id>
    <published>2018-10-13T10:08:00.335Z</published>
    <updated>2018-10-13T12:19:50.520Z</updated>
    
    <content type="html"><![CDATA[<p>Java 中有两大数据类型：</p><ul><li><strong>内置数据类型</strong></li><li><strong>引用数据类型</strong></li></ul><a id="more"></a><h4 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h4><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p><table><thead><tr><th style="text-align:center">基本类型</th><th style="text-align:center">大小</th><th style="text-align:center">最小值</th><th style="text-align:center">最大值</th><th style="text-align:center">默认值</th><th style="text-align:center">包装类</th><th style="text-align:center">例子</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">8 bit</td><td style="text-align:center">-2^7</td><td style="text-align:center">2^7-1</td><td style="text-align:center">0</td><td style="text-align:center">Byte</td><td style="text-align:center">byte a = 100</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">16 bit</td><td style="text-align:center">-2^15</td><td style="text-align:center">2^15 - 1</td><td style="text-align:center">0</td><td style="text-align:center">Short</td><td style="text-align:center">short s = 1000</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">32 bit</td><td style="text-align:center">-2^31</td><td style="text-align:center">2^31 - 1</td><td style="text-align:center">0</td><td style="text-align:center">Integer</td><td style="text-align:center">int a = 100000</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">64 bit</td><td style="text-align:center">-2^63</td><td style="text-align:center">2^63 -1</td><td style="text-align:center">0L</td><td style="text-align:center">Long</td><td style="text-align:center">long a = 100000L</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">32 bit</td><td style="text-align:center">IEEE754</td><td style="text-align:center">IEEE754</td><td style="text-align:center">0.0f</td><td style="text-align:center">Float</td><td style="text-align:center">float f1 = 234.5f</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">64 bit</td><td style="text-align:center">IEEE754</td><td style="text-align:center">IEEE754</td><td style="text-align:center">0.0d</td><td style="text-align:center">Double</td><td style="text-align:center">double d1 = 123.4</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">16 bit</td><td style="text-align:center">\u0000</td><td style="text-align:center">\uffff</td><td style="text-align:center">空</td><td style="text-align:center">Character</td><td style="text-align:center">char letter = ‘A’</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">false</td><td style="text-align:center">Boolean</td><td style="text-align:center">boolean one = true</td></tr></tbody></table><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul><li>在 Java 中，引用类型的变量非常类似于 C/C++ 的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了</li><li>引用数据类型包括：类、接口类型、数组类型、枚举类型、注解类型，字符串型；</li><li>所有引用类型的默认值都是 null</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>什么是类型转换？</p><p><strong>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></p><p>转换从低级到高级</p><blockquote><p>低————————————————————&gt;高</p><p>byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double </p></blockquote><p>数据类型转换必须满足如下规则：</p><ul><li><p>不能对boolean类型进行类型转换。</p></li><li><p>不能把对象类型转换成不相关类的对象。</p></li><li><p>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p></li><li><p>转换过程中可能导致溢出或损失精度，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">128</span>;   </span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;</span><br></pre></td></tr></table></figure><p>因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p></li><li><p>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span>)<span class="number">23.7</span> == <span class="number">23</span>;        </span><br><span class="line">(<span class="keyword">int</span>)-<span class="number">45.89f</span> == -<span class="number">45</span></span><br></pre></td></tr></table></figure></li></ul><p>类型转换分为：</p><ul><li><strong>自动类型转换</strong></li><li><strong>强制类型转换</strong></li></ul><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZiDongLeiZhuan</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">            <span class="keyword">char</span> c1=<span class="string">'a'</span>;<span class="comment">//定义一个char类型</span></span><br><span class="line">            <span class="keyword">int</span> i1 = c1;<span class="comment">//char自动类型转换为int</span></span><br><span class="line">            System.out.println(<span class="string">"char自动类型转换为int后的值等于"</span>+i1);</span><br><span class="line">            <span class="keyword">char</span> c2 = <span class="string">'A'</span>;<span class="comment">//定义一个char类型</span></span><br><span class="line">            <span class="keyword">int</span> i2 = c2+<span class="number">1</span>;<span class="comment">//char 类型和 int 类型计算</span></span><br><span class="line">            System.out.println(<span class="string">"char类型和int计算后的值等于"</span>+i2);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>自动类型转换为<span class="keyword">int</span>后的值等于<span class="number">97</span></span><br><span class="line"><span class="keyword">char</span>类型和<span class="keyword">int</span>计算后的值等于<span class="number">66</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong>：c1 的值为字符 <strong>a</strong> ,查 ASCII 码表可知对应的 int 类型值为 97， A 对应值为 65，所以 i2=65+1=66。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>将高级别类型赋值给低级别类型时，必须进行强制类型转换。</p><ul><li>条件是转换的数据类型必须是兼容的。</li><li>格式：(type)value type是要强制类型转换后的数据类型。</li></ul><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p>Java 中有两大数据类型，基本数据类型和引用数据类型。</p><ul><li>基本数据类型在被创建时，在栈上给其划分一块内存，将<strong>数据直接存储在栈</strong>上.</li><li>引用数据类型在被创建时，首先要在栈上给其引用分配一块内存，而<strong>对象的具体信息都存储在堆</strong>上，然后由栈上面的引用指向堆中对象的地址。</li></ul></li><li><p>简答的说小类型可<strong>自动转换</strong>为大类型，大类型转小类型需要<strong>强制转换</strong>。</p></li></ul><p><img src="/2018/10/13/Java基础一/Java类型装换.jpg" alt="Java类型转换"></p><p>箭头指向的方向表示可以自动转换，箭头的相反方向需要强制转换，虚线所指向的内容可能发生精度的丢失。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 中有两大数据类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内置数据类型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引用数据类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数据类型" scheme="https://cuizhe1023.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
</feed>
