<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CuiZhe&#39;s Blog</title>
  
  <subtitle>CuiZhe&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cuizhe1023.github.io/"/>
  <updated>2018-11-27T14:21:29.974Z</updated>
  <id>https://cuizhe1023.github.io/</id>
  
  <author>
    <name>Cui Zhe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工厂模式</title>
    <link href="https://cuizhe1023.github.io/2018/11/27/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://cuizhe1023.github.io/2018/11/27/工厂模式/</id>
    <published>2018-11-27T13:59:43.000Z</published>
    <updated>2018-11-27T14:21:29.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、工厂模式介绍"><a href="#一、工厂模式介绍" class="headerlink" title="一、工厂模式介绍"></a>一、工厂模式介绍</h1><h2 id="1-工厂模式的定义"><a href="#1-工厂模式的定义" class="headerlink" title="1.工厂模式的定义"></a>1.工厂模式的定义</h2><p>“Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.”(在基类中定义创建对象的一个接口，让子类决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。)</p><h2 id="2-工厂模式的分类："><a href="#2-工厂模式的分类：" class="headerlink" title="2.工厂模式的分类："></a>2.工厂模式的分类：</h2><ol><li>简单工厂（Simple Factory）模式，又称静态工厂方法模式（Static Factory Method Pattern）。</li><li>工厂方法（Factory Method）模式，又称多态性工厂（Polymorphic Factory）模式或虚拟构造子（Virtual Constructor）模式。</li><li>抽象工厂（Abstract Factory）模式，又称工具箱（Kit 或 Toolkit）模式。</li></ol><h2 id="3-为什么要用工厂模式"><a href="#3-为什么要用工厂模式" class="headerlink" title="3.为什么要用工厂模式"></a>3.为什么要用工厂模式</h2><ol><li><strong>解耦</strong> ：把对象的创建和使用的过程分开</li><li><strong>降低代码重复:</strong> 如果创建某个对象的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码</li><li><strong>降低维护成本</strong> ：由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需要创建对象B的地方去逐个修正，只需要在工厂里修改即可，降低维护成本</li></ol><a id="more"></a><h1 id="二、简单工厂模式"><a href="#二、简单工厂模式" class="headerlink" title="二、简单工厂模式"></a>二、简单工厂模式</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>严格的说，简单工厂模式并不是23种常用的设计模式之一，它只算工厂模式的一个特殊实现。简单工厂模式在实际中的应用相对于其他2个工厂模式用的还是相对少得多，因为它只适应很多简单的情况。</p><p>最重要的是它违背了我们在概述中说的 开放-封闭原则 （虽然可以通过反射的机制来避免，后面我们会介绍到） 。因为每次你要新添加一个功能，都需要在生 switch-case 语句（或者 if-else 语句）中去修改代码，添加分支条件。</p><h2 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2.适用场景"></a>2.适用场景</h2><ol><li>需要创建的对象较少</li><li>客户端不关心对象的创建过程</li></ol><h2 id="3-简单工厂模式角色分配"><a href="#3-简单工厂模式角色分配" class="headerlink" title="3.简单工厂模式角色分配"></a>3.简单工厂模式角色分配</h2><ol><li><strong>工厂(Factory)角色:</strong>简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。</li><li><strong>抽象产品(Product)角色:</strong> 简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。</li><li><strong>具体产品(Concrete Product)角色:</strong>简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。</li></ol><h2 id="4-简单工厂实例"><a href="#4-简单工厂实例" class="headerlink" title="4.简单工厂实例"></a>4.简单工厂实例</h2><p>创建一个可以绘制不同形状的绘图工具，可以绘制圆形，正方形，三角形，每个图形都会有一个draw()方法用于绘图.</p><p><strong>1. 创建 Shape 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 创建实现该接口的具体图形类</strong></p><p>圆形</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Circle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Draw a Circle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>长方形</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Rectangle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Draw a Rectangle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正方形</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Square"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Draw a Square"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 创建工厂类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getShape</span><span class="params">(String shapType)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">if</span> (shapType == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">if</span> (shapType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (shapType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (shapType.equalsIgnoreCase(<span class="string">"SQUARE"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Circle 的对象，并调用它的 draw 方法</span></span><br><span class="line">        Shape circle = ShapeFactory.getShape(<span class="string">"Circle"</span>);</span><br><span class="line">        circle.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Rectangle 的对象，并调用它的 draw 方法</span></span><br><span class="line">        Shape rectangle = ShapeFactory.getShape(<span class="string">"Rectangle"</span>);</span><br><span class="line">        rectangle.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Square 的对象，并调用它的 draw 方法</span></span><br><span class="line">        Shape square = ShapeFactory.getShape(<span class="string">"Square"</span>);</span><br><span class="line">        square.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>Circle<br>Draw a Circle<br>Rectangle<br>Draw a Rectangle<br>Square<br>Draw a Square</p></blockquote><p>这样的实现有个问题，如果我们新增产品类的话，就需要修改工厂类中的getShape（）方法，这很明显不符合 <strong>开放-封闭原则</strong> 。</p><h2 id="5-使用反射机制改善简单工厂"><a href="#5-使用反射机制改善简单工厂" class="headerlink" title="5.使用反射机制改善简单工厂"></a>5.使用反射机制改善简单工厂</h2><p><strong>将工厂类改为下面的形式：</strong></p><p>利用反射解决简单工厂每次增加新了产品类都要修改产品工厂的弊端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getClass</span><span class="params">(Class&lt;? extends Shape&gt; clazz)</span></span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = Class.forName(clazz.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Circle circle = (Circle) ShapeFactory2.getClass(Circle.class);</span><br><span class="line">        circle.draw();</span><br><span class="line"></span><br><span class="line">        Rectangle rectangle = (Rectangle) ShapeFactory2.getClass(Rectangle.class);</span><br><span class="line">        rectangle.draw();</span><br><span class="line"></span><br><span class="line">        Square square = (Square) ShapeFactory2.getClass(Square.class);</span><br><span class="line">        square.draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式的虽然符合了 <strong>开放-关闭原则</strong> ，但是每一次传入的都是产品类的全部路径，这样比较麻烦。如果需要改善的话可以通过 <strong>反射+配置文件</strong> 的形式来改善，这种方式使用的也是比较多的。</p><h1 id="三、工厂方法模式"><a href="#三、工厂方法模式" class="headerlink" title="三、工厂方法模式"></a>三、工厂方法模式</h1><h2 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>工厂方法模式应该是在工厂模式家族中是用的最多模式，一般项目中存在最多的就是这个模式。</p><p>工厂方法模式是简单工厂的仅一步深化， 在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说 <strong>每个对象都有一个与之对应的工厂</strong> 。</p><h2 id="2-适用场景-1"><a href="#2-适用场景-1" class="headerlink" title="2.适用场景"></a>2.适用场景</h2><ol><li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li><li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li><li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无需关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li></ol><h2 id="3-工厂方法模式角色分配"><a href="#3-工厂方法模式角色分配" class="headerlink" title="3.工厂方法模式角色分配"></a>3.工厂方法模式角色分配</h2><ol><li><p><strong>抽象工厂(Abstract Factory)角色：</strong>是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。</p></li><li><p><strong>具体工厂(Concrete Factory)角色 ：</strong>这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。</p></li><li><p><strong>抽象产品(Abstract Product)角色 ：</strong>工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。</p></li><li><p><strong>具体产品(Concrete Product)角色 ：</strong>这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应。</p></li></ol><h2 id="4-工厂方法模式实例"><a href="#4-工厂方法模式实例" class="headerlink" title="4.工厂方法模式实例"></a>4.工厂方法模式实例</h2><p>上面简单工厂例子中的图形接口以及相关图像实现类不变。我们只需要增加一个工厂接口以及实现这个接口的工厂类即可。</p><p><strong>1. 创建 Shape 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 增加一个工厂接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 增加相关工厂类</strong></p><p>圆形工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>长方形工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RectangleFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正方形工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SquareFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory circleFactory = <span class="keyword">new</span> CircleFactory();</span><br><span class="line">        Shape circle = circleFactory.getShape();</span><br><span class="line">        circle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>Circle<br>Draw a Circle</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、工厂模式介绍&quot;&gt;&lt;a href=&quot;#一、工厂模式介绍&quot; class=&quot;headerlink&quot; title=&quot;一、工厂模式介绍&quot;&gt;&lt;/a&gt;一、工厂模式介绍&lt;/h1&gt;&lt;h2 id=&quot;1-工厂模式的定义&quot;&gt;&lt;a href=&quot;#1-工厂模式的定义&quot; class=&quot;headerlink&quot; title=&quot;1.工厂模式的定义&quot;&gt;&lt;/a&gt;1.工厂模式的定义&lt;/h2&gt;&lt;p&gt;“Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.”(在基类中定义创建对象的一个接口，让子类决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。)&lt;/p&gt;
&lt;h2 id=&quot;2-工厂模式的分类：&quot;&gt;&lt;a href=&quot;#2-工厂模式的分类：&quot; class=&quot;headerlink&quot; title=&quot;2.工厂模式的分类：&quot;&gt;&lt;/a&gt;2.工厂模式的分类：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;简单工厂（Simple Factory）模式，又称静态工厂方法模式（Static Factory Method Pattern）。&lt;/li&gt;
&lt;li&gt;工厂方法（Factory Method）模式，又称多态性工厂（Polymorphic Factory）模式或虚拟构造子（Virtual Constructor）模式。&lt;/li&gt;
&lt;li&gt;抽象工厂（Abstract Factory）模式，又称工具箱（Kit 或 Toolkit）模式。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;3-为什么要用工厂模式&quot;&gt;&lt;a href=&quot;#3-为什么要用工厂模式&quot; class=&quot;headerlink&quot; title=&quot;3.为什么要用工厂模式&quot;&gt;&lt;/a&gt;3.为什么要用工厂模式&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;解耦&lt;/strong&gt; ：把对象的创建和使用的过程分开&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;降低代码重复:&lt;/strong&gt; 如果创建某个对象的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;降低维护成本&lt;/strong&gt; ：由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需要创建对象B的地方去逐个修正，只需要在工厂里修改即可，降低维护成本&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://cuizhe1023.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="简单工厂模式" scheme="https://cuizhe1023.github.io/tags/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="工厂方法模式" scheme="https://cuizhe1023.github.io/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="抽象工厂模式" scheme="https://cuizhe1023.github.io/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>字符串转整数</title>
    <link href="https://cuizhe1023.github.io/2018/11/13/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>https://cuizhe1023.github.io/2018/11/13/字符串转整数/</id>
    <published>2018-11-13T15:51:10.000Z</published>
    <updated>2018-11-13T16:08:19.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 </p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个字符串,包括数字字母符号,可以为空</span><br></pre></td></tr></table></figure><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果是合法的数值表达则返回该数字，否则返回0</span><br></pre></td></tr></table></figure><h5 id="输入例子"><a href="#输入例子" class="headerlink" title="输入例子:"></a><strong>输入例子:</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">2147483647</span></span><br><span class="line">    <span class="number">1</span>a33</span><br></pre></td></tr></table></figure><h5 id="输出例子"><a href="#输出例子" class="headerlink" title="输出例子:"></a><strong>输出例子:</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2147483647</span></span><br><span class="line">    <span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>将字符串转化为数组进行处理，例如12 = 1<em>10+2；123 = 12\</em>10+3；</p><p>此外还需要注意一下几点</p><ol><li>字符串是否为空</li><li>字符串两边有空格自动屏蔽</li><li>字符串是否溢出（大于最大值，小于最小值）</li><li>字符串的符号怎么判断</li><li>“+123”和”123”效果一样</li><li>字符串的每一位的正确性</li></ol><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToInt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"12a3"</span>;</span><br><span class="line">        <span class="keyword">int</span> b = StringToInt(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">StringToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String s = str.trim();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> symbol = <span class="number">1</span>;<span class="comment">//符号位</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, len = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] array = s.toCharArray();</span><br><span class="line">        <span class="keyword">boolean</span> isValid = <span class="keyword">false</span>;<span class="comment">//结果是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> firstChar = s.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (firstChar &lt; <span class="string">'0'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (firstChar == <span class="string">'-'</span>) &#123;</span><br><span class="line">                    symbol = -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstChar != <span class="string">'+'</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!(<span class="string">'0'</span> &lt;= array[j] &amp;&amp; array[j] &lt;= <span class="string">'9'</span> ))&#123;</span><br><span class="line">                    isValid = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                result = result*<span class="number">10</span> + array[j] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span> ((symbol == <span class="number">1</span> &amp;&amp; result&gt;Integer.MAX_VALUE)||(symbol == -<span class="number">1</span> &amp;&amp; result &lt; Integer.MIN_VALUE))&#123;</span><br><span class="line">                    isValid = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result*symbol;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 &lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="剑指offer(JAVA)" scheme="https://cuizhe1023.github.io/categories/%E5%89%91%E6%8C%87offer-JAVA/"/>
    
    
      <category term="字符串转整数" scheme="https://cuizhe1023.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java基础十一-Map</title>
    <link href="https://cuizhe1023.github.io/2018/11/08/Java%E5%9F%BA%E7%A1%80%E5%8D%81%E4%B8%80-Map/"/>
    <id>https://cuizhe1023.github.io/2018/11/08/Java基础十一-Map/</id>
    <published>2018-11-08T15:36:25.000Z</published>
    <updated>2018-11-20T15:54:04.911Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Map 中的数据是以键值对（key - value）的形式存储的</li><li>key - value 以 Entry 类型的对象实例存在</li><li>可以通过 key 值快速的查找 value 值</li><li>一个映射不能包含重复的键</li><li>每个键最多只能映射到一个值</li><li>当访问的值不在的时候，方法会抛出一个 NoSuchElementException 异常</li><li>当对象的类型和 Map 里元素类型不兼容的时候，就会抛出一个 ClassCastException 异常</li><li>当在不允许使用 Null 对象的 Map 中使用Null对象，会抛出一个 NullPointerException 异常</li><li>当尝试修改一个只读的 Map 时，会抛出一个 UnsupportedOperationException 异常</li></ul><a id="more"></a><h1 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h1><ul><li>添加或者修改功能<ul><li>V put(K key, V value)：添加元素 /修改元素，并返回修改前元素的值</li></ul></li><li>删除功能<ul><li>void clear()：移除所有的键值对元素</li><li>V remove(Object key)：删除键对应的元素，并把值返回</li></ul></li><li>判断功能<ul><li>boolean containsKey(Object key)：判断集合是否包含指定的键</li><li>boolean containsValue(Object value)：判断集合是否包含指定的值</li><li>boolean isEmpty()：判断集合是否为空</li></ul></li><li>获取功能<ul><li>Set&lt; Map.Entry&lt; K,V&gt;&gt; entrySet()：遍历</li><li>V get(Object key)：根据键获取值</li><li>Set&lt; K&gt; keySet()：获取集合中所有键的集合</li><li>Collection&lt; V&gt; values()：获取集合中所有值的集合</li></ul></li><li>长度功能<ul><li>int size()：返回集合中的键值对的对数</li></ul></li></ul><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="什么是Hash表"><a href="#什么是Hash表" class="headerlink" title="什么是Hash表"></a>什么是Hash表</h2><p>在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能</p><p><strong>数组：</strong>采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)</p><p><strong>线性链表：</strong>对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)</p><p><strong>二叉树：</strong>对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</p><p><strong>哈希表：</strong>相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。</p><p>我们知道，数据结构的物理存储结构只有两种：<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<strong>哈希表的主干就是数组</strong>。</p><p>比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</p><blockquote><p><strong>存储位置 = f(关键字)</strong></p></blockquote><p>其中，这个函数f一般称为<strong>哈希函数</strong>，这个函数的设计好坏会直接影响到哈希表的优劣。</p><h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的<strong>哈希冲突</strong>，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 <strong>计算简单</strong>和<strong>散列地址分布均匀,</strong>但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是<strong>数组+链表</strong>的方式</p><p>HashMap 是 Java 中 Map 的一个实现类，它是一个双列结构(数据+链表)，这样的结构使得它的查询和插入效率都很高。HashMap 允许 null 键和值，它的键唯一，元素的存储无序，并且它是线程不安全的。</p><p><img src="/2018/11/08/Java基础十一-Map/Java8HashMap.png" alt="Java8HashMap"></p><p>由于 HashMap 的这些特性，它在 Java 中被广泛地使用，下面我们就基于 Java 8 分析一下 HashMap 的源码。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>HashMap 实现了 Map 接口，继承 AbstractMap。其中 Map 接口定义了键映射到值的规则，而 AbstractMap 类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作，其实 AbstractMap 类已经实现了 Map。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>HashMap提供了三个构造函数：</p><p>HashMap()：构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap</p><p>HashMap(int initialCapacity)：构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap</p><p>HashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和加载因子的空 HashMap</p><p>在这里提到了两个参数：初始容量，加载因子。这两个参数是影响 HashMap 性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是 O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。</p><p>HashMap是一种支持快速存取的数据结构，要了解它的性能必须要了解它的数据结构。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>首先 HashMap 是一个双列结构，它是一个散列表，存储方式是键值对。 它继承了 AbstractMap，实现了 Map&lt;K,V&gt; Cloneable Serializable 接口。</p><p>HashMap 的双列结构是数组 Node[]+链表，我们知道数组的查询很快，但是修改很慢，因为数组定长，所以添加或者减少元素都会导致数组扩容。而链表结构恰恰相反，它的查询慢，因为没有索引，需要遍历链表查询。但是它的修改很快，不需要扩容，只需要在首或者尾部添加即可。HashMap 正是应用了这两种数据结构，以此来保证它的查询和修改都有很高的效率。</p><p>HashMap 在调用 put() 方法存储元素的时候，会根据 key 的 hash 值来计算它的索引，这个索引有什么用呢？HashMap 使用这个索引来将这个键值对储存到对应的数组位置，比如如果计算出来的索引是 n，则它将存储在 Node[n] 这个位置。</p><p>HashMap 在计算索引的时候尽量保证它的离散，但还是会有不同的 key 计算出来的索引是一样的，那么第二次 put 的时候，key 就会产生冲突。HashMap 用链表的结构解决这个问题，当 HashMap 发现当前的索引下已经有不为 null 的 Node 存在时，会在这个 Node 后面添加新元素，同一索引下的元素就组成了链表结构，Node 和 Node 之间如何联系可以看下面 Node 类的源码分析。</p><h3 id="几个比较重要的字段"><a href="#几个比较重要的字段" class="headerlink" title="几个比较重要的字段"></a>几个比较重要的字段</h3><p>DEFAULT_INITIAL_CAPACITY，默认初始化的容量为16，必须是2的幂。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure><p>MAXIMUM_CAPACITY，最大长度，2^30：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>DEFAULT_LOAD_FACTOR，默认加载因子，0.75：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p>由链表转换成树的阈值TREEIFY_THRESHOLD</p><p>一个桶中 bin（箱子）的存储方式由链表转换成树的阈值。即当桶中bin的数量超过 TREEIFY_THRESHOLD 时使用树来代替链表。默认值是8 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>由树转换成链表的阈值UNTREEIFY_THRESHOLD</p><p>当执行resize操作时，当桶中bin的数量少于UNTREEIFY_THRESHOLD时使用链表来代替树。默认值是6 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>MIN_TREEIFY_CAPACITY</p><p>当桶中的 bin 被树化时最小的 hash 表容量。（如果没有达到这个阈值，即 hash 表容量小于MIN_TREEIFY_CAPACITY，当桶中 bin 的数量太多时会执行 resize 扩容操作）这个 MIN_TREEIFY_CAPACITY 的值至少是 TREEIFY_THRESHOLD 的4倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>下边是非常重要的一个内部类 Node ，它实现了 Map.Entry，Node 是 HashMap 中的基本元素，每个键值对都储存在一个 Node 对象里， Node 类有四个成员变量：hash key 的哈希值、键值对 key 与 value，以及 next 指针。next 也是 Node 类型，这个 Node 指向的是链表下一个键值对，这也就是前文提到的 hash 冲突时 HashMap 的处理办法。</p><p>Node 类内部实现了 Map.Entry 接口中的 getKey()、getValue() 等方法，所以在遍历 Map 的时候我们可以用 Map.entrySet() 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="put-流程"><a href="#put-流程" class="headerlink" title="put() 流程"></a>put() 流程</h2><h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put() 方法"></a>put() 方法</h3><p>put() 主要是将 key 和 value 保存到 Node 数组中，HashMap 根据 key 的 hash 值来确定它的索引，源码里 put 方法将调用内部的 putVal() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap 在 put 键值对的时候会调用 hash() 方法计算 key 的 hash 值，hash() 方法会调用 Object 的 native 方法 hashCode() 并且将计算之后的 hash 值高低位做异或运算，以增加 hash 的复杂度。（Java 里一个 int 类型占 4 个字节，一个字节是 8 bit，所以下面源码中的 h 与 h 右移 16 位就相当于高低位异或）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="putAll-方法"><a href="#putAll-方法" class="headerlink" title="putAll() 方法"></a>putAll() 方法</h3><p>这部分是主要 put 的逻辑</p><ol><li><p>计算容量：根据 map 的 size 计算数组容量大小，如果元素数量也就是 size 大于数组容量 ×0.75，则对数组进行扩容，扩容到原来的 2 倍。</p></li><li><p>查找数据索引：根据 key 的 hash 值和数组长度找到 Node 数组索引。</p></li><li><p>储存：这里有以下几种情况（假设计算出的 hash 为 i，数组为 tab，变量以代码为例）</p><p>a. 当前索引为 null，直接 new 一个 Node 并存到数组里，tab[i]=newNode(hash, key, value, null)</p><p>b. 数组不为空，这时两个元素的 hash 是一样的，再调用 equals 方法判断 key 是否一致，相同，则覆盖当前的 value，否则继续向下判断</p><p>c. 上面两个条件都不满足，说明 hash 发生冲突，Java 8 里实现了红黑树，红黑树在进行插入和删除操作时通过特定算法保持二叉查找树的平衡，从而可以获得较高的查找性能。本篇也是基于 Java 8 的源码进行分析，在这里 HashMap 会判断当前数组上的元素 tab[i] 是否是红黑树，如果是，调用红黑树的 putTreeVal 的 put 方法，它会将新元素以红黑树的数据结构储存到数组中。</p></li></ol><p>如果以上条件都不成立，表明 tab[i] 上有其它 key 元素存在，并且没有转成红黑树结构，这时只需调用 tab[i].next 来遍历此链表，找到链表的尾然后将元素存到当前链表的尾部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"> Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"> <span class="comment">// 根据当前的map size计算容量大小capacity， 主要实现是在resize()中计算capacity，需要扩容的时候， 长度左移一位（二倍）</span></span><br><span class="line"> <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">     n = (tab = resize()).length;</span><br><span class="line"> <span class="comment">// 这里就是经常说的桶结构了， 看过HashMap介绍的都知道它的内部有不同的桶, 这个桶实际上就是一个链表结构</span></span><br><span class="line"> <span class="comment">// 在这个地方， HashMap先判断key所属的桶是否存在。 (n - 1) &amp; hash 相当于计算桶的序号， 根据桶序号来找到对应的桶</span></span><br><span class="line"> <span class="comment">// 这里的table 是HashMap的数组， 数组为空就新建一个数组 newNode(hash, key, value, null)</span></span><br><span class="line"> <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">     tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//数组不为空， 先判断key是否存在， 存在 就覆盖value</span></span><br><span class="line">     Node&lt;K,V&gt; e; K k;</span><br><span class="line">     <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">         ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">         e = p;</span><br><span class="line">     <span class="comment">// 如果此链表是红黑树结构（TreeNode）</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">         e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 循环当前链表， 找出p.next为空的位置就是链表的末端， 添加上</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">             <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123; </span><br><span class="line">                p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                 <span class="comment">// 这里会判断这个链表是否需要转换为红黑树链表</span></span><br><span class="line">                 <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                     treeifyBin(tab, hash);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                 ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             p = e;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">         V oldValue = e.value;</span><br><span class="line">         <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">             e.value = value;</span><br><span class="line">         afterNodeAccess(e);</span><br><span class="line">         <span class="keyword">return</span> oldValue;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ++modCount;</span><br><span class="line"> <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">     <span class="comment">// put之后，如果元素个数大于当前的数组容量了，进行数组扩容</span></span><br><span class="line">     resize();</span><br><span class="line"> afterNodeInsertion(evict);</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get() 方法"></a>get() 方法</h3><p>get() 方法会调用 getNode() 方法，这是 get() 的核心，getNode() 方法的两个参数分别是 hash 值和 key。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重点来看 getNode() 方法，前面讲到过，HashMap 是通过 key 生成的 hash 值来存储到数组的对应索引上，HashMap 在 get 的时候也是用这种方式来查找元素的。</p><ol><li>根据 hash 值和数组长度找到 key 对应的数组索引。</li><li>拿到当前的数组元素，也就是这个链表的第一个元素 first，先用 hash 和 equals() 判断是不是第一个元素，是的话直接返回，不是的话继续下面的逻辑。</li><li>不是链表的第一个元素，判断这个元素 first 是不是红黑树，如果是调用红黑树的 getTreeNode 方法来查询。</li><li>如果不是红黑树结构，从 first 元素开始遍历当前链表，直到找到要查询的元素，如果没有则返回 null。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// tab： HashMap的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">  Node&lt;K,V&gt; first, e;</span><br><span class="line">  <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 判断数组不为空， 桶不为空</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 先查询桶的第一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">      <span class="comment">// 不是第一个元素</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果是红黑树， 则用红黑树的方法查询</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">          <span class="comment">// 不是红黑树， 遍历桶， 直到找到对应的key， 返回</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">               <span class="comment">// 1. 判断hash值是否相等； </span></span><br><span class="line">               <span class="comment">// 2. 判断key相等。 防止hash碰撞发生</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-的扩容机制"><a href="#HashMap-的扩容机制" class="headerlink" title="HashMap 的扩容机制"></a>HashMap 的扩容机制</h2><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p><p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">  Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">  <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">  <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">    threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">  transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">  table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">  threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">  Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">  <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">    Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">        e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">        newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">        e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">      &#125;<span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p><p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p><p><img src="/Java基础十一-Map/jdk1.7扩容例图.png" alt="jdk1.7扩容例图"></p><p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p><p><img src="/Java基础十一-Map/hashMap 1.8 哈希算法例图1.png" alt="hashMap 1.8 哈希算法例图1"></p><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="/Java基础十一-Map/hashMap 1.8 哈希算法例图2.png" alt="hashMap 1.8 哈希算法例图2"></p><p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p><p><img src="/Java基础十一-Map/jdk1.8 hashMap扩容例图.png" alt="jdk1.8 hashMap扩容例图"></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order // 链表优化重hash的代码块</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                      <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                      <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                  <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><p>​    LinkedHashMap继承自HashMap，是Hash表和链表的实现，并且依靠着双向链表保证了迭代顺序是插入的顺序。如果 一个key重新插入到LinkedHashMap中，那么这个插入顺序是无效的，也就是说，如果m.put(K,V)时，调用m.containsKey(k),将会返回true，更新value值，但是顺序不变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TestLinkHashMap &#123;</span><br><span class="line">    public static  void main(String[] args)&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = new LinkedHashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;1&quot;,&quot;1&quot;);</span><br><span class="line">        map.put(&quot;2&quot;,&quot;2&quot;);</span><br><span class="line">        map.put(&quot;3&quot;,&quot;3&quot;);</span><br><span class="line">        //重新插入&quot;1&quot;</span><br><span class="line">        map.put(&quot;1&quot;,&quot;4&quot;);</span><br><span class="line"></span><br><span class="line">        for (Map.Entry&lt;String,Object&gt; entry:map.entrySet()) &#123;</span><br><span class="line">            System.out.println(&quot;key=&quot;+entry.getKey()+&quot; &quot;+&quot;value=&quot;+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>key=1 value=4<br>key=2 value=2<br>key=3 value=3</p></blockquote><p>从上面的程序我们可以看见，同一key的多次插入，并不会影响其顺序</p><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><p>循环双向链表的头部存放的是最久访问的节点或最先插入的节点，尾部为最近访问的或最近插入的节点，迭代器遍历方向是从链表的头部开始到链表尾部结束，在链表尾部有一个空的header节点，该节点不存放key-value内容，为LinkedHashMap类的成员属性，循环双向链表的入口；</p><p><img src="/Java基础十一-Map/LinkedHashMap的数据结构.png" alt="LinkedHashMap的数据结构"></p><p>它继承了HashMap的Node，Node基础上添加了before和after两个指针，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  Entry&lt;K,V&gt; before, after;</span><br><span class="line">  Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重要的属性"><a href="#重要的属性" class="headerlink" title="重要的属性"></a>重要的属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 双向链表的头部(eldest)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 双向链表的尾部(youngest)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  *accessOrder为true时，按访问顺序排序，false时，按插入顺序排序</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><h2 id="重点的方法"><a href="#重点的方法" class="headerlink" title="重点的方法"></a>重点的方法</h2><ol><li><p>LinkedHashMap的Entry是继承与Node类，也就是LinkedHashMap与HashMap的根本区别所在，Node是链表形式，只有next与下一个元素进行连接，而Entry的链表有before和after两个连接点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  Entry&lt;K,V&gt; before, after;</span><br><span class="line">  Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别是将节点变成Entry，并且按照链表方式将元素有序连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">  LinkedHashMap.Entry&lt;K,V&gt; p = <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">  linkNodeLast(p);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>afterNodeAccess方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">  LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">  <span class="comment">// 若访问顺序为true，且访问的对象不是尾结点</span></span><br><span class="line">  <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">    <span class="comment">// 向下转型，记录p的前后结点</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">      (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    <span class="comment">// p的后结点为空</span></span><br><span class="line">    p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果p的前结点为空</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">      <span class="comment">// a为头结点</span></span><br><span class="line">      head = a;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// p的前结点不为空</span></span><br><span class="line">      <span class="comment">// b的后结点为a</span></span><br><span class="line">      b.after = a;</span><br><span class="line">    <span class="comment">// p的后结点不为空</span></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">      <span class="comment">// a的前结点为b</span></span><br><span class="line">      a.before = b;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// p的后结点为空</span></span><br><span class="line">      <span class="comment">// 后结点为最后一个结点</span></span><br><span class="line">      last = b;</span><br><span class="line">    <span class="comment">// 若最后一个结点为空</span></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">      <span class="comment">// 头结点为p</span></span><br><span class="line">      head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// p链入最后一个结点后面</span></span><br><span class="line">      p.before = last;</span><br><span class="line">      last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尾结点为p</span></span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="comment">// 增加结构性修改数量</span></span><br><span class="line">    ++modCount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是说在进行put之后就算是对节点的访问了，那么这个时候就会更新链表，把最近访问的放到最后，保证链表。关键参数是accessOrder，这个参数只有在public LinkedHashMap(int initialCapacity, float loadFactor,boolean accessOrder) 中可以手动设置为true，其余时候都默认为false</p></li></ol><h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><h1 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Map 中的数据是以键值对（key - value）的形式存储的&lt;/li&gt;
&lt;li&gt;key - value 以 Entry 类型的对象实例存在&lt;/li&gt;
&lt;li&gt;可以通过 key 值快速的查找 value 值&lt;/li&gt;
&lt;li&gt;一个映射不能包含重复的键&lt;/li&gt;
&lt;li&gt;每个键最多只能映射到一个值&lt;/li&gt;
&lt;li&gt;当访问的值不在的时候，方法会抛出一个 NoSuchElementException 异常&lt;/li&gt;
&lt;li&gt;当对象的类型和 Map 里元素类型不兼容的时候，就会抛出一个 ClassCastException 异常&lt;/li&gt;
&lt;li&gt;当在不允许使用 Null 对象的 Map 中使用Null对象，会抛出一个 NullPointerException 异常&lt;/li&gt;
&lt;li&gt;当尝试修改一个只读的 Map 时，会抛出一个 UnsupportedOperationException 异常&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java基础十一-Set</title>
    <link href="https://cuizhe1023.github.io/2018/11/08/Java%E5%9F%BA%E7%A1%80%E5%8D%81%E4%B8%80-Set/"/>
    <id>https://cuizhe1023.github.io/2018/11/08/Java基础十一-Set/</id>
    <published>2018-11-08T15:36:18.000Z</published>
    <updated>2018-11-08T15:54:33.925Z</updated>
    
    <content type="html"><![CDATA[<p>Set 和 List 一样，也继承于 Collection，是集合的一种。和 List 不同的是，Set 内部实现是基于 Map 的，所以 Set取值时<strong>不保证</strong>数据和存入的时候顺序一致，并且不允许空值，不允许重复值。</p><p>Set主要有2个实现方式，一个是 TreeSet，另一个是 HashSet 。</p><a id="more"></a><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><ul><li>HashSet 是 Set 的一个重要实现类，称为哈希集</li><li>HashSet 中的元素无序并且不可以重复</li><li>HashSet 中只允许一个 null 元素</li><li>具有良好的存取和查找性能</li></ul><p>就如它的名字一样，HashSet 主要由 HashMap 实现</p><p>如果调用HashSet的无参构造函数，那么就会使用默认的HashMap，初始化Size为16，扩张系数为0.75</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span><br><span class="line"> * default initial capacity (16) and load factor (0.75).</span><br><span class="line"> */</span><br><span class="line">public HashSet() &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们简单的看一下 HashSet 的几个数据执行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the specified element to this set if it is not already present.</span></span><br><span class="line"><span class="comment"> * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if</span></span><br><span class="line"><span class="comment"> * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * If this set already contains the element, the call leaves the set</span></span><br><span class="line"><span class="comment"> * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be added to this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified</span></span><br><span class="line"><span class="comment"> * element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the specified element from this set if it is present.</span></span><br><span class="line"><span class="comment"> * More formally, removes an element &lt;tt&gt;e&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment"> * if this set contains such an element.  Returns &lt;tt&gt;true&lt;/tt&gt; if</span></span><br><span class="line"><span class="comment"> * this set contained the element (or equivalently, if this set</span></span><br><span class="line"><span class="comment"> * changed as a result of the call).  (This set will not contain the</span></span><br><span class="line"><span class="comment"> * element once the call returns.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o object to be removed from this set, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if the set contained the specified element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes all of the elements from this set.</span></span><br><span class="line"><span class="comment"> * The set will be empty after this call returns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the number of elements in this set (its cardinality).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of elements in this set (its cardinality)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an iterator over the elements in this set.  The elements</span></span><br><span class="line"><span class="comment"> * are returned in no particular order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an Iterator over the elements in this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConcurrentModificationException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，HashMap 的几个主要数据执行操作都是间接的调用了内部的 HashMap 的数据操作</p><p>HashSet 的值是 HashMap 的 key</p><p>HashMap 的 value 是写死的 PRESENT</p><p>所以遍历 HashSet 的值，也就是遍历 HashMap 的 KeyEntry</p><h2 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h2><p>HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 是按照哈希值来存的所以取数据也是按照哈希值取得。</p><p>HashSet 会通过元素的 hashcode（）和 equals 方法进行判断元素是否重复。</p><p>当你试图把对象加入 HashSet 时，HashSet 会使用对象的 hashCode 来判断对象加入的位置。同时也会与其他已经加入的对象的 hashCode 进行比较，如果没有相等的 hashCode，HashSet 就会假设对象没有重复出现。</p><p>简单一句话，<strong>如果对象的hashCode值是不同的，那么HashSet会认为对象是不可能相等的。</strong></p><p>因此我们自定义类的时候需要重写 hashCode，来确保对象具有相同的 hashCode 值。</p><p>如果元素(对象)的 hashCode 值相同,是不是就无法存入 HashSet 中了? 当然不是，HashSet 会继续用 equals 进行比较，如果 equals 为 true ，那么 HashSet 认为新加入的对象重复了，所以加入失败；如果 equals 为 false 那么HashSet 认为新加入的对象没有重复，新元素可以存入。</p><p><strong>总结</strong></p><p>元素的哈希值是通过元素的 hashcode 方法来获取的，HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较 equals 方法，如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。</p><p>哈希值相同 equals 为 false 的元素是怎么存储呢？就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer stuNum;</span><br><span class="line">    <span class="keyword">private</span> String stuName;</span><br><span class="line">    <span class="keyword">private</span> Integer stuAge;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Integer stuNum, String stuName, Integer stuAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stuNum = stuNum;</span><br><span class="line">        <span class="keyword">this</span>.stuName = stuName;</span><br><span class="line">        <span class="keyword">this</span>.stuAge = stuAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getStuNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stuNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuNum</span><span class="params">(Integer stuNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stuNum = stuNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStuName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stuName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuName</span><span class="params">(String stuName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stuName = stuName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getStuAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stuAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuAge</span><span class="params">(Integer stuAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stuAge = stuAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">"---equals---"</span> + o);</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">            Student s = (Student) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.stuName.equals(s.stuName) &amp;&amp; <span class="keyword">this</span>.stuAge.equals(s.stuAge);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hashCode is :"</span>+ <span class="keyword">this</span>.stuName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stuName.hashCode() + stuNum * <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"stuNum="</span> + stuNum +</span><br><span class="line">                <span class="string">", stuName='"</span> + stuName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", stuAge="</span> + stuAge +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="number">0001</span>,<span class="string">"Jack"</span>,<span class="number">18</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="number">0002</span>,<span class="string">"Mike"</span>,<span class="number">20</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="number">0003</span>,<span class="string">"Lucy"</span>,<span class="number">19</span>);</span><br><span class="line">        Student s4 = <span class="keyword">new</span> Student(<span class="number">0003</span>,<span class="string">"Lucy"</span>,<span class="number">19</span>);</span><br><span class="line">        Student s5 = <span class="keyword">new</span> Student(<span class="number">0003</span>,<span class="string">"Lucy"</span>,<span class="number">20</span>);</span><br><span class="line">        Student s6 = <span class="keyword">new</span> Student(<span class="number">0004</span>,<span class="string">"Lucy"</span>,<span class="number">20</span>);</span><br><span class="line">        set.add(s1);</span><br><span class="line">        set.add(s2);</span><br><span class="line">        set.add(s3);</span><br><span class="line">        set.add(s4);</span><br><span class="line">        set.add(s5);</span><br><span class="line">        set.add(s6);</span><br><span class="line"></span><br><span class="line">        Iterator it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>hashCode is :Jack<br>hashCode is :Mike<br>hashCode is :Lucy<br>hashCode is :Lucy<br>Student{stuNum=3, stuName=’Lucy’, stuAge=19}—equals—Student{stuNum=3, stuName=’Lucy’, stuAge=19}<br>hashCode is :Lucy<br>Student{stuNum=3, stuName=’Lucy’, stuAge=20}—equals—Student{stuNum=3, stuName=’Lucy’, stuAge=19}<br>hashCode is :Lucy<br>Student{stuNum=1, stuName=’Jack’, stuAge=18}<br>Student{stuNum=2, stuName=’Mike’, stuAge=20}<br>Student{stuNum=4, stuName=’Lucy’, stuAge=20}<br>Student{stuNum=3, stuName=’Lucy’, stuAge=19}<br>Student{stuNum=3, stuName=’Lucy’, stuAge=20}</p></blockquote><p>重写后的 hashCode 的判断依据是<code>this.stuName.hashCode() + stuNum * 4</code></p><p>重写后的 equals 中的判断依据是<code>this.stuName.equals(s.stuName) &amp;&amp; this.stuAge.equals(s.stuAge);</code></p><p>这里我们可以看到，因为 s3 和 s4 的 hashCode 相同，所以，会用 equals 进行比较，而 s3 和 s4 的 equals 也相同，那么 HashSet 认为新加入的对象重复了，所以加入失败。</p><p>而在判断 s3 和 s5 时， s3 和 s5 的 hashCode 相同，而 equals 不同，HashSet 认为新加入的对象没有重复，新元素可以存入。</p><p>s3 和 s6 比较的时候 hashCode 不同，直接判断是不同的对象，认为没有重复，可以存入。</p><h1 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h1><p>继承自 HashSet，只是实现了几个构造方法，并且这几个构造方法都是直接使用了父类的构造方法。</p><p>LinkedHashSet 所使用的父类构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty linked hash set.  (This package private</span></span><br><span class="line"><span class="comment"> * constructor is only used by LinkedHashSet.) The backing</span></span><br><span class="line"><span class="comment"> * HashMap instance is a LinkedHashMap with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the specified load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      loadFactor        the load factor of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      dummy             ignored (distinguishes this</span></span><br><span class="line"><span class="comment"> *             constructor from other int, float constructor.)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero, or if the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashSet 其他的构造方法（这里只举出一个）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * the specified initial capacity and default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash table</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有在 HashSet 的这个构造方法中，把 map 实例化 LinkedHashMap，而其他的构造方法则是把 map 实例化为HashMap 。所以 LinkedHashSet 的实现是通过 LinkedHashMap 实现的。</p><p><strong>注意：</strong>无论是 HashSet 还是 LinkedHashSet，它们本质上是一个值（Value）为同一 Object（即是源码中的PRESENT）的 Map。</p><p>LinkedHashSet 集合同样是根据元素的 hashCode 值来决定元素的存储位置，<strong>但是它同时使用链表维护元素的次序</strong>。这样使得元素看起来像是以插入顺序保存的，也就是说，<strong>当遍历该集合时候，LinkedHashSet 将会以元素的添加顺序访问集合的元素。</strong></p><p>LinkedHashSet 在迭代访问 Set 中的全部元素时，性能比 HashSet 好，但是插入时性能稍微逊色于 HashSet。</p><h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><p>TreeSet 和 HashMap 的处理方式相似，这里就不重复展开，区别的地方在于，TreeSet 是基于 TreeMap 实现的，TreeSet 是有序的。</p><p>我们先来看这么一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set set = <span class="keyword">new</span> TreeSet();</span><br><span class="line">        set.add(<span class="string">"cccc"</span>);</span><br><span class="line">        set.add(<span class="string">"dddd"</span>);</span><br><span class="line">        set.add(<span class="string">"aaaa"</span>);</span><br><span class="line">        set.add(<span class="string">"bbbb"</span>);</span><br><span class="line">        Iterator it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>aaaa<br>bbbb<br>cccc<br>dddd</p></blockquote><p>既然 TreeSet 可以自然排序,那么 TreeSet 必定是有排序规则的。</p><ul><li>让存入的元素自定义比较规则</li><li>给 TreeSet 指定排序规则</li></ul><p>方式一：元素自身具备比较性</p><p>元素自身具备比较性，需要元素实现 Comparable 接口，重写 compareTo 方法，也就是让元素自身具备比较性，这种方式叫做元素的自然排序也叫做默认排序。</p><p>方式二：容器具备比较性</p><p>当元素自身不具备比较性，或者自身具备的比较性不是所需要的。那么此时可以让容器自身具备。需要定义一个类实现接口 Comparator，重写 compare 方法，并将该接口的子类实例对象作为参数传递给 TreeMap 集合的构造方法。</p><p><strong>注意：</strong></p><ul><li><p>当 Comparable 比较方式和 Comparator 比较方式同时存在时，以 Comparator 的比较方式为主</p></li><li><p>在重写 compareTo 或者 compare 方法时，必须要明确比较的主要条件相等时要比较次要条件</p><p>假设姓名和年龄一致的人为相同的人，如果想要对人按照年龄的大小来排序，如果年龄相同的人，需要如何处理？不能直接 return 0，因为可能姓名不同（年龄相同姓名不同的人是不同的人）。此时就需要进行次要条件判断（需要判断姓名），只有姓名和年龄同时相等的才可以返回 0。</p><p>通过return 0来判断唯一性</p></li></ul><p><strong>为什么使用TreeSet存入字符串,字符串默认输出是按升序排列的？</strong></p><p>因为字符串实现了 Comparable 接口。字符串重写了该接口的 compareTo 方法,所以 String 对象具备了比较性。那么同样道理,我的自定义元素(例如 Person 类，Book 类)想要存入 TreeSet 集合,就需要实现该接口,也就是要让自定义对象具备比较性。</p><blockquote><p>存入 TreeSet 集合中的元素要具备比较性。</p><p>比较性要实现 Comparable 接口，重写该接口的 compareTo 方法</p></blockquote><p><strong>TreeSet 属于 Set 集合，该集合的元素是不能重复的，TreeSet 如何保证元素的唯一性？</strong></p><p>通过 compareTo 或者 compare 方法中的来保证元素的唯一性。</p><p>添加的元素必须要实现 Comparable 接口。当 compareTo() 函数返回值为0时，说明两个对象相等，此时该对象不会添加进来。</p><h2 id="让元素自身具备比较性"><a href="#让元素自身具备比较性" class="headerlink" title="让元素自身具备比较性"></a>让元素自身具备比较性</h2><p>也就是元素需要实现Comparable接口，覆盖compareTo 方法。这种方式也作为元素的自然排序，也可称为默认排序。年龄按照搜要条件，年龄相同再比姓名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer stuNum;</span><br><span class="line">    <span class="keyword">private</span> String stuName;</span><br><span class="line">    <span class="keyword">private</span> Integer stuAge;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Integer stuNum, String stuName, Integer stuAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stuNum = stuNum;</span><br><span class="line">        <span class="keyword">this</span>.stuName = stuName;</span><br><span class="line">        <span class="keyword">this</span>.stuAge = stuAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getStuNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stuNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuNum</span><span class="params">(Integer stuNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stuNum = stuNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStuName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stuName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuName</span><span class="params">(String stuName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stuName = stuName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getStuAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stuAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuAge</span><span class="params">(Integer stuAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stuAge = stuAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">"---equals---"</span> + o);</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">            Student s = (Student) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.stuName.equals(s.stuName) &amp;&amp; <span class="keyword">this</span>.stuAge.equals(s.stuAge);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hashCode is :"</span>+ <span class="keyword">this</span>.stuName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stuName.hashCode() + stuNum * <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"stuNum="</span> + stuNum +</span><br><span class="line">                <span class="string">", stuName='"</span> + stuName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", stuAge="</span> + stuAge +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Student s = (Student) o;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">"compareTo:"</span> + s);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stuAge &gt; s.stuAge)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stuAge &lt; s.stuAge)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stuName.compareTo(s.stuName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet ts = <span class="keyword">new</span> TreeSet();</span><br><span class="line">        ts.add( <span class="keyword">new</span> Student(<span class="number">0001</span>,<span class="string">"Jack"</span>,<span class="number">18</span>));</span><br><span class="line">        ts.add( <span class="keyword">new</span> Student(<span class="number">0002</span>,<span class="string">"Mike"</span>,<span class="number">20</span>));</span><br><span class="line">        ts.add( <span class="keyword">new</span> Student(<span class="number">0003</span>,<span class="string">"Lucy"</span>,<span class="number">19</span>));</span><br><span class="line">        ts.add( <span class="keyword">new</span> Student(<span class="number">0003</span>,<span class="string">"Lucy"</span>,<span class="number">19</span>));</span><br><span class="line">        ts.add( <span class="keyword">new</span> Student(<span class="number">0003</span>,<span class="string">"Lucy"</span>,<span class="number">20</span>));</span><br><span class="line">        ts.add( <span class="keyword">new</span> Student(<span class="number">0004</span>,<span class="string">"Lucy"</span>,<span class="number">20</span>));</span><br><span class="line">        System.out.println(ts);</span><br><span class="line">        System.out.println(ts.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>Student{stuNum=1, stuName=’Jack’, stuAge=18}compareTo:Student{stuNum=1, stuName=’Jack’, stuAge=18}<br>Student{stuNum=2, stuName=’Mike’, stuAge=20}compareTo:Student{stuNum=1, stuName=’Jack’, stuAge=18}<br>Student{stuNum=3, stuName=’Lucy’, stuAge=19}compareTo:Student{stuNum=1, stuName=’Jack’, stuAge=18}<br>Student{stuNum=3, stuName=’Lucy’, stuAge=19}compareTo:Student{stuNum=2, stuName=’Mike’, stuAge=20}<br>Student{stuNum=3, stuName=’Lucy’, stuAge=19}compareTo:Student{stuNum=3, stuName=’Lucy’, stuAge=19}<br>Student{stuNum=3, stuName=’Lucy’, stuAge=20}compareTo:Student{stuNum=3, stuName=’Lucy’, stuAge=19}<br>Student{stuNum=3, stuName=’Lucy’, stuAge=20}compareTo:Student{stuNum=2, stuName=’Mike’, stuAge=20}<br>Student{stuNum=4, stuName=’Lucy’, stuAge=20}compareTo:Student{stuNum=3, stuName=’Lucy’, stuAge=19}<br>Student{stuNum=4, stuName=’Lucy’, stuAge=20}compareTo:Student{stuNum=2, stuName=’Mike’, stuAge=20}<br>Student{stuNum=4, stuName=’Lucy’, stuAge=20}compareTo:Student{stuNum=3, stuName=’Lucy’, stuAge=20}<br>[Student{stuNum=1, stuName=’Jack’, stuAge=18}, Student{stuNum=3, stuName=’Lucy’, stuAge=19}, Student{stuNum=3, stuName=’Lucy’, stuAge=20}, Student{stuNum=2, stuName=’Mike’, stuAge=20}]</p><p>4</p></blockquote><h2 id="让容器自身具备比较性"><a href="#让容器自身具备比较性" class="headerlink" title="让容器自身具备比较性"></a>让容器自身具备比较性</h2><p>当元素自身不具备比较性，或者元素自身具备的比较性不是所需的。那么这时只能让容器自身具备。</p><p>定义一个类实现 Comparator 接口，覆盖 compare 方法。并将该接口的子类对象作为参数传递给 TreeSet 集合的构造函数。当 Comparable 比较方式，及 Comparator 比较方式同时存在，以 Comparator 比较方式为主。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Book&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", price="</span> + price +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        Book b1 = (Book) o1;</span><br><span class="line">        Book b2 = (Book) o2;</span><br><span class="line">        System.out.println(b1 + <span class="string">"compare"</span> + b2);</span><br><span class="line">        <span class="keyword">if</span> (b1.getPrice() &gt; b2.getPrice())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b1.getPrice() &lt; b2.getPrice())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b1.getName().compareTo(b2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet ts = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> MyComparator());</span><br><span class="line">        ts.add(<span class="keyword">new</span> Book(<span class="string">"think in java"</span>, <span class="number">100</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Book(<span class="string">"java 核心技术"</span>, <span class="number">75</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Book(<span class="string">"现代操作系统"</span>, <span class="number">50</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Book(<span class="string">"java就业教程"</span>, <span class="number">35</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Book(<span class="string">"think in java"</span>, <span class="number">100</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> Book(<span class="string">"ccc in java"</span>, <span class="number">100</span>));</span><br><span class="line">        System.out.println(ts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HashSet、LinkedHashSet-和-TreeSet-的区别"><a href="#HashSet、LinkedHashSet-和-TreeSet-的区别" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet 的区别"></a>HashSet、LinkedHashSet 和 TreeSet 的区别</h1><ul><li><p>底层存储的数据结构不同</p><p>HashSet 底层用的是 HashMap 哈希表结构存储，LinkedHashSet 继承自 HashSet 底层用的是 LinkedHashMap 链表结构存储， 而 TreeSet 底层用的是 TreeMap 树结构存储</p></li><li><p>存储时保证数据唯一性依据不同</p><p>HashSet 和 LinkedHashSet 是通过重写 hashCode() 方法和 equals() 方法来保证的，而 HashSet 通过 Compareable 接口的compareTo() 方法来保证的 </p></li><li><p>有序性不一样</p><p>HashSet 无序，LinkedHashSet 以元素的插入顺序，TreeSet 有序</p></li><li><p>线程安全</p><p>都不安全</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Set 和 List 一样，也继承于 Collection，是集合的一种。和 List 不同的是，Set 内部实现是基于 Map 的，所以 Set取值时&lt;strong&gt;不保证&lt;/strong&gt;数据和存入的时候顺序一致，并且不允许空值，不允许重复值。&lt;/p&gt;
&lt;p&gt;Set主要有2个实现方式，一个是 TreeSet，另一个是 HashSet 。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="集合" scheme="https://cuizhe1023.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="Set" scheme="https://cuizhe1023.github.io/tags/Set/"/>
    
  </entry>
  
  <entry>
    <title>Java基础十一-List</title>
    <link href="https://cuizhe1023.github.io/2018/11/08/Java%E5%9F%BA%E7%A1%80%E5%8D%81%E4%B8%80-List/"/>
    <id>https://cuizhe1023.github.io/2018/11/08/Java基础十一-List/</id>
    <published>2018-11-08T15:36:10.000Z</published>
    <updated>2018-11-08T15:54:15.470Z</updated>
    
    <content type="html"><![CDATA[<ul><li>List 是元素有序并且可以重复的集合，称为序列</li><li>List 可以精确的控制每个元素的插入位置，或删除某个位置的元素</li><li>List 的两个主要实现类，是 ArrayList 和 LinkedList</li></ul><a id="more"></a><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><ul><li>ArrayList 底层是由数组实现的</li><li>动态增长，以满足应用程序的需求</li><li>在列表尾部插入或删除非常有效</li><li>更适合查找和更新元素</li><li>ArrayList 中的元素可以为 NULL</li></ul><p>下面的例子介绍 ArrayList 的增删改查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">'a'</span>);</span><br><span class="line">        list.add(<span class="string">'b'</span>);</span><br><span class="line">        list.add(<span class="string">'c'</span>);</span><br><span class="line">        list.add(<span class="string">'d'</span>);</span><br><span class="line">        list.add(<span class="string">'e'</span>);</span><br><span class="line">        System.out.println(<span class="string">"list的长度为:"</span> + list.size());</span><br><span class="line">        System.out.println(<span class="string">"输出list中的第二个元素:"</span> + list.get(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"遍历list数组:"</span>);</span><br><span class="line">        System.out.println(<span class="string">"--第一种遍历方法---for循环"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.print(list.get(i) + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"--第二种遍历方法---foreach循环（修改第三个位置的数据）"</span>);</span><br><span class="line">        list.set(<span class="number">2</span>,<span class="string">'z'</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object i :</span><br><span class="line">                list) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"--第三种遍历方法---Iterator迭代器（去掉第二个位置的数据）"</span>);</span><br><span class="line">        list.remove(<span class="number">1</span>);</span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.print(iterator.next() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>list的长度为:5<br>输出list中的第二个元素:b<br>遍历list数组:<br>–第一种遍历方法—for循环<br>a b c d e<br>–第二种遍历方法—foreach循环（修改第三个位置的数据）<br>a b z d e<br>–第三种遍历方法—Iterator迭代器（去掉第二个位置的数据）<br>a z d e </p></blockquote><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><ul><li>与 ArrayList 一样，LinkedList 也按照索引位置排序，但它的元素之间是双向链表的</li><li>适合快速地插入和删除元素</li><li>LinkedList 实现 List 和 Queue 两个接口</li></ul><p>案例一：使用 LinkedList 对字符串进行管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//向链表添加数据</span></span><br><span class="line">        list.add(<span class="string">"apple"</span>);</span><br><span class="line">        list.add(<span class="string">"pear"</span>);</span><br><span class="line">        <span class="comment">//将数据插入链表头</span></span><br><span class="line">        list.addFirst(<span class="string">"banana"</span>);</span><br><span class="line">        <span class="comment">//将数据插入链表的末尾</span></span><br><span class="line">        list.addLast(<span class="string">"grape"</span>);</span><br><span class="line">        <span class="comment">//在指定位置添加数据</span></span><br><span class="line">        list.add(<span class="number">2</span>,<span class="string">"orange"</span>);</span><br><span class="line">        <span class="comment">//显示链表中的所有数据</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//判断链表中是否包含指定元素</span></span><br><span class="line">        <span class="keyword">if</span> (list.contains(<span class="string">"Mast"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"'Mast'存在"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"'Mast'不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回位置3的元素</span></span><br><span class="line">        System.out.println(<span class="string">"位置3的元素是："</span> + list.get(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//返回第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"第一个元素是："</span> + list.getFirst());</span><br><span class="line">        <span class="comment">//返回最后一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"最后一个元素是："</span> + list.getLast());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>[banana, apple, orange, pear, grape]<br>‘Mast’不存在<br>位置3的元素是：orange<br>第一个元素是：banana<br>最后一个元素是：grape</p></blockquote><p>案例二：使用 LinkedList 对自定义类进行管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer stuNum;</span><br><span class="line">    <span class="keyword">private</span> String stuName;</span><br><span class="line">    <span class="keyword">private</span> Integer stuAge;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Integer stuNum, String stuName, Integer stuAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stuNum = stuNum;</span><br><span class="line">        <span class="keyword">this</span>.stuName = stuName;</span><br><span class="line">        <span class="keyword">this</span>.stuAge = stuAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getStuNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stuNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuNum</span><span class="params">(Integer stuNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stuNum = stuNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStuName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stuName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuName</span><span class="params">(String stuName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stuName = stuName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getStuAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stuAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuAge</span><span class="params">(Integer stuAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stuAge = stuAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"stuNum="</span> + stuNum +</span><br><span class="line">                <span class="string">", stuName='"</span> + stuName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", stuAge="</span> + stuAge +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Student&gt; stulist = <span class="keyword">new</span> LinkedList&lt;Student&gt;();</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="number">0001</span>,<span class="string">"Jack"</span>,<span class="number">18</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="number">0002</span>,<span class="string">"Mike"</span>,<span class="number">20</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="number">0003</span>,<span class="string">"Lucy"</span>,<span class="number">19</span>);</span><br><span class="line">        <span class="comment">//将学生添加到链表，使用push完成</span></span><br><span class="line">        <span class="comment">//LinkedList 实现 List 接口的同时，也实现了 Queue 接口</span></span><br><span class="line">        <span class="comment">//push 和 pop 就是针对 Queue 进行添加和取出数据的操作</span></span><br><span class="line">        stulist.push(s1);</span><br><span class="line">        stulist.push(s2);</span><br><span class="line">        stulist.push(s3);</span><br><span class="line">        System.out.println(<span class="string">"链表为："</span> + stulist);</span><br><span class="line">        <span class="comment">//弹出一个元素，这里可以把链表看成一个容器，先加入链表里的元素后弹出</span></span><br><span class="line">        <span class="comment">//依据先进后出的原则</span></span><br><span class="line">        System.out.println(<span class="string">"弹出的数据为："</span> + stulist.pop());</span><br><span class="line">        System.out.println(<span class="string">"调用 pop() 方法后的链表为："</span> + stulist);</span><br><span class="line">        <span class="comment">//peek() 方法获取并不移除元素</span></span><br><span class="line">        System.out.println(<span class="string">"调用 peek() 方法的数据为："</span> + stulist.peek());</span><br><span class="line">        System.out.println(<span class="string">"调用 peek() 方法后的链表为："</span> + stulist);</span><br><span class="line">        <span class="comment">//再次调用 pop() 方法，发现调用 pop() 方法后，数据从链表中移除了而 peek() 方法不会</span></span><br><span class="line">        System.out.println(<span class="string">"弹出的数据为："</span> + stulist.pop());</span><br><span class="line">        System.out.println(<span class="string">"调用 pop() 方法后的链表为："</span> + stulist);</span><br><span class="line">        <span class="comment">//重新添加元素</span></span><br><span class="line">        stulist.push(s2);</span><br><span class="line">        stulist.push(s3);</span><br><span class="line">        System.out.println(<span class="string">"重新添加元素后的链表为："</span> + stulist);</span><br><span class="line">        <span class="comment">//调用 poll() 方法</span></span><br><span class="line">        System.out.println(<span class="string">"调用 poll() 方法的数据为："</span> + stulist.poll());</span><br><span class="line">        <span class="comment">//调用 poll() 方法在获取了元素的同时删除了链表中的元素</span></span><br><span class="line">        System.out.println(<span class="string">"调用 poll() 方法后的链表为："</span> + stulist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>链表为：[Student{stuNum=3, stuName=’Lucy’, stuAge=19}, Student{stuNum=2, stuName=’Mike’, stuAge=20}, Student{stuNum=1, stuName=’Jack’, stuAge=18}]<br>弹出的数据为：Student{stuNum=3, stuName=’Lucy’, stuAge=19}<br>调用 pop() 方法后的链表为：[Student{stuNum=2, stuName=’Mike’, stuAge=20}, Student{stuNum=1, stuName=’Jack’, stuAge=18}]<br>调用 peek() 方法的数据为：Student{stuNum=2, stuName=’Mike’, stuAge=20}<br>调用 peek() 方法后的链表为：[Student{stuNum=2, stuName=’Mike’, stuAge=20}, Student{stuNum=1, stuName=’Jack’, stuAge=18}]<br>弹出的数据为：Student{stuNum=2, stuName=’Mike’, stuAge=20}<br>调用 pop() 方法后的链表为：[Student{stuNum=1, stuName=’Jack’, stuAge=18}]<br>重新添加元素后的链表为：[Student{stuNum=3, stuName=’Lucy’, stuAge=19}, Student{stuNum=2, stuName=’Mike’, stuAge=20}, Student{stuNum=1, stuName=’Jack’, stuAge=18}]<br>调用 poll() 方法的数据为：Student{stuNum=3, stuName=’Lucy’, stuAge=19}<br>调用 poll() 方法后的链表为：[Student{stuNum=2, stuName=’Mike’, stuAge=20}, Student{stuNum=1, stuName=’Jack’, stuAge=18}]</p></blockquote><p>我们在这里发现，好像 pop() 和 poll() 的作用是一样的。</p><h2 id="pop-和-poll-的区别"><a href="#pop-和-poll-的区别" class="headerlink" title="pop() 和 poll() 的区别"></a>pop() 和 poll() 的区别</h2><p>poll是队列数据结构实现类的方法，从队首获取元素，同时获取的这个元素将从原队列删除；</p><p>pop是栈结构的实现类的方法，表示返回栈顶的元素，同时该元素从栈中删除，当栈中没有元素时，调用该方法会发生异常</p><p>其实，这两个函数的代码实现是基本一致的，如果一定要说区别那么就是当头结点为空的时候，两个函数的处理方式不同：poll()选择返回null，pop()选择抛出异常。</p><h1 id="ArrayList-和-LinkedList-的区别"><a href="#ArrayList-和-LinkedList-的区别" class="headerlink" title="ArrayList 和 LinkedList 的区别"></a>ArrayList 和 LinkedList 的区别</h1><ul><li><p>ArrayList 和 LinkedLis t可想从名字分析，它们一个是 Array（动态数组）的数据结构，一个是 Link（链表）的数据结构，此外，它们两个都是对 List 接口的实现。</p><p>前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列</p></li><li><p>当随机访问 List 时（ get 和 set 操作），ArrayList 比 LinkedList 的效率更高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p></li><li><p>当对数据进行增加和删除的操作时( add 和 remove 操作)，LinkedList 比 ArrayList 的效率更高，因为ArrayList 是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。</p></li><li><p>从利用效率来看，ArrayList 自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而 LinkedList 自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。</p></li><li><p>线程都不安全</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;List 是元素有序并且可以重复的集合，称为序列&lt;/li&gt;
&lt;li&gt;List 可以精确的控制每个元素的插入位置，或删除某个位置的元素&lt;/li&gt;
&lt;li&gt;List 的两个主要实现类，是 ArrayList 和 LinkedList&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="集合" scheme="https://cuizhe1023.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="List" scheme="https://cuizhe1023.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>Java基础十二--线程</title>
    <link href="https://cuizhe1023.github.io/2018/10/29/Java%E5%9F%BA%E7%A1%80%E5%8D%81%E4%BA%8C/"/>
    <id>https://cuizhe1023.github.io/2018/10/29/Java基础十二/</id>
    <published>2018-10-29T14:58:28.000Z</published>
    <updated>2018-10-29T15:00:15.704Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="多线程" scheme="https://cuizhe1023.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java基础十一--集合</title>
    <link href="https://cuizhe1023.github.io/2018/10/29/Java%E5%9F%BA%E7%A1%80%E5%8D%81%E4%B8%80/"/>
    <id>https://cuizhe1023.github.io/2018/10/29/Java基础十一/</id>
    <published>2018-10-29T14:58:23.000Z</published>
    <updated>2018-11-08T16:04:37.218Z</updated>
    
    <content type="html"><![CDATA[<p>在编程中，常常需要集中存放多个数据。从传统意义上讲，数组是我们的一个很好的选择，前提是我们事先已经明确知道我们将要保存的对象的数量。一旦在数组初始化时指定了这个数组长度，这个数组长度就是不可变的，如果我们需要保存一个可以动态增长的数据（在编译时无法确定具体的数量），Java 的集合类就是一个很好的设计方案了。</p><a id="more"></a><h1 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h1><p>collection是个接口，它下面有两个子接口分别是 List 和 Set。</p><p>List 又有三个类，ArrayList、LinkList和Vector</p><p>Set 又分为 HashSet、TreeSet</p><p>TreeSte是二叉树，有序的</p><p>HashSet采用散列存储，是无序的</p><h1 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h1><p>Map 集合使用键（key）值（value）来保存数据，其中值（value）可以重复，但键（key）必须是唯一，也可以为空，但最多只能有一个 key 为空，它的主要实现类有 HashMap、LinkedHashMap、TreeMap、Hashtable（过时了）。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在编程中，常常需要集中存放多个数据。从传统意义上讲，数组是我们的一个很好的选择，前提是我们事先已经明确知道我们将要保存的对象的数量。一旦在数组初始化时指定了这个数组长度，这个数组长度就是不可变的，如果我们需要保存一个可以动态增长的数据（在编译时无法确定具体的数量），Java 的集合类就是一个很好的设计方案了。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="集合" scheme="https://cuizhe1023.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="List、Set、Map" scheme="https://cuizhe1023.github.io/tags/List%E3%80%81Set%E3%80%81Map/"/>
    
  </entry>
  
  <entry>
    <title>Java基础十--泛型</title>
    <link href="https://cuizhe1023.github.io/2018/10/29/Java%E5%9F%BA%E7%A1%80%E5%8D%81/"/>
    <id>https://cuizhe1023.github.io/2018/10/29/Java基础十/</id>
    <published>2018-10-29T14:58:16.000Z</published>
    <updated>2018-10-31T14:26:07.127Z</updated>
    
    <content type="html"><![CDATA[<p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</p><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><a id="more"></a><blockquote><p>假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？</p><p>答案是可以使用 <strong>Java 泛型</strong>。</p><p>使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。</p></blockquote><h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><p>你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。</p><p>下面是定义泛型方法的规则：</p><ul><li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<t>）。</t></li><li>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。</li><li>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</li><li>泛型方法体的声明和其他方法一样。注意类型参数只能代表<strong>引用类型</strong>，不能是<strong>基本数据类型</strong>（像int,double,char的等）。</li></ul><p>下面的例子演示了如何使用泛型方法打印不同字符串的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T i :</span><br><span class="line">                arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义不同类型的数组</span></span><br><span class="line">        Integer[] i = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        Double[] d = &#123;<span class="number">2.1</span>,<span class="number">3.2</span>,<span class="number">4.7</span>,<span class="number">5.8</span>,<span class="number">6.7</span>&#125;;</span><br><span class="line">        Character[] c = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"整形数组元素："</span>);</span><br><span class="line">        printArray(i);</span><br><span class="line">        System.out.println(<span class="string">"双精度型数组元素："</span>);</span><br><span class="line">        printArray(d);</span><br><span class="line">        System.out.println(<span class="string">"字符型数组元素："</span>);</span><br><span class="line">        printArray(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>整形数组元素：<br>1  2  3  4  5  6<br>双精度型数组元素：<br>2.1  3.2  4.7  5.8  6.7<br>字符型数组元素：<br>a  b  c  d  e  f  g</p></blockquote><h2 id="有界的类型参数"><a href="#有界的类型参数" class="headerlink" title="有界的类型参数"></a>有界的类型参数</h2><p>可能有时候，你会想限制那些被允许传递到一个类型参数的类型种类范围。例如，一个操作数字的方法可能只希望接受Number或者Number子类的实例。这就是有界类型参数的目的。</p><p>要声明一个有界的类型参数，首先列出类型参数的名称，后跟extends关键字，最后紧跟它的上界。</p><p>下面的例子演示了”extends”如何使用在一般意义上的意思”extends”（类）或者”implements”（接口）。</p><p>该例子中的泛型方法返回三个可比较对象的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">maxNum</span><span class="params">(T x,T y,T z)</span></span>&#123;</span><br><span class="line">        T max = x;</span><br><span class="line">        <span class="keyword">if</span> (y.compareTo(x) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            max = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (z.compareTo(max) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            max = z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"3、4、5中最大的数是："</span> + maxNum(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">        System.out.println(<span class="string">"3.1f、4.5f、5.1f中最大的数是："</span> + maxNum(<span class="number">3.1f</span>,<span class="number">4.5f</span>,<span class="number">5.1f</span>));</span><br><span class="line">        System.out.println(<span class="string">"'A'、'a'、'C'中最大的数是："</span> + maxNum(<span class="string">'A'</span>,<span class="string">'a'</span>,<span class="string">'C'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>3、4、5中最大的数是：5<br>3.1f、4.5f、5.1f中最大的数是：5.1<br>‘A’、’a’、’C’中最大的数是：a</p></blockquote><hr><h1 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h1><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。</p><p>和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</p><p>如下实例演示了我们如何定义一个泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main&lt;Integer&gt; integerMain = <span class="keyword">new</span> Main&lt;Integer&gt;();</span><br><span class="line">        Main&lt;String&gt; stringMain = <span class="keyword">new</span> Main&lt;String&gt;();</span><br><span class="line">        integerMain.add(<span class="keyword">new</span> Integer(<span class="number">10</span>));</span><br><span class="line">        stringMain.add(<span class="keyword">new</span> String(<span class="string">"泛型"</span>));</span><br><span class="line">        System.out.println(<span class="string">"整型值为："</span>+integerMain.getT());</span><br><span class="line">        System.out.println(<span class="string">"字符串为："</span>+stringMain.getT());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>整型值为：10<br>字符串为：泛型</p></blockquote><h1 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h1><ul><li><p>类型通配符一般是使用 ? 代替具体的类型参数。例如 <strong>List&lt;?&gt;</strong> 在逻辑上是<strong>List<string>,List<integer></integer></string></strong> 等所有List&lt;具体类型实参&gt;的父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xerces.internal.xs.StringList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; name = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        List&lt;Integer&gt; age = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;Number&gt; number = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line"></span><br><span class="line">        name.add(<span class="string">"张三"</span>);</span><br><span class="line">        age.add(<span class="number">18</span>);</span><br><span class="line">        number.add(<span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">        getData(name);</span><br><span class="line">        getData(age);</span><br><span class="line">        getData(number);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(List&lt;?&gt; data)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"data："</span> + data.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>data：张三<br>data：18<br>data：3.14</p></blockquote><p>因为 getData() 方法的参数是 List 类型的，所以 name，age，number 都可以作为这个方法的实参，这就是通配符的作用。</p></li><li><p>类型通配符上限通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xerces.internal.xs.StringList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; name = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        List&lt;Integer&gt; age = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;Number&gt; number = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line"></span><br><span class="line">        name.add(<span class="string">"张三"</span>);</span><br><span class="line">        age.add(<span class="number">18</span>);</span><br><span class="line">        number.add(<span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getUperNumber(name);//因为 name 定义的时候是 String 类型，所以会报错</span></span><br><span class="line">        getUperNumber(age);</span><br><span class="line">        getUperNumber(number);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(List&lt;?&gt; data)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"data："</span> + data.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getUperNumber</span><span class="params">(List&lt;? extends Number&gt; data)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"data："</span> + data.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>data：18<br>data：3.14</p></blockquote><p>在注释处会出现错误，因为 getUperNumber() 方法中的参数已经限定了参数泛型上限为 Number，所以泛型为 String 是不在这个范围之内，所以会报错。</p></li><li><p>类型通配符下限通过形如 <strong>List&lt;? super Number&gt;</strong>来定义，表示类型只能接受Number及其三层父类类型，如Objec类型的实例。</p></li></ul><h2 id="lt-extends-T-gt-和-lt-super-T-gt-的区别"><a href="#lt-extends-T-gt-和-lt-super-T-gt-的区别" class="headerlink" title="&lt; ? extends T &gt;和&lt; ? super T &gt;的区别"></a>&lt; ? extends T &gt;和&lt; ? super T &gt;的区别</h2><ul><li><p>&lt; ? extends T &gt; 表示该通配符所代表的类型是T类型的子类。</p></li><li><p>&lt; ? super T &gt; 表示该通配符所代表的类型是T类型的父类。</p></li></ul><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>对于泛型，只是允许程序员在编译时检测到非法的类型而已。</p><p>但是在运行期时，其中的泛型标志会变化为 Object 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//list.add('a');//这么添加会报错</span></span><br><span class="line">        Class&lt; ? extends List&gt; clazz = list.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method add = clazz.getDeclaredMethod(<span class="string">"add"</span>, Object.class);<span class="comment">//但是通过反射添加是可以的</span></span><br><span class="line">            add.invoke(list,<span class="string">'a'</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>[12, a]</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。&lt;/p&gt;
&lt;p&gt;泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="泛型" scheme="https://cuizhe1023.github.io/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java基础九--字符串</title>
    <link href="https://cuizhe1023.github.io/2018/10/27/Java%E5%9F%BA%E7%A1%80%E4%B9%9D/"/>
    <id>https://cuizhe1023.github.io/2018/10/27/Java基础九/</id>
    <published>2018-10-27T09:13:02.000Z</published>
    <updated>2018-10-28T12:45:24.645Z</updated>
    
    <content type="html"><![CDATA[<p>字符串广泛应用在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String、StringBuffer、StringBuilder类来创建和操作字符串。</p><a id="more"></a><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"这是字符串1"</span>;</span><br><span class="line">        String s2 = <span class="keyword">new</span> String();<span class="comment">//这里创建了一个空字符串</span></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">"这是字符串3"</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>这是字符串1</p><p>这是字符串3</p></blockquote><p>String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，比如提供一个字符数组参数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] name = &#123;<span class="string">'C'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>,<span class="string">'n'</span>,<span class="string">'a'</span>&#125;;</span><br><span class="line">        String str = <span class="keyword">new</span> String(name);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>China</p></blockquote><p><strong>注意：</strong>String 类是不可改变的，所以你一旦创建了 String 对象，那么它的值就不能改了。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int length()</td><td>返回当前字符串的长度</td></tr><tr><td>int indexOf(int ch)</td><td>查找ch字符在该字符串中第一次出现的位置</td></tr><tr><td>int indexOf(String str)</td><td>查找str子字符串在该字符串中第一次出现的位置</td></tr><tr><td>int lastIndexOf(int ch)</td><td>查找ch字符在该字符串中最后一次出现的位置</td></tr><tr><td>int lastIndexOf(String str)</td><td>查找str子字符串在该字符串中最后一次出现的位置</td></tr><tr><td>String substring(int beginIndex)</td><td>获取从beginIndex位置开始到结束的子字符串</td></tr><tr><td>String substring(int beginIndex,int endIndex)</td><td>获取从beginIndex位置开始到endIndex位置的子字符串[beginIndex,endIndex)</td></tr><tr><td>String trim()</td><td>返回去除了前后空格的字符串</td></tr><tr><td>boolean equals(Object obj)</td><td>将该字符串与指定对象比较，返回true或者false</td></tr><tr><td>String toLowerCase()</td><td>将字符串转换为小写</td></tr><tr><td>String toUpperCase()</td><td>将字符串转换为大写</td></tr><tr><td>char charAt(int index)</td><td>获取字符串中指定位置的字符</td></tr><tr><td>String[] split(String regex,int li)</td><td>将字符串分割为子字符串，返回字符串数组</td></tr><tr><td>byte[] getBytes()</td><td>将该字符串转换为byte数组</td></tr></tbody></table><p>这里先介绍length()、charAt()、substring()、indexOf()、lastIndexOf()的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"Java编程基础，我喜欢Java编程"</span>;</span><br><span class="line">        System.out.println(<span class="string">"字符串长度："</span>+str.length());</span><br><span class="line">        System.out.println(<span class="string">"字符串中第5个位置是："</span>+str.charAt(<span class="number">5</span>));</span><br><span class="line">        System.out.println(<span class="string">"从4位置开始到结束的子字符串："</span>+str.substring(<span class="number">4</span>));</span><br><span class="line">        System.out.println(<span class="string">"从4位置开始到6位置结束的子字符串[4,6)："</span>+str.substring(<span class="number">4</span>,<span class="number">6</span>));</span><br><span class="line">        System.out.println(<span class="string">"查找“编程”在该字符串中第一次出现的位置："</span>+str.indexOf(<span class="string">"编程"</span>));</span><br><span class="line">        System.out.println(<span class="string">"查找“编程”在该字符串中最后一次出现的位置："</span>+str.lastIndexOf(<span class="string">"编程"</span>));</span><br><span class="line">        System.out.println(<span class="string">"从8位置开始，查找子串“编程”第一次出现的位置："</span>+str.indexOf(<span class="string">"编程"</span>, <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>字符串长度：18<br>字符串中第5个位置是：程<br>从4位置开始到结束的子字符串：编程基础，我喜欢Java编程<br>从4位置开始到6位置结束的子字符串：编程<br>查找“编程”在该字符串中第一次出现的位置：4<br>查找“编程”在该字符串中最后一次出现的位置：16<br>从8位置开始，查找子串“编程”第一次出现的位置：16</p></blockquote><p>字符串和 byte 数组之间相互转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"Java 编程 基础"</span>;</span><br><span class="line">        <span class="comment">//将字符串转换为 byte 数组，并打印输出</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> i :</span><br><span class="line">                bytes) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//将 byte 数组转换为字符串</span></span><br><span class="line">        String str1 = <span class="keyword">new</span> String(bytes);</span><br><span class="line">        System.out.println(str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>74 97 118 97 32 -25 -68 -106 -25 -88 -117 32 -27 -97 -70 -25 -95 -128<br>Java 编程 基础</p></blockquote><p>为什么会出现这么一堆东西？</p><p>这一堆数字其实就是字符串每一位所对应的ASCII码值，J的ASCII码值是74，a的ASCII码值是97，空格的ASCII码值是32，以此类推。那么负数是什么呢，因为默认用的是UTF-8编码，所以这里每三个负数对应一个汉字，即“编”对应-25 -68 -106，“程”对应-25 -88 -117。</p><p>在 String 中，除了有<code>String(byte[] bytes)</code>这个构造方法以外，还有一个构造方法<code>String(byte[] bytes,Charset charset)</code>，Charset 字符集。我们来看下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"Java 编程 基础"</span>;</span><br><span class="line">        <span class="comment">//将字符串转换为 byte 数组，并打印输出</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> i :</span><br><span class="line">                bytes) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//将 byte 数组转换为字符串</span></span><br><span class="line">        String str1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            str1 = <span class="keyword">new</span> String(bytes,<span class="string">"GBK"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>74 97 118 97 32 -25 -68 -106 -25 -88 -117 32 -27 -97 -70 -25 -95 -128<br>Java 缂栫▼ 鍩虹</p></blockquote><p>出现乱码了！为什么会这样？</p><p>这是因为 String 转 byte 数组的时候用的是UTF-8，而 byte 转 String 的时候用的却是 GBK，编码不统一导致的。</p><p>如果你就是想用 GBK 编码的话，可以这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"Java 编程 基础"</span>;</span><br><span class="line">        <span class="comment">//将字符串转换为 byte 数组，并打印输出</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bytes = str.getBytes(<span class="string">"GBK"</span>);<span class="comment">//byte[] getBytes(Charset charset) </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> i :</span><br><span class="line">                bytes) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//将 byte 数组转换为字符串</span></span><br><span class="line">        String str1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            str1 = <span class="keyword">new</span> String(bytes,<span class="string">"GBK"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>74 97 118 97 32 -25 -68 -106 -25 -88 -117 32 -27 -97 -70 -25 -95 -128<br>Java 编程 基础</p></blockquote><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>我们来看这么一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"string"</span>;</span><br><span class="line">        String s2 = <span class="string">"string"</span>;</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">"string"</span>);</span><br><span class="line">        String s4 = <span class="keyword">new</span> String(<span class="string">"string"</span>);</span><br><span class="line">        System.out.println(s1==s2);</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">        System.out.println(s1==s3);</span><br><span class="line">        System.out.println(s1.equals(s3));</span><br><span class="line">        System.out.println(s3==s4);</span><br><span class="line">        System.out.println(s3.equals(s4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>true<br>true<br>false<br>true<br>false<br>true</p></blockquote><p>为什么会出现这样的情况呢？当你用<code>String s1 = “string”;</code>创建字符串的时候，“string” 是存放在常量池里的。当你又用创建 s2 的时候，因为在常量池中已经存在了一个 “string”，所以 s2 里存放的是 “string” 中的内存地址。但当你用<code>String s3 = new String(“string”);</code>创建对象时，他是存放在堆内存的（实例化对象都是在堆内存中开辟空间）。每创建一个对象，它就开辟一个空间。</p><p><img src="/2018/10/27/Java基础九/String在内存中的存储.png" alt="String在内存中的存储"></p><hr><h1 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h1><p>前面有提到，String 是不可变的，一旦创建了 String 对象，那么它的值就不能改了。那么我们要是想要进行多次修改，就要用到 StringBuffer 和 StringBuilder 了。</p><p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p><p>StringBuilder 和 StringBuffer 之间最大的不同是在于 StringBuilder 的方法是线程不安全的（不能同步访问）。</p><p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder。然而在要求线程安全的情况下，必须要用 StringBuffer。</p><h2 id="StringBuilder的常用方法"><a href="#StringBuilder的常用方法" class="headerlink" title="StringBuilder的常用方法"></a>StringBuilder的常用方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String toString()</td><td>将StringBuilder对象转换为String对象</td></tr><tr><td>StringBuilder reverse()</td><td>将此字符序列用其反转形式取代</td></tr><tr><td>StringBuilder append()</td><td>追加内容到当前StringBuilder对象的末尾</td></tr><tr><td>StringBuilder delete()</td><td>移除此序列的子字符串中的字符。</td></tr><tr><td>StringBuilder insert()</td><td>将内容插入到StringBuilder对象的指定位置</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">"String"</span>);</span><br><span class="line">        System.out.println(<span class="string">"StringBuilder字符串为："</span>+str.toString();</span><br><span class="line">        System.out.println(<span class="string">"反转之后："</span>+str.reverse());</span><br><span class="line">        System.out.println(<span class="string">"再反转回来："</span>+str.reverse());</span><br><span class="line">        System.out.println(<span class="string">"在末尾添加“String”："</span>+str.append(<span class="string">"String"</span>));</span><br><span class="line">        System.out.println(<span class="string">"删除从6位置到12位置的字符[6,12)："</span>+str.delete(<span class="number">6</span>,<span class="number">12</span>));</span><br><span class="line">        System.out.println(<span class="string">"在位置5上加入“nnnnn”："</span>+str.insert(<span class="number">5</span>,<span class="string">"nnnnn"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>StringBuilder字符串为：String<br>反转之后：gnirtS<br>再反转回来：String<br>在末尾添加“String”：StringString<br>删除从6位置到12位置的字符[6,12)：String<br>在位置5上加入“nnnnn”：Strinnnnnng</p></blockquote><h2 id="String、StringBuffer和StringBuilder区别"><a href="#String、StringBuffer和StringBuilder区别" class="headerlink" title="String、StringBuffer和StringBuilder区别"></a>String、StringBuffer和StringBuilder区别</h2><h3 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h3><p>String 类中使用字符数组保存字符串，<code>private final char value[];</code>,所以 String 对象是不可变的。</p><p>StringBuffer 和 StringBuilder 是继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也使用字符数组保存字符串<code>char[] value;</code>没有被 final修饰，所以 StringBuffer 和 StringBuilder 都是可变的。</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>String 中的对象是不可变的，也就可以理解为常量，所以是线程安全的。</p><p>AbstractStringBuilder 是 StringBuffer 和 StringBuilder 的公共父类，定义了一些字符串的基本操作，如 append()、insert()、indexOf()等公共方法。</p><p>StringBuffer 对方法加了 synchronized 或者对调用的方法加了 synchronized，所以是线程安全的。</p><p>StringBuilder 并没有对方法加锁，所以是非线程安全的。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后指针指向新的 String</p><p>对象。</p><p>StringBuffer 每次都会对 StringBuffer 对象本身进行改变，而不是生成新的对象并改变对象的引用。</p><p>相同情况下，使用 StringBuilder 相比使用 StringBuffer 仅能获得10%-15%的性能提升，但是要冒着线程不安全的风险。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>String：操作少量的数据</p><p>StringBuilder：单线程下操作大量数据</p><p>StringBuffer：多线程下操作大量数据</p><hr><h1 id="和equals-方法"><a href="#和equals-方法" class="headerlink" title="==和equals()方法"></a>==和equals()方法</h1><h2 id=""><a href="#" class="headerlink" title="=="></a>==</h2><p>它的作用是比较两个对象的地址是不是相等的。即，判断两个对象是不是同一个对象。（基本数据类型\==比较的是值，引用数据类型\==比较的是内存地址）</p><h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><p>它的作用也是判断两个对象是否相等，但它一般有两种使用情况：</p><h3 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h3><p>类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象是，等价于通过“==”比较这两个对象。</p><h3 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h3><p>类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来判断两个对象的内容是否相等。若他们的内容相等，则返回 true（即，认为这两个对象是相等的）。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>);<span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>);<span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>;<span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>;<span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (a == b)&#123;<span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a == b"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (aa == bb)&#123;<span class="comment">//true</span></span><br><span class="line">            System.out.println(<span class="string">"aa == bb "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b))&#123;<span class="comment">//true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>)&#123;<span class="comment">//true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>aa == bb<br>aEQb<br>true</p></blockquote><p>说明：</p><ul><li>String 中的 equals() 方法是被重写过的，因为 Object 的 equals() 是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值</li><li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有，就把它赋给当前的引用，如果没有就在常量池中重新创建一个 String 对象。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字符串广泛应用在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String、StringBuffer、StringBuilder类来创建和操作字符串。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="String、StringBuffer、StringBuilder" scheme="https://cuizhe1023.github.io/tags/String%E3%80%81StringBuffer%E3%80%81StringBuilder/"/>
    
  </entry>
  
  <entry>
    <title>Java基础八--异常</title>
    <link href="https://cuizhe1023.github.io/2018/10/25/Java%E5%9F%BA%E7%A1%80%E5%85%AB/"/>
    <id>https://cuizhe1023.github.io/2018/10/25/Java基础八/</id>
    <published>2018-10-25T03:41:16.000Z</published>
    <updated>2018-10-26T09:10:38.258Z</updated>
    
    <content type="html"><![CDATA[<p>异常字面翻译就是“意外、例外”的意思，也就是说非正常情况。</p><p>在程序运行过程中，意外发生的情况，背离我们程序本身的意图的表现，都可以理解为异常</p><p>Java 中的异常本质上是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。</p><a id="more"></a><p>利用 Java 中的异常处理机制，我们可以更好地提升程序的健壮性</p><p>要理解 Java 异常处理是如何工作的，需要掌握以下三种类型的异常：</p><ul><li>检查型异常：最具代表的检查性异常时用户错误或问题引起的异常，这是我们无法预见的。例如要打开一个不存在的文件，一个异常就发生了，这些异常在编译时不能被简单的忽略。</li><li>运行时异常：运行时异常时可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略</li><li>错误：错误不是异常，而是脱离我们控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，他们在编译也检查不到。</li></ul><h1 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h1><p>在程序开发中，异常指不期而至的各种状况。他是一个事件，当发生在程序运行期间时，会干扰正常的指令流程。</p><p>在 Java 中，通过 Throwable 及其子类描述各种不同的异常类型</p><p><img src="/2018/10/25/Java基础八/Throwable及其子类.png" alt="Throwable及其子类"></p><p>Throwable 有两个重要的子类：Exception 和 Error</p><hr><h1 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h1><p>Error 是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而代表代码运行时 JVM 出现的问题</p><p>例如，Java 虚拟机运行错误，当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError</p><ul><li><p>这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。</p></li><li><p>对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。</p></li><li>因此我们编写程序时不需要关心这类异常</li></ul><hr><h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><p>Exception 是程序本身可以处理的异常。异常处理通常指针对这种类型异常的处理。</p><p>Exception 类的异常包括 unchecked exception（非检查型异常） 和 checked exception（检查型异常）</p><h2 id="unchecked-exception"><a href="#unchecked-exception" class="headerlink" title="unchecked exception"></a>unchecked exception</h2><ul><li><p>unchecked exception：编译器不要求强制处置的异常。</p></li><li><p>包含 RunntimeException 类及其子类异常</p></li><li><p>如 NullPointerException（空指针异常）、IndexOutOfBoundsException（下标越界异常）等，这些异常时unchecked exception。</p></li><li><p>Java 编译器不会检查这些异常，在程序中可以选择捕获处理，也可以不处理，照样正常编译通过</p></li></ul><h2 id="checked-exception"><a href="#checked-exception" class="headerlink" title="checked exception"></a>checked exception</h2><ul><li><p>checked exception：编译器要求必须处置的异常</p></li><li><p>是 RunntimeException 类及其子类以外，其他的 Exception 类的子类</p></li><li>如 IOException、SQLException 等</li><li>Java 编译器会检查这些异常，当程序中可能出现这类异常时，要求必须进行异常处理，否则编译不会通过</li></ul><hr><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>在 Java 应用程序中，异常处理机制为：抛出异常、捕获异常</p><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><ul><li>当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统</li><li>异常对象中包含了异常类型和异常出现时的程序状态等异常信息</li><li>运行时系统负责寻找处置异常的代码并执行</li></ul><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><ul><li>在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器</li><li>运行时系统从发生异常的方法开始，依次回查调用栈中的方法，当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器</li><li>当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着 Java 程序的终止</li><li>对于运行时异常、错误或可查异常，Java 技术所要求的的异常处理方式有所不同</li><li>总体来说，Java 规定：对于可查异常必捕获、或者声明抛出。允许忽略不可查的 RuntimeException 和 Error</li><li>简单的来说，异常总是先被抛出，后被捕获的</li></ul><h2 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h2><p>通过5个关键字来实现：try、catch、finally、throw、throws</p><p><img src="/2018/10/25/Java基础八/异常处理.PNG" alt="异常处理"></p><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//代码段1</span></span><br><span class="line">    <span class="comment">//产生异常的代码段2</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">    <span class="comment">//对异常进行处理的代码段3</span></span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//代码段4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h3><ul><li>使用 try-catch 块捕获并处理异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//代码段</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">    <span class="comment">//对异常进行处理的代码段</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//代码段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 try-catch 块捕获并处理异常——无异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//代码段（此处不会产生异常）</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">    <span class="comment">//对异常进行处理的代码段</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//代码段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/25/Java基础八/try-catch无异常.png" alt="try-catch无异常"></p><ul><li>使用 try-catch 块捕获并处理异常——有异常并能正常匹配处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//代码段1</span></span><br><span class="line">    <span class="comment">//产生异常的代码段2</span></span><br><span class="line">    <span class="comment">//代码段3</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">    <span class="comment">//对异常进行处理的代码段4</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//代码段5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/25/Java基础八/try-catch有异常且能处理.png" alt="try-catch有异常且能处理"></p><ul><li>使用 try-catch 块捕获并处理异常——有异常不能正常匹配处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//代码段1</span></span><br><span class="line">    <span class="comment">//产生异常的代码段2</span></span><br><span class="line">    <span class="comment">//代码段3</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">    <span class="comment">//对异常进行处理的代码段4</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//代码段5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/25/Java基础八/try-catch有异常但不能处理.png" alt="try-catch有异常但不能处理"></p><h3 id="多重-catch-块"><a href="#多重-catch-块" class="headerlink" title="多重 catch 块"></a>多重 catch 块</h3><ul><li>一旦某个 catch 捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个 tr-catch 语句结束。其他的 catch 子句不再有匹配和捕获异常类型的机会。</li><li>对于有多个 catch 子句的异常程序而言，应该尽量将捕获底层异常类的 catch 子句放在前面，同时尽量将捕获相对高层的异常类的 catch 子句放在后面。否则，捕获底层异常类 catch 子句将可能会被屏蔽。</li><li><p>引发多种类型的异常</p><ul><li><p>排列 catch 语句的顺序：先子类后父类</p></li><li><p>发生异常时按顺序逐个匹配</p><p><img src="/2018/10/25/Java基础八/多重catch块发生异常时按顺序逐个匹配.png" alt="多重catch块发生异常时按顺序逐个匹配"></p></li><li><p>只执行第一个与异常类型匹配的 catch 语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//代码段</span></span><br><span class="line">    <span class="comment">//产生异常（类型2）</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> e)&#123;</span><br><span class="line">    <span class="comment">//对异常处理的代码</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> e)&#123;</span><br><span class="line">    <span class="comment">//对异常处理的代码</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> e)&#123;</span><br><span class="line">    <span class="comment">//对异常处理的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//代码段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="try-ctach-finally"><a href="#try-ctach-finally" class="headerlink" title="try-ctach-finally"></a>try-ctach-finally</h3><ul><li><p>try 块后可以接零个或者多个 catch 块</p></li><li><p>如果没有 catch，则必须跟一个 finally 块</p></li><li><p>catch、finally可选</p><ul><li>语法组合：<ul><li>try-catch</li><li>try-finally</li><li>try-catch-finally</li><li>try-catch-catch-finally</li></ul></li></ul></li><li><p>在 try-catch 块后加入 finally 块</p><ul><li><p>是否发生异常都执行</p></li><li><p>不执行的唯一情况</p><p><img src="/2018/10/25/Java基础八/finally不执行的情况.png" alt="finally不执行的情况"></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通代码"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"try"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"catch"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p> 普通代码<br> try<br> catch</p></blockquote></li><li><p>一旦在 try 块或者 catch 块中加入 System.exit(1) 这个语句 finally 语句块将会强制终止执行</p><p>其实还要一种情况，当 try 块没有执行的话，finally 也不会被执行，也就是说，当一个方法在 try 块之前就返回了，那么他的 finally 块就不会被执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String str= method();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (a&lt;<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"finally 没有执行"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"普通代码"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"try"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"catch"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"finally 执行了"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>finally 没有执行</p></blockquote></li></ul></li></ul><ul><li><p>try-catch-finally的执行情况</p><p><img src="/2018/10/25/Java基础八/try-catch-finally的执行流程.png" alt="try-catch-finally的执行流程"></p></li></ul><hr><h1 id="实际应用中的经验与总结"><a href="#实际应用中的经验与总结" class="headerlink" title="实际应用中的经验与总结"></a>实际应用中的经验与总结</h1><ul><li>处理运行时异常时，采用逻辑去合理规避同时辅助 try-catch 处理</li><li>在多重 catch 块后面，可以加上 catch(Exception e)来处理可能会被遗漏的异常</li><li>对于不确定的代码，也可以加上 try-catch，处理潜在的异常</li><li>尽量去处理异常，切记只是简单地调用 printStackTrace() 去打印输出</li><li>具体如何处理异常，要根据不同的业务需求和异常类型去决定</li><li>尽量添加 finally 语句块去释放占用的资源</li><li>不执行 finally 块有两种方式<ul><li>try 语句没有被执行到，如在 try 语句之前 return 就返回了，这样 finally 语句就不会执行。这也说明了 finally 语句被执行的必要而非充分条件是：相应的 try 语句一定被执行到</li><li>在 try 块 catch 块中有 System.exit(0); 这样的语句。System.exit(0) 是终止 Java 虚拟机 JVM 的，连 JVM 都停止了，所有都结束了，当然 finally 语句也不会被执行到。</li></ul></li><li>在 try-catch-finally 中, 当 return 遇到 finally，return 对 finally 无效<ul><li>在try catch块里return的时候，finally也会被执行</li><li>finally 里的 return 语句会把 try catch 块里的 return 语句效果给覆盖掉</li></ul></li></ul><hr><h1 id="throw-amp-throws"><a href="#throw-amp-throws" class="headerlink" title="throw&amp;throws"></a>throw&amp;throws</h1><p>可以通过 throws 声明将要抛出何种类型的异常，通过 throw将产生的异常抛出</p><h2 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h2><ul><li><p>如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用 throws 子句来声明抛出异常</p></li><li><p>例如：汽车在运行时可能会出现故障，汽车本身没有办法处理这个故障，那就让开车的人来处理</p></li><li><p>throws 语句用在方法定义时声明该方法要抛出的异常类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception1，Exception2,...,ExceptionN</span>&#123;</span><br><span class="line">  <span class="comment">//可能产生异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当方法抛出异常列表中的异常时，方法不对这些类型及其子类类型的异常作处理，而抛向调用该方法的方法，由他去处理</p></li></ul><h3 id="throws的使用规则"><a href="#throws的使用规则" class="headerlink" title="throws的使用规则"></a>throws的使用规则</h3><ul><li>如果是不可检查异常（unchecked exception），即 Error 、RuntimeException 或他们的子类，那么可以不适用 throws 关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出</li><li>如果一个方法中可能出现可查异常，要么用 try-catch 语句捕获，要么用 throws 子句声明将它抛出，否则会导致编译错误</li><li>当抛出了异常，则该方法的调用者必须处理或者重新抛出该异常</li><li>当子类重写父类抛出异常的方法时，声明的异常必须是父类方法所声明异常的同类或子类</li></ul><h2 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h2><ul><li><p>throw 用来抛出一个异常</p><p>例如：throw new IOException();</p></li><li><p>trhow 抛出的只能是可抛出类 Throwable 或其子类的实例对象</p><p>例如：throw new String(“出错啦！”);//是错误的</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//代码段1</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> 异常类型();</span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">    <span class="comment">//对异常进行处理的代码段2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> throw 异常类型</span>&#123;</span><br><span class="line">  <span class="comment">//代码段1</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> 异常类型();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><ul><li>使用 Java 内置的异常类可以描述在编程时出现的大部分异常情况</li><li>也可以通过自定义异常描述特定业务产生的异常类型</li><li>所谓自定义异常，就是定义一个类，去继承 Throwable 类或者它的子类</li><li>如果希望写一个检查性异常类，则需要继承 Exception 类</li><li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类</li></ul><hr><h1 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h1><ul><li><p>有时候我们会捕捉一个异常后再抛出另一个异常</p></li><li><p>顾名思义就是：将异常发生的原因一个传一个穿起来，即把底层的异常信息传给上层，这样逐层抛出</p></li></ul><hr><h1 id="Java-常见异常类型及原因分析"><a href="#Java-常见异常类型及原因分析" class="headerlink" title="Java 常见异常类型及原因分析"></a>Java 常见异常类型及原因分析</h1><h1 id="常见的异常类型"><a href="#常见的异常类型" class="headerlink" title="常见的异常类型"></a>常见的异常类型</h1><table><thead><tr><th>异常类型</th><th>说明</th></tr></thead><tbody><tr><td>Exception</td><td>异常层次结构的父类</td></tr><tr><td>ArithmeticException</td><td>算术错误情形，如以零作除数</td></tr><tr><td>ArrayIndexOutOfBoundsException</td><td>数组下标越界</td></tr><tr><td>NullPointerException</td><td>尝试访问 null 对象成员</td></tr><tr><td>ClassNotFoundException</td><td>不能加载所需的类</td></tr><tr><td>IllegalArgumentException</td><td>方法接受到非法参数</td></tr><tr><td>ClassCastException</td><td>对象强制类型转换出错</td></tr><tr><td>NumberFormatException</td><td>数字格式转换异常，如把“abc”转换为数字</td></tr></tbody></table><h2 id="NullPointerException-异常"><a href="#NullPointerException-异常" class="headerlink" title="NullPointerException 异常"></a>NullPointerException 异常</h2><p>顾名思义，空指针异常，这可能是最常遇见的异常了。但是在 Java 中没有指针，怎么会有空指针异常呢？</p><p>在 C++ 中，声明的指针需要指向一个实例（通过 new 方法构造），这个指针可以理解为地址。在 Java 中，虽然没有指针，但是有引用（通常称为对象引用，一般直接说对象），引用也是要指向一个实例对象（通过 new 方法构造）的，从某种意义上说，Java 中的引用与 C++ 中的指针没有本质区别，不同的是，出于安全的目的，在 Java 中不能对引用进行操作，而在 C++ 中可以直接进行指针的运算。</p><p>所以这里的 NullPointerException 虽然不是真正的空指针异常，但本质上差不多，是因为引用没有指向具体的实例，所以当访问这个引用的时候就会产生这种异常。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"这是一个测试字符串"</span>;</span><br><span class="line">        System.out.println(str.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>9</p></blockquote><p>这段代码是没有问题的，但是如果改成下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(str.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>Exception in thread “main” java.lang.NullPointerException<br>​    at Main.main(Main.java:4)</p></blockquote><p>这就产生了 NullPointerException 异常了</p><h3 id="这种异常是如何产生的呢"><a href="#这种异常是如何产生的呢" class="headerlink" title="这种异常是如何产生的呢"></a>这种异常是如何产生的呢</h3><ul><li><p>把调用某个方法的返回值直接赋值给某个引用，然后调用这个引用的方法。在这种情况下，如果返回的值是Null，必然会产生 NullPointerException 异常。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String Name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        People p = <span class="keyword">null</span>;</span><br><span class="line">        p.setName(<span class="string">"张三"</span>);</span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：声明一个 People对象，并打印出该对象的 Name 值</p><p>说明：这个时候你的 p 就出现了空指针异常，因为你只是声明了 People 类型的对象，并没有创建对象，所以它的堆里面没有地址引用，切记你要用对象调用方法的时候，一定要先创建对象。</p></li><li><p>在方法体中调用参数的方法</p><p>如果调用方法的时候传递进来的值是 null，也要产生 NullPointerException 异常。</p><p>要避免程序产生这种异常，比较好的解决方法是在调用某个对象的方法时候判断这个对象是否可能为空，如果可能，则增加判断语句，例如上面的代码就可以写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        People p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = <span class="keyword">new</span> People();</span><br><span class="line">            p.setName(<span class="string">"张三"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            p.setName(<span class="string">"张三"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="ClassCastException-异常"><a href="#ClassCastException-异常" class="headerlink" title="ClassCastException 异常"></a>ClassCastException 异常</h2><p>从字面上看，是类型转换异常，通常是进行强制类型转换时候出现的错误。下面对产生 ClassCastException 异常的原因进行分析，然后给出这种异常的解决方法</p><h3 id="这种异常是如何产生的呢-1"><a href="#这种异常是如何产生的呢-1" class="headerlink" title="这种异常是如何产生的呢"></a>这种异常是如何产生的呢</h3><p>我们来看下面这段代码</p><p>这里 Animal 表示动物类，Dog 类表示狗类，Cat 类表示猫类，Dog 和 Cat 是 Animal 类的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Animal a1 = <span class="keyword">new</span> Dog();</span><br><span class="line">        Animal a2 = <span class="keyword">new</span> Cat();</span><br><span class="line">        Dog d1 = (Dog) a1;</span><br><span class="line">        Dog d2 = (Dog) a2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>Exception in thread “main” java.lang.ClassCastException: Cat cannot be cast to Dog<br>​    at Main.main(Main.java:6)</p></blockquote><p>第5行和第6行代码基本相同，从字面意思上来看都是把 Animal 强制转换为 Dog，但是第六行代码产生了 ClassCastException 异常，说 Cat cannot be cast to Dog 。</p><p>这下就很好理解了，我在 Java 基础七-多态里的<a href="https://cuizhe1023.github.io/2018/10/18/Java%E5%9F%BA%E7%A1%80%E4%B8%83/">向下转型</a>中有说到，因为 a1 本身就是 Dog 对象，所以它理所当然的可以转型为 Dog，a2 本身是 Cat 对象，所以它也理所当然的不能转为 Dog 。猫狗之间能互换吗？</p><p>从上面的例子可以看出，ClassCastException 是进行强制类型转换的时候产生的异常。</p><p>强制类型转换的前提是父类引用指向的对象的类型是子类的时候才可以进行强制类型转换，如果父类引用指向的对象类型不是子类的时候就会产生 ClassCastException 异常。</p><p>遇到这个异常该怎么办呢？如果你知道要访问的对象的具体类型，直接转换成该类型即可。如果不能确定类型可以通过下面的两种方式进行处理（假设对象为 o ）：</p><ul><li>通过<code>o.getClass().getName()</code>&gt;得到具体的类型，可以通过输出语句输出这个类型，然后根据类型进行具体的处理</li><li>通过<code>if(o instanceof 类型)</code>的语句来判断 o 的类型是什么</li></ul><h2 id="ArrayIndexOutOfBoundsException-异常"><a href="#ArrayIndexOutOfBoundsException-异常" class="headerlink" title="ArrayIndexOutOfBoundsException 异常"></a>ArrayIndexOutOfBoundsException 异常</h2><p>这是一个非常常见的异常，从名字上看是数组下标越界错误，解决这个异常的方法就是查看为什么数组下标越界。</p><p>下面有一个错误实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>1 2 3 4 5 Exception in thread “main” java.lang.ArrayIndexOutOfBoundsException: 5<br>​    at Main.main(Main.java:5)</p></blockquote><p>1.我们可以看到错误在第5行</p><p>2.发生错误的时候，下标的值是5</p><p>接下来，我们分析为什么下标值是5的会出错就可以了。</p><h2 id="NumberFormatException-异常"><a href="#NumberFormatException-异常" class="headerlink" title="NumberFormatException 异常"></a>NumberFormatException 异常</h2><p>数字转换异常，在把一个表示数字的字符串转换成数字类型的时候会后可能会报这个异常，原因是作为参数的字符串不是由数字组成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String num1 = <span class="string">"123"</span>;</span><br><span class="line">        String num2 = <span class="string">"123 "</span>;</span><br><span class="line">        System.out.println(Integer.parseInt(num1));</span><br><span class="line">        System.out.println(Integer.parseInt(num2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>123<br>Exception in thread “main” java.lang.NumberFormatException: For input string: “123 “<br>​    at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)<br>​    at java.lang.Integer.parseInt(Integer.java:580)<br>​    at java.lang.Integer.parseInt(Integer.java:615)<br>​    at Main.main(Main.java:6)</p></blockquote><p>这是因为 num2 后面有一个空格。</p><h2 id="堆栈溢出和内存溢出"><a href="#堆栈溢出和内存溢出" class="headerlink" title="堆栈溢出和内存溢出"></a>堆栈溢出和内存溢出</h2><p>在递归调用的时候可能会产生堆栈溢出的情况，因为递归调用的时候需要把调用的状态保存起来，如果递归的深度达到一定程度，将产生堆栈溢出的异常。</p><p>如果虚拟机内存比较小，而程序对内存要求比较高，则可能产生内存溢出错误</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;异常字面翻译就是“意外、例外”的意思，也就是说非正常情况。&lt;/p&gt;
&lt;p&gt;在程序运行过程中，意外发生的情况，背离我们程序本身的意图的表现，都可以理解为异常&lt;/p&gt;
&lt;p&gt;Java 中的异常本质上是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="异常" scheme="https://cuizhe1023.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构一--数组</title>
    <link href="https://cuizhe1023.github.io/2018/10/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/"/>
    <id>https://cuizhe1023.github.io/2018/10/23/数据结构一/</id>
    <published>2018-10-23T13:33:42.000Z</published>
    <updated>2018-10-25T03:31:43.615Z</updated>
    
    <content type="html"><![CDATA[<p>所谓数组，就是<strong>相同类型的数据</strong>按照<strong>顺序</strong>组成的一种引用数据类型。</p><a id="more"></a><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。</p><p>Java 语言中提供的数组是用来存储固定大小的同类型元素。</p><h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><p>在 Java 中有两种声明数组的方式</p><ul><li><p>type[] 变量名</p><p>int[] myIntArray;    //首选的方法</p></li><li><p>type 变量名[]</p><p>int myIntArray[];    //效果相同，但不是首选的方法</p></li></ul><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>Java 中使用 new 操作符来创建数组</p><ul><li><p>语法格式一：先声明后创建</p><p>type[] 变量名;</p><p>变量名 = new type[数组中元素的个数];</p><p>int[] arr;</p><p>arr = new int[10];</p><p>创建一个长度为10的数组</p></li><li><p>语法格式二：声明的同时创建数组</p><p>type 变量名[] = new type[数组中元素的个数];</p><p>int[] arr = new int[10]；</p><p>创建一个长度为10的数组</p></li></ul><p><strong>注意：</strong>数组长度必须指定</p><blockquote><p>以上两种方式都叫做动态初始化，也就是说，只有在程序运行之后，你才能知道数组里到底存了那些数据。</p><p>语法格式二的命名方式 C 和 C++ 程序员比较熟悉，但是 Java 官方推荐使用第一种，一看知道是 int 型数组，叫 arr。</p></blockquote><ul><li><p>静态初始化：int[] arr = new int[]{1,2,3};</p><p>在定义的时候直接初始化，大括号里就是数组的值</p></li><li><p>隐式初始化：数据类型[] 数组名 = {value0，value1…valuek};</p><p>可以不写 new ,直接使用大括号，其实本质上还是调用了 new 的，只是可以不写出来而已，所以叫隐式初始化。</p></li></ul><blockquote><p>我们回过头来看看下面这句代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]；</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这句代码都做了什么？</p><blockquote><p>1.int[] arr：定义了一个 int 型数组的引用，名字叫做 arr，存放在栈中</p><p>2.new int[10]：初始化了一个长度为10的 int 型数组，在堆中开辟相应大小的内存</p><p>3.int[] arr = new int[10]：将堆中开辟的数组内存地址赋值给数组引用 arr</p></blockquote><p>这样，就可以通过 arr 这个变量，来操作这个数组了</p><p>是不是觉得这个过程很熟悉？没错！我们创建对象的过程也是这样的！那是不是证明，数组其实是一个对象呢？</p><p><strong>也没错！</strong> Java 中的数组的确是一个对象，但是是一个特殊的对象，实在是太特殊了，以致我们都不好把它多做对象处理。</p><p>这个数组对象并不是从某个类实例化来的，而是由JVM直接创建的，因此查看类名的时候会发现是很奇怪的样子，这个直接创建的对象的父类就是Object，所以可以调用Object中的所有方法，包括你用到的toString()。</p><h2 id="数组在内存中的存储"><a href="#数组在内存中的存储" class="headerlink" title="数组在内存中的存储"></a>数组在内存中的存储</h2><p>数组会被分配连续的内存空间</p><p>比如，我们定义一个数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 定义数组</span></span><br><span class="line">        <span class="keyword">double</span>[] myList = <span class="keyword">new</span> <span class="keyword">double</span>[size];</span><br><span class="line">        myList[<span class="number">0</span>] = <span class="number">5.6</span>;</span><br><span class="line">        myList[<span class="number">1</span>] = <span class="number">4.5</span>;</span><br><span class="line">        myList[<span class="number">2</span>] = <span class="number">3.3</span>;</span><br><span class="line">        myList[<span class="number">3</span>] = <span class="number">13.2</span>;</span><br><span class="line">        myList[<span class="number">4</span>] = <span class="number">4.0</span>;</span><br><span class="line">        myList[<span class="number">5</span>] = <span class="number">34.33</span>;</span><br><span class="line">        myList[<span class="number">6</span>] = <span class="number">34.0</span>;</span><br><span class="line">        myList[<span class="number">7</span>] = <span class="number">45.45</span>;</span><br><span class="line">        myList[<span class="number">8</span>] = <span class="number">99.993</span>;</span><br><span class="line">        myList[<span class="number">9</span>] = <span class="number">11123</span>;</span><br><span class="line">        <span class="comment">// 计算所有元素的总和</span></span><br><span class="line">        <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            total += myList[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"总和为： "</span> + total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它在内存空间中的存储如下图所示：</p><p><img src="/2018/10/23/数据结构一/数组在内存中的存储.jpg" alt="数组在内存中的存储"></p><p>若数组没有赋值，则整型数组的默认值为0，其他类型的数组按照数据类型确定数组的默认值。</p><h1 id="处理数组"><a href="#处理数组" class="headerlink" title="处理数组"></a>处理数组</h1><p>数组的元素类型和数组的大小都是确定的，所以当处理数组元素的时候，我们通常用基本循环或者 foreach 循环</p><p>下面的例子就展示了数组的创建、初始化和操纵数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] myList = &#123;<span class="number">1.9</span>, <span class="number">2.9</span>, <span class="number">3.5</span>, <span class="number">3.4</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"打印数组："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myList.length; i++) &#123;</span><br><span class="line">            System.out.print(myList[i] + <span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"计算所有元素的和"</span>);</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myList.length; i++) &#123;</span><br><span class="line">            sum += myList[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"数组myList元素的和为："</span> + sum);</span><br><span class="line">        <span class="keyword">double</span> max = myList[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myList.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max&lt;myList[i])&#123;</span><br><span class="line">                max = myList[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"数组myList中的最大值为："</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>打印数组：<br>1.9  2.9  3.5  3.4<br>计算所有元素的和<br>数组myList元素的和为：11.700000000000001<br>数组myList中的最大值为：3.5</p></blockquote><h2 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h2><p>foreach 循环可以在不适用下标的情况下遍历数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] myList = &#123;<span class="number">1.9</span>, <span class="number">2.9</span>, <span class="number">3.5</span>, <span class="number">3.4</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"打印数组："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> i :</span><br><span class="line">                myList) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>打印数组：<br>1.9  2.9  3.5  3.4  </p></blockquote><h2 id="数组作为函数的参数"><a href="#数组作为函数的参数" class="headerlink" title="数组作为函数的参数"></a>数组作为函数的参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] myList = &#123;<span class="number">1.9</span>, <span class="number">2.9</span>, <span class="number">3.5</span>, <span class="number">3.4</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"打印数组:"</span>);</span><br><span class="line">        printArray(myList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">double</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> i :</span><br><span class="line">                arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>打印数组:<br>1.9  2.9  3.5  3.4  </p></blockquote><h2 id="数组作为函数的返回值"><a href="#数组作为函数的返回值" class="headerlink" title="数组作为函数的返回值"></a>数组作为函数的返回值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] myList = &#123;<span class="number">1.9</span>, <span class="number">2.9</span>, <span class="number">3.5</span>, <span class="number">3.4</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"打印数组:"</span>);</span><br><span class="line">        <span class="keyword">double</span>[] result = reverse(myList);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> i :</span><br><span class="line">                result) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] reverse(<span class="keyword">double</span>[] list) &#123;</span><br><span class="line">        <span class="keyword">double</span>[] result = <span class="keyword">new</span> <span class="keyword">double</span>[list.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = result.length - <span class="number">1</span>; i &lt; list.length; i++, j--) &#123;</span><br><span class="line">            result[j] = list[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>打印数组:<br>3.4  3.5  2.9  1.9  </p></blockquote><h2 id="数组内容的比较"><a href="#数组内容的比较" class="headerlink" title="数组内容的比较"></a>数组内容的比较</h2><p>数组内容的比较可以通过 equals() 吗？我们先来看个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(a.equals(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>false</p></blockquote><p>所以，不能直接用 equals() 比较数组内容。那么该怎么比较呢？</p><p>有两种方法：一种是自己实现，另一种是利用 Arrays。</p><p>Arrays 中的方法全是static的。其中包括了 equals() 方法的各种重载版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEquals</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a==<span class="keyword">null</span> || b==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.length!=b.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i]!=b[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(isEquals(a,b));</span><br><span class="line">        System.out.println(Arrays.equals(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>true<br>true</p></blockquote><h2 id="Arrays类的使用"><a href="#Arrays类的使用" class="headerlink" title="Arrays类的使用"></a>Arrays类的使用</h2><p>Arrays 能方便的操作数组，他提供的方法都是静态的。</p><p>具有以下功能</p><ul><li>对数组赋值：通过 fill 方法</li><li>对数组排序：用过 sort 方法，按升序。</li><li>比较数组：通过 equals 方法，比较数组中的元素是否相等</li><li>查找数组元素：通过 binarySearch 方法能对<strong>排序好的数组</strong>进行二分查找。</li><li>…….</li></ul><hr><h1 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h1><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。</p><p>其实 Java 只有一维数组，但是由于数组可以存放任意类型的数据，当然也就可以存放数组了，这个时候，就可以模拟多维数组了。</p><p>基本的定义方法同样有两种</p><blockquote><p>type[][] i = new type[2][3];//（推荐）</p><p>type i[][] = new type[2][3];//（推荐）</p></blockquote><h2 id="变长的二维数组"><a href="#变长的二维数组" class="headerlink" title="变长的二维数组"></a>变长的二维数组</h2><p>二维数组的每个元素是一个一维数组，这些数组不一定都是等长的。</p><p>声明二维数组的时候可以只指定第一维的大小，空缺处第二维的大小，之后在指定不同长度的数组。但是注意，第一维大小不能空缺（可以指定行数不指定列数，不能只指定列数不指定行数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维数组也可以在定义的时候初始化，使用花括号的嵌套完成，这时候不指定两个维数的大小，并且根据初始化值的个数不同，可以生成不同长度的数组元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>&#125;,&#123;<span class="number">7</span>,&#125;,&#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>有时候，你需要一个方法，但是你调用它之前不知道要传递几个参数给它，这个时候你就需要可变参数了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(add(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">        System.out.println(add(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> ...args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            sum = sum + args[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那个奇怪的<code>int ...args</code>就是可变参数，这样你就可以传递任意个你想传递的数据了。</p><p>java把可变参数当做数组处理。</p><blockquote><p><strong>注意：</strong>可变参数必须位于最后一项。当可变参数个数多余一个时，必将有一个不是最后一项，所以只支持有一个可变参数。因为参数个数不定，所以当其后边还有相同类型参数时，java无法区分传入的参数属于前一个可变参数还是后边的参数，所以只能让可变参数位于最后一项。</p></blockquote><h1 id="面试中关于数组的常见问题"><a href="#面试中关于数组的常见问题" class="headerlink" title="面试中关于数组的常见问题"></a>面试中关于数组的常见问题</h1><h2 id="寻找数组中第二小的元素"><a href="#寻找数组中第二小的元素" class="headerlink" title="寻找数组中第二小的元素"></a>寻找数组中第二小的元素</h2><p>1.做容易想到的方法，先排序，然后找到第二个数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] array=&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">31</span>,<span class="number">27</span>,<span class="number">27</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"第二大的是:"</span> + FindSecMax(array));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FindSecMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> sec_max = arr[arr.length-<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> sec_max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>第二大的是:27</p></blockquote><p>不过这个方法的时间复杂度和空间复杂度都比较大。</p><p>2.先定义两个变量：一个变量用来存储数组的最大数，初始值为数组首元素，另一个变量用来存储第二大的数，初始值为最小负整数，然后遍历数组元素，如果数组元素的值比最大数变量还大，更新最大数；若数组元素的值比最大值还小，则与第二大的数比较，若该数比第二大数大，则更新第二大的数；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] array=&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">31</span>,<span class="number">27</span>,<span class="number">27</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"第二大的是:"</span> + FindSecMax(array));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FindSecMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sec_max=Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&gt;max)&#123;</span><br><span class="line">                sec_max = max;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i]&gt;sec_max)&#123;</span><br><span class="line">                    sec_max = arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sec_max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>第二大的是:27</p></blockquote><h2 id="合并两个数组"><a href="#合并两个数组" class="headerlink" title="合并两个数组"></a>合并两个数组</h2><p>不管数组有没有顺序，都有一个统一的思路：定义一个新数组，长度为两个数组长度之和，然后对新数组排序</p><ul><li>如果数组是有序的<ul><li>定义一个新数组，长度为两个数组长度之和</li><li>分别定义 i：a数组下标, j：b数组下标, k：新数组下标</li><li>按位循环比较两个数组，较小元素的放入新数组，下标加一（较大元素对应的下标不加一），直到某个小标等于数组长度时退出循环</li><li>再写两个 while 循环来保证两个数组作比较完后剩下的数组还能顺利传入</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[] arrayA=&#123;1,8,3,6,9,3,5,7,2,6,18,19,20,20,31,27,27&#125;;</span></span><br><span class="line"><span class="comment">//        int[] arrayB = &#123;37,3,8,85,87,44,22,39,40,80,58,10,69,75,90&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] arrayA = &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arrayB = &#123;<span class="number">37</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">85</span>,<span class="number">87</span>&#125;;</span><br><span class="line">        Arrays.sort(arrayA);</span><br><span class="line">        Arrays.sort(arrayB);</span><br><span class="line">        System.out.print(<span class="string">"arrayA："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i :</span><br><span class="line">                arrayA) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.print(<span class="string">"arrayB："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i :</span><br><span class="line">                arrayB) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并两个有序数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arrayC = combineSortedArray(arrayA,arrayB);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.print(<span class="string">"arrayC："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i :</span><br><span class="line">                arrayC) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] combineSortedArray(<span class="keyword">int</span>[] arrA, <span class="keyword">int</span>[] arrB)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arrA == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arrB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arrB == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arrA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] arrayC = <span class="keyword">new</span> <span class="keyword">int</span>[arrA.length+arrB.length];</span><br><span class="line">        System.out.println(arrayC.length);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; arrA.length &amp;&amp; j &lt; arrB.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arrA[i] &lt;= arrB[j])&#123;</span><br><span class="line">                arrayC[k++] = arrA[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                arrayC[k++] = arrB[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i&lt; arrA.length)&#123;</span><br><span class="line">            arrayC[k++] = arrA[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j&lt; arrB.length)&#123;</span><br><span class="line">            arrayC[k++] = arrB[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayC;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果数组是无序的<ul><li>将两个数组分别排序，然后按照上面的思路</li></ul></li></ul><h2 id="重新排列数组中的正值和负值"><a href="#重新排列数组中的正值和负值" class="headerlink" title="重新排列数组中的正值和负值"></a>重新排列数组中的正值和负值</h2><p>给定一个包含正数和负数的整数数组，重新排列它，使得所有的负数排在前面，所有的正数排在后面。正数间和负数间的相对顺序保持不变。</p><p>eg： 给定 [-1,2,-2,3,5,-4], 重新排列后变成 [-1,-2,-4,2,3,5]</p><ul><li>思路一：先遍历第一遍，将负数挑出来放在一个新的数组中，再遍历一遍，将正数放进去</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arrayA = &#123;<span class="number">1</span>,<span class="number">7</span>,-<span class="number">5</span>,-<span class="number">12</span>,-<span class="number">13</span>,<span class="number">99</span>,-<span class="number">6</span>,<span class="number">31</span>,<span class="number">15</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arrayB = positiveAndMinus(arrayA);</span><br><span class="line">        System.out.println(Arrays.toString(arrayB));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] positiveAndMinus(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                result[j] = arr[i];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                result[j] = arr[i];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>思路二：冒泡排序的一种改进，将负数逐个“冒”出来。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[]x=&#123;<span class="number">1</span>,<span class="number">7</span>,-<span class="number">5</span>,-<span class="number">12</span>,-<span class="number">13</span>,<span class="number">99</span>,-<span class="number">6</span>,<span class="number">31</span>,<span class="number">15</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x.length-<span class="number">1</span>;i&gt;p;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x[i]&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j=i;</span><br><span class="line">                <span class="keyword">while</span>(j!=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> t=x[j];</span><br><span class="line">                    x[j]=x[j-<span class="number">1</span>];</span><br><span class="line">                    x[j-<span class="number">1</span>]=t;<span class="comment">//交换</span></span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> i--;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓数组，就是&lt;strong&gt;相同类型的数据&lt;/strong&gt;按照&lt;strong&gt;顺序&lt;/strong&gt;组成的一种引用数据类型。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://cuizhe1023.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数组" scheme="https://cuizhe1023.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="数据结构" scheme="https://cuizhe1023.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java基础七--内部类</title>
    <link href="https://cuizhe1023.github.io/2018/10/22/Java%E5%9F%BA%E7%A1%80%E4%B8%83-%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>https://cuizhe1023.github.io/2018/10/22/Java基础七-内部类/</id>
    <published>2018-10-22T14:07:13.803Z</published>
    <updated>2018-10-23T09:39:36.472Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。</p><p>与之对应，包含内部类的类被称为外部类。</p><a id="more"></a><p>一般来说，内部类有四种：</p><ul><li>成员内部类</li><li>局部内部类</li><li>匿名内部类</li><li>静态内部类</li></ul><h1 id="为什么要使用内部类"><a href="#为什么要使用内部类" class="headerlink" title="为什么要使用内部类"></a>为什么要使用内部类</h1><p>在《Think in java》中有这样一句话：<strong>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</strong></p><p>在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，<strong>接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。</strong></p><hr><h1 id="内部类的优势"><a href="#内部类的优势" class="headerlink" title="内部类的优势"></a>内部类的优势</h1><ul><li><p>内部类提供了更好的封装，可以把内部类隐藏在外部类之中，不允许同一个包中的其他类访问该类，更好的实现了信息隐藏。</p></li><li><p>也是最吸引人的原因，每个内部类都能独立地继承一个接口，而无论外部类是否已经继承了某个接口。<br>因此，内部类使多重继承的解决方案变得更加完整。<br>在项目中，需要多重继承，如果是两个接口，那么好办，接口支持多重继承。<br>如果是两个类呢？这时只有使用内部类了。</p></li></ul><hr><h1 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h1><p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;<span class="comment">//外部类</span></span><br><span class="line">    <span class="keyword">double</span> r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span></span>&#123;<span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Draw Sahpe."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看起来，Draw 类像是 Circle 类的一个成员，Circle 称为外部类，Draw 类称为 Circle 类的成员内部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括 private 成员和静态成员）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(r);<span class="comment">//外部类的private成员</span></span><br><span class="line">            System.out.println(count);<span class="comment">//外部类的静态成员</span></span><br><span class="line">            System.out.println(<span class="string">"Draw Sahpe."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然成员内部类可以无条件的访问外部类的成员，但是外部类想访问成员内部类的成员缺不是那么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">        getDrawInstance().drawSahpe();      <span class="comment">//必须先创建成员内部类的对象，再进行访问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Draw <span class="title">getDrawInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span></span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(r);<span class="comment">//外部类的private成员</span></span><br><span class="line">            System.out.println(<span class="string">"Draw Sahpe."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员内部类是依附于外部类而成在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Inner inner = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inner == <span class="keyword">null</span>)&#123;</span><br><span class="line">            inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一种方法：外部类对象.new 内部类</span></span><br><span class="line">        Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">        Outter.Inner inner = outter.new Inner();</span><br><span class="line">        <span class="comment">//第二种方法：外部类对象.获取方法</span></span><br><span class="line">        Outter.Inner inner1 = outter.getInnerInstance();</span><br><span class="line">        <span class="comment">//第三种方法：new 外部类.new 内部类</span></span><br><span class="line">        Outter.Inner inner2 = <span class="keyword">new</span> Outter().new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类可以拥有 private 访问权限、protected 访问权限、public 访问权限及包访问权限。比如上面的例子，如果成员内部类 Inner 用 private 修饰，则只能在外部类的内部访问，如果用 public 修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被 public 和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>内部类在外部使用时，无法直接实例化，需要借由外部类信息才能完成实例化</li><li>成员内部类中不能存在任何static的变量和方法</li><li>内部类的访问修饰符，可以任意，但是访问范围会受到影响</li><li>内部类可以直接访问外部类的成员；如果出现同名属性，有限访问内部类中定义的</li><li>可以使用<strong>外部类.this.成员</strong>的方法，访问外部类中同名的信息</li><li>外部类访问内部类信息，需要通过内部类实例，无法直接访问</li><li>内部类编译后.class文件命名:<strong>外部类$内部类.class</strong></li><li>内部类中可以包含与外部类相同方法签名的方法，内部类对象在调用的时候调用的是内部类中的方法</li></ul><hr><h1 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h1><p>有这样一种内部类，它是嵌套在方法和作用域内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//局部内部类 Inner</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"局部内部类..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul><li><p>局部内部类类似方法的局部变量，所以在类外或者类的其他方法中不能访问这个内部类，但这并不代表局部内部类的实例和定义了它的方法中的局部变量具有相同的生命周期。</p><p><img src="/2018/10/22/Java基础七-内部类/局部内部类.png" alt="局部内部类"></p><p>我们可以看到，这里的局部内部类 Inner 定义在了一个 if 条件作用域中，因此，在 if 之外的部分，尽管没有离开 function() 方法，就会编译报错，无法访问到 Inner 这个内部类。因此，还要广义的理解局部内部类的含义和访问条件，不可以片面的理解为仅仅是方法中定义的内部类。</p></li><li><p>只能在方法内部，局部内部类定义之后使用，不存在外部可见性问题，因此没有访问修饰符，即 class 前面不可以添加public、private、protected、static</p></li><li><p>不能再局部内部类中使用可变的局部变量</p></li><li><p>类中不能包含静态成员</p></li><li><p>类中可以包含final、abstract修饰的成员</p></li></ul><p>综上，就是局部内部类的知识，其实局部内部类的名气远没有匿名内部类的名气大，但是作为一个匿名内部类的父概念，其定义了匿名内部类和普通的局部内部类的概念和特性，因此可以作为匿名内部类的知识补充。</p><hr><h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><p>匿名内部类也就是没有名字的内部类。</p><p>正因为没有名字，所以匿名内部类只能用一次，它通常是用来简化代码编写</p><p>但使用匿名内部类还有一个前提条件:必须继承一个父类或实现一个接口</p><p>这应该是我最经常用的内部类了，写 Android 的时候，使用点击事件就会用到它，来举个例子吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">  setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">  bt = findViewById(R.id.bt1);</span><br><span class="line">  <span class="comment">//1.匿名内部类</span></span><br><span class="line">  bt.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      Log.i(<span class="string">"匿名内部类"</span>, <span class="string">"点击事件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是匿名内部类的使用。代码中需要给 Button 设置一个监听器对象，使用匿名内部类能够在实现父类或者接口的方法的情况下同时产生一个相应的对象，但是前提是父类或者这个接口的方法是存在的。当然，也可以按照下面这么写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setListener</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bt.setOnClickListener(<span class="keyword">new</span> Listener1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Listener1</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      Log.i(<span class="string">"匿名内部类"</span>, <span class="string">"点击事件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的写法虽然能达到同样的效果，但是及冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也不能有访问修饰符和 static 修饰符的。</p><h2 id="匿名内部类初始化"><a href="#匿名内部类初始化" class="headerlink" title="匿名内部类初始化"></a>匿名内部类初始化</h2><p>我们一般用构造器来完成某个实例的初始化工作，但是匿名内部类是没有构造器的，那怎么来初始化匿名内部类呢？答案是使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>匿名内部类有不能的表现形式，下面为大家展示一下：</p><h3 id="继承式的匿名内部类"><a href="#继承式的匿名内部类" class="headerlink" title="继承式的匿名内部类"></a>继承式的匿名内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Driving another car"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        car.drive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>Driving another car</p></blockquote><p>引用变量不是引用 Car 对象，而是 Car 匿名子类的对象</p><p>建立匿名内部类的关键是重写父类的一个或者多个方法，这里再强调一下，是重写父类的方法，而不是建立新的方法。因为父类的引用不可能调用父类本身没有的方法，所以建立新的方法是多余的。</p><h3 id="接口式的匿名内部类"><a href="#接口式的匿名内部类" class="headerlink" title="接口式的匿名内部类"></a>接口式的匿名内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vehicle v = <span class="keyword">new</span> Vehicle() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Driving a car"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>Driving a car</p></blockquote><p>这段代码很奇怪，乍一看以为实例化了个接口。事实并非如此，接口式的匿名内部类是实现了一个接口的匿名类。而且只能实现一个借口。</p><h3 id="参数式的匿名内部类"><a href="#参数式的匿名内部类" class="headerlink" title="参数式的匿名内部类"></a>参数式的匿名内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doStuff</span><span class="params">(Foo f)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BarOne</span> <span class="keyword">extends</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doStuff</span><span class="params">(Foo f)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Bar b = <span class="keyword">new</span> BarOne();</span><br><span class="line">        b.doStuff(<span class="keyword">new</span> Foo() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"foofy"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面3个例子可以看出，只要一个类是抽象的或者是一个接口，那么其子类中的方法都可以使用匿名内部类来实现。最常用的情况就是在多线程的实现上，因为要实现多线程必须继承 Thread 类或是实现 Runable 接口</p><h3 id="Thread-类的匿名内部类实现"><a href="#Thread-类的匿名内部类实现" class="headerlink" title="Thread 类的匿名内部类实现"></a>Thread 类的匿名内部类实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Runnable-接口的匿名内部类实现"><a href="#Runnable-接口的匿名内部类实现" class="headerlink" title="Runnable 接口的匿名内部类实现"></a>Runnable 接口的匿名内部类实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><ul><li>匿名内部类没有类型名称、实例对象名称</li><li><p>编译后的文件命名：外部类$数字.class</p></li><li><p>无法使用private、public、protected、abstract、static修饰，匿名内部类不能出现抽象方法</p></li><li>无法编写构造方法，可以添加构造代码块</li><li>不能出现静态成员</li><li>匿名内部类可以实现接口也可以继承父类，但不可以兼得</li><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现接口的所有抽象方法</li></ul><hr><h1 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h1><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字 static 。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非 static 成员变量或方法。这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非 static 成员就会产生矛盾，因为外部类的非 static 必须依附于具体的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"外部类"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是外部类的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"这是内部类的静态方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Outter().say();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Outter().name + <span class="string">"到此一游"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outter.Inner in = <span class="keyword">new</span> Outter.Inner();</span><br><span class="line">        System.out.println(in.print());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>这是外部类的静态方法<br>外部类到此一游</p></blockquote><p>可以看到，如果用 static 将内部类静态化，那么内部类就只能访问外部类的静态成员变量，具有局限性。</p><p>其次，因为内部类被静态化，因此 Outter.Inner 可以当做一个整体看，可以直接 new 出内部类的对象。(因为类名访问 static ，生不成外部类对象都没关系)</p><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><ul><li><p>静态内部类中，只能直接访问外部类的静态成员，如果需要调用非静态成员，可以通过对象实例</p><p><code>new Outter().say();</code> 这样调用</p></li><li><p>静态内部类对象实例时，可以不依赖于外部类对象</p></li><li><p>可以通过<strong>外部类.内部类.静态成员</strong>的方式，访问内部类中的静态成员</p></li><li><p>当内部类属性与外部类属性同名时，默认直接调用内部类中的成员</p></li><li><p>如果需要访问外部类中的静态属性，则可以通过<strong>外部类.属性</strong>的方式</p></li><li><p>如果需要访问外部类中的非静态属性，则可以通过<strong>new 外部类().属性</strong>的方式</p></li></ul><hr><h1 id="接口中的内部类"><a href="#接口中的内部类" class="headerlink" title="接口中的内部类"></a>接口中的内部类</h1><p>我们在实际开发中，如果想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么接口内部的嵌套类会显得很方便。也就是说，在接口中可以含有内部类。</p><ul><li>首先创建接口，接口中定义了普通内部类 InnerClass 和抽象内部类 AbInnerClass</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IOuterInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> TEMP = <span class="number">100</span>;<span class="comment">//常亮</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">abMethod</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">deMethod</span><span class="params">()</span></span>&#123;<span class="comment">//jdk1.8后可添加</span></span><br><span class="line">        System.out.println(<span class="string">"接口中的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stMethod</span><span class="params">()</span></span>&#123;<span class="comment">//jdk1.8后可添加</span></span><br><span class="line">        System.out.println(<span class="string">"接口中的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"接口中可定义普通成员内部类"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbInnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abInfo</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"接口中可以定义抽象成员内部类"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>普通成员内部类的实例化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> <span class="keyword">implements</span> <span class="title">IOuterInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取接口中内部类方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">getInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一种实例化对象方式</span></span><br><span class="line">        <span class="comment">//通过 接口名.类名 进行实例化</span></span><br><span class="line">        IOuterInterface.InnerClass innerClass = <span class="keyword">new</span> IOuterInterface.InnerClass();</span><br><span class="line">        innerClass.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种实例化对象方式</span></span><br><span class="line">        <span class="comment">//通过在实现类中创建接口中内部类获取方法</span></span><br><span class="line">        <span class="comment">//用实现类对象调用获取方法</span></span><br><span class="line">        ClassDemo demo = <span class="keyword">new</span> ClassDemo();</span><br><span class="line">        demo.getInner().show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>接口中可定义普通成员内部类<br>接口中可定义普通成员内部类</p></blockquote><ul><li>抽象成员内部类的实例化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbClassDemo</span> <span class="keyword">implements</span> <span class="title">IOuterInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//继承抽象类AbInnerClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbDemo</span> <span class="keyword">extends</span> <span class="title">AbInnerClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"重写了接口中国抽象类中的抽象方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一种实例化对象方式</span></span><br><span class="line">        <span class="comment">//通过 接口名.类名 进行实例化</span></span><br><span class="line">        <span class="comment">//但是对于抽象类而言，不能直接实例化，所以这里可以使用匿名内部类的方式</span></span><br><span class="line">        IOuterInterface.AbInnerClass abInner = <span class="keyword">new</span> IOuterInterface.AbInnerClass() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"重写抽象类中的抽象方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        abInner.abInfo();</span><br><span class="line">        abInner.info();</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//第二种实例化对象方式</span></span><br><span class="line">        <span class="comment">//在实现类中定义内部类继承接口中的抽象内部类</span></span><br><span class="line">        IOuterInterface.AbInnerClass abInnerOne = <span class="keyword">new</span> AbClassDemo().new AbDemo();</span><br><span class="line">        abInnerOne.abInfo();</span><br><span class="line">        abInnerOne.info();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>重写抽象类中的抽象方法<br>接口中可以定义抽象成员内部类</p><p>重写了接口中国抽象类中的抽象方法<br>接口中可以定义抽象成员内部类</p></blockquote><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>这里只是提供给大家几种实例化接口中内部类的思路和方式，大家也可以用其他方式去进行对象实例化，当然前提是要满足代码规则。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。&lt;/p&gt;
&lt;p&gt;与之对应，包含内部类的类被称为外部类。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="多态" scheme="https://cuizhe1023.github.io/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="内部类" scheme="https://cuizhe1023.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java基础七--接口</title>
    <link href="https://cuizhe1023.github.io/2018/10/18/Java%E5%9F%BA%E7%A1%80%E4%B8%83-%E6%8E%A5%E5%8F%A3/"/>
    <id>https://cuizhe1023.github.io/2018/10/18/Java基础七-接口/</id>
    <published>2018-10-18T03:27:33.126Z</published>
    <updated>2018-10-21T02:28:11.914Z</updated>
    
    <content type="html"><![CDATA[<p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><a id="more"></a><p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p><p>除非实现接口的类是抽象类，否则该类要定义接口中的<strong>所有</strong>方法。</p><p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><h1 id="接口与类相似点"><a href="#接口与类相似点" class="headerlink" title="接口与类相似点"></a>接口与类相似点</h1><ul><li>一个接口可以有多个方法</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名</li><li>接口的字节码文件保存在 .class 结尾的文件中</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中</li></ul><h1 id="接口与类的区别"><a href="#接口与类的区别" class="headerlink" title="接口与类的区别"></a>接口与类的区别</h1><ul><li>接口不能用于实例化对象</li><li>接口没有构造方法</li><li>接口中所有的方法必须是抽象方法</li><li>接口不能包含成员变量，除了 static 和 final 变量</li><li>接口不是被类继承了，而是被类实现了</li><li>接口支持多继承</li></ul><h1 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h1><ul><li>接口中每个方法也是隐式抽象的，接口中的方法会被隐式的指定为 public abstract （只能是 public abstract，其他修饰符都会报错）</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）</li><li>接口中的方法不能再接口中实现，只能由实现了接口的类来实现接口中的方法</li></ul><h1 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h1><ul><li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的</li><li>接口中不能含有静态代码块以及静态方法（用 static 修饰的方法），而抽象类是可以有静态代码块和静态方法</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口</li></ul><h1 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口名[extends 父接口1，父接口2..]&#123;</span><br><span class="line">  零到多个常量定义...</span><br><span class="line">  零到多个抽象方法的定义...</span><br><span class="line">  零到多个默认方法的定义...（jdk1.8 新增）</span><br><span class="line">  零到多个静态方法的定义...（jdk1.8 新增）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interface 关键字用来声明一个接口。下面是接口声明的一个简单例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Animal &#123;</span><br><span class="line">    static int age = 6;</span><br><span class="line">    final String name = &quot;名字&quot;;</span><br><span class="line">    public void sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口的特性"><a href="#接口的特性" class="headerlink" title="接口的特性"></a>接口的特性</h1><ul><li>接口是隐式抽象的，当声明一个接口的时候，不必使用 abstract 关键字</li><li>接口中每一个方法也是隐式抽象的，声明时同样不需要 abstract 关键字</li><li>接口中的方法都是共有的</li></ul><h1 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h1><p>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象类</p><p>类使用 implements 关键字实现接口。在类声明中，implements 关键字放在 class 声明后面</p><p>实现一个接口的语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...implements 接口名[,其他接口名称,其他接口名称..,...]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">final</span> String name = <span class="string">"名字"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我不想跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫爱睡觉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cat c = <span class="keyword">new</span> Cat();</span><br><span class="line">        c.run();</span><br><span class="line">        c.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>我不想跑<br>猫爱睡觉</p></blockquote><p>重写接口中声明的方法时，需要注意以下规则：</p><ul><li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常</li><li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型</li><li>如果实现接口的类是抽象类，那么就没有必要实现该接口的方法</li></ul><p>在实现接口的时候，也要注意一些规则：</p><ul><li><p>一个类可以<strong>同时</strong>实现多个接口</p></li><li><p>一个类只能继承一个类，但是能实现多个接口</p></li><li>一个接口可以继承另一个接口，这和类之间的继承比较相似</li></ul><h1 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h1><p>上面说到，一个接口可以继承另一个接口，这和类之间的继承比较相似。接口之间的继承也是使用的 extedns 关键字，子接口继承父接口的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//猫科动物接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClimbTree</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虎类接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Cat</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shape</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//东北虎类实现虎类这个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManchuriaTiger</span> <span class="keyword">implements</span> <span class="title">Tiger</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shape</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClimbTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有一个父接口 Animal ，猫科动物接口 Cat 继承 Animal，而 Tiger 接口又继承 Cat 接口，最后ManchuriaTiger实现了 Tiger 接口。这时编译器提示需要实现接口中的方法。</p><p>Tiger 接口自己声明了一个方法，从 Cat 接口继承了一个方法，Cat 接口自己声明了一个方法，又从 Animal 接口继承了两个方法。这样，实现 Tiger 接口的 ManchuriaTiger 类需要实现四个方法。</p><h1 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h1><p>在 Java 中，类的多继承是不合法的，但是接口允许多继承</p><p>在接口的多继承中 extends 关键字只需要使用一次，在其后跟着继承接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Cat</span>,<span class="title">Animal</span></span></span><br></pre></td></tr></table></figure><p>以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Cat 及 Animal 可能定义或者是继承相同的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="多态" scheme="https://cuizhe1023.github.io/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="接口" scheme="https://cuizhe1023.github.io/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java基础七--抽象类</title>
    <link href="https://cuizhe1023.github.io/2018/10/18/Java%E5%9F%BA%E7%A1%80%E4%B8%83-%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>https://cuizhe1023.github.io/2018/10/18/Java基础七-抽象类/</id>
    <published>2018-10-18T03:26:57.362Z</published>
    <updated>2018-10-21T02:27:31.041Z</updated>
    
    <content type="html"><![CDATA[<p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p><a id="more"></a><p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p><p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p><p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><h1 id="抽象类和抽象方法的声明格式"><a href="#抽象类和抽象方法的声明格式" class="headerlink" title="抽象类和抽象方法的声明格式"></a>抽象类和抽象方法的声明格式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> &lt;类名&gt; </span>&#123;</span><br><span class="line">成员变量;</span><br><span class="line">  方法()&#123;</span><br><span class="line">      方法体</span><br><span class="line">    &#125;<span class="comment">//一般方法</span></span><br><span class="line">    <span class="keyword">abstract</span> 方法（）&#123;&#125;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal eating..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从例子中可以看出，抽象类是用关键字 abstract 修饰的。抽象类中有一种特殊方法，即用 abstract 关键字来修饰的方法，称为”抽象方法“。</p><hr><h1 id="抽象类和抽象方法的特点"><a href="#抽象类和抽象方法的特点" class="headerlink" title="抽象类和抽象方法的特点"></a>抽象类和抽象方法的特点</h1><ul><li><p>抽象方法不允许直接实例化，换句话说抽象类不能创建对象，他只能作为其他类的父类。但可以通过向上转型，指向实例化。</p></li><li><p>抽象方法只有声明，不能实现，也就是说仅有方法头，而没有方法体和操作实现。</p><p>如：<code>abstract void sleep()；</code></p></li></ul><hr><h1 id="抽象类的意义"><a href="#抽象类的意义" class="headerlink" title="抽象类的意义"></a>抽象类的意义</h1><ul><li><p>为其子类提供一个公共的类型（父类引用指向子类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal a = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure></li><li><p>封装子类中重复内容（成员变量和方法）</p></li><li><p>将父类设计成抽象类后，既可借由父子继承关系限制子类的设计随意性，在一定程度上避免了无意义父类的实例化</p></li></ul><hr><h1 id="重点注意"><a href="#重点注意" class="headerlink" title="重点注意"></a>重点注意</h1><ul><li><p>含有抽象方法的类，只能被定义成抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;<span class="comment">//这里报错了</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal eating..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象类不一定包含抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal eating..."</span>);<span class="comment">//一般方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在抽象类中的成员方法可以包括一般方法和抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal eating..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象类不能实例化，及时抽象类里不包含抽象方法 ，这个抽象类 也不能创建实例，抽象类的构造方法主要是用于被其子类调用</p><p>例子：</p><p>Animal 抽象类中不包含抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal eating..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类中实例化 Animal ，编译器会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();<span class="comment">//这里报错了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个类继承抽象类后，必须实现其所有抽象方法，否则也是抽象类，不同的子类对父类的抽象方法可以有不同的实现</p><p>如父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal eating..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则其子类 Cat 有两种做法</p><p>方案一：重写抽象方法 sleep()，使方法得以实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫要睡大觉！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我不想跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案二：子类 Cat 类也定义为抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;<span class="comment">//没有实现父类中的抽象方法，所以是抽象类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我不想跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>即使父类是具体的，但其子类也可以是抽象的，如 Object 是具体的，但可以创建抽象子类</p></li><li><p>abstract 方法不能用 static 和 private 修饰；对于类，不能同时用 final 和 abstract 修饰，因为 final 关键字使得类不可继承，而 abstract 修饰的类如果不可以继承将没有任何意义。两者放一起回起冲突</p></li></ul><hr><h1 id="一个完整的抽象类的例子"><a href="#一个完整的抽象类的例子" class="headerlink" title="一个完整的抽象类的例子"></a>一个完整的抽象类的例子</h1><p>父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象父类 Shape</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> r;</span><br><span class="line">    Circle()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建带参构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setR</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">3.14</span>*r*r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Circle c = <span class="keyword">new</span> Circle(<span class="number">3.5</span>);</span><br><span class="line">        System.out.println(<span class="string">"圆的面积为："</span>+c.area());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>圆的面积为：38.465</p></blockquote><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>抽象类不能被实例化，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象</li><li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类</li><li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现</li><li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法</li><li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="多态" scheme="https://cuizhe1023.github.io/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="抽象类" scheme="https://cuizhe1023.github.io/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java基础七--多态</title>
    <link href="https://cuizhe1023.github.io/2018/10/18/Java%E5%9F%BA%E7%A1%80%E4%B8%83/"/>
    <id>https://cuizhe1023.github.io/2018/10/18/Java基础七/</id>
    <published>2018-10-18T02:34:58.013Z</published>
    <updated>2018-10-21T02:25:11.129Z</updated>
    
    <content type="html"><![CDATA[<p>多态是同一个行为具有多个不同表现形式或形态的能力。</p><a id="more"></a><h1 id="多态的分类"><a href="#多态的分类" class="headerlink" title="多态的分类"></a>多态的分类</h1><ul><li>编译时多态（设计时多态）：方法重载</li><li>运行时多态：Java 运行时系统根据调用该方法的实例的类型来决定选择调用哪个方法则被称为运行时多态</li></ul><p>我们平时说的多态，多指运行时多态</p><hr><h1 id="多态的实现方法"><a href="#多态的实现方法" class="headerlink" title="多态的实现方法"></a>多态的实现方法</h1><ul><li><p>重写</p><p>这个内容写过了，可以访问 <a href="https://cuizhe1023.github.io/2018/10/17/Java%E5%9F%BA%E7%A1%80%E5%85%AD/">Java基础六</a> 中的<strong><em>重写 &amp; 重载</em></strong>。</p></li><li><p>接口</p><ul><li>生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。</li><li>java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 <a href="https://cuizhe1023.github.io/2018/10/18/Java%E5%9F%BA%E7%A1%80%E4%B8%83-%E6%8E%A5%E5%8F%A3/">Java基础七-接口</a> 这一章节的内容</li></ul></li><li><p>抽象类和抽象方法</p><p>详情请看<a href="https://cuizhe1023.github.io/2018/10/18/Java%E5%9F%BA%E7%A1%80%E4%B8%83-%E6%8A%BD%E8%B1%A1%E7%B1%BB/">Java基础七-抽象类</a> 。</p></li></ul><hr><h1 id="向上转型-amp-向下转型"><a href="#向上转型-amp-向下转型" class="headerlink" title="向上转型 &amp; 向下转型"></a>向上转型 &amp; 向下转型</h1><p>要转型，首先要有继承。</p><ul><li><p>向上类型转换（Upcast）：将子类对象转换为父类，父类可以是接口</p><p>隐式/自动类型转换，是小类型到大类型的转换。</p></li><li><p>向下类型转换（Downcast）：将父类型转换为子类型</p><p>强制类型转换，是大类型到小类型。</p></li><li><p>通过 instanceof 运算符，来解决引用对象的类型，避免类型转换的安全性问题，提高代码的健壮性。</p></li></ul><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>举一个大家都知道的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal eating..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狗吃肉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狗爱跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Cat();<span class="comment">//向上转型</span></span><br><span class="line">        animal.eat();</span><br><span class="line">        animal = <span class="keyword">new</span> Dog();</span><br><span class="line">        animal.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>猫吃鱼<br>狗吃肉</p></blockquote><p>这就是向上转型，向上转型是安全的，因为任何子类都继承并接受了父类的方法。从例子中也可以看出猫和狗都属于他们的父类——Animal，这是可行的。但是向下转型就不行，若所所有的动物都是猫或者都是狗就不成立的。（所以向下转型要通过强制类型转换）</p><p>Animal animal = new Cat(); 将子类对象 Cat 转换为父类对象 Animal 。这个时候 animal 这个引用调用的方法是子类方法。</p><h3 id="转型过程中需要注意的问题"><a href="#转型过程中需要注意的问题" class="headerlink" title="转型过程中需要注意的问题"></a>转型过程中需要注意的问题</h3><ul><li>向上转型时，子类单独定义的方法会丢失。比如上面 Dog 类中定义的 run 方法，当 animal 引用指向 Dog 类实例时是访问不到 run 方法的，<code>animal.run()；</code>会报错。</li><li>子类引用引用不能指向父类对象。<code>Cat c = (Cat)new Animal()</code>这样是不行的。</li></ul><h3 id="向上转型的应用"><a href="#向上转型的应用" class="headerlink" title="向上转型的应用"></a>向上转型的应用</h3><ul><li><p>当一个子类对象向上转型父类类型后，就被当成了父类的对象，所能调用的方法会减少，只能调用子类重写了父类的方法以及父类派生的方法（如 set(),get()方法），而不能调用子类独有的方法。</p><p>继续用上面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Cat();<span class="comment">//向上转型</span></span><br><span class="line">        animal.eat();</span><br><span class="line">        animal = <span class="keyword">new</span> Dog();</span><br><span class="line">        animal.eat();</span><br><span class="line">      <span class="comment">//如果调用 Dog 类中的 run() 方法。</span></span><br><span class="line">      animal.run();<span class="comment">//这个会报错，编译不通过</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以调用子类重写父类的方法 eat()，但调用子类独有的方法 run() 时就是无效的</p></li><li><p>父类中的静态方法是不允许被子类重写的</p><p>如父类 Animal 中含有静态方法 sleep()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal eating..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal sleep..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当子类 Cat 中也定义同名方法时，此时 sleep() 算 Cat 类自己独有的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫要睡大觉！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Cat();</span><br><span class="line">        animal.eat();</span><br><span class="line">        animal.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>猫吃鱼<br>animal sleep…</p></blockquote><p>实际上调用的是父类的静态方法 sleep()</p><p>这是因为父类的静态方法可以被子类继承，但是不能重写。</p></li></ul><h3 id="向上转型的好处"><a href="#向上转型的好处" class="headerlink" title="向上转型的好处"></a>向上转型的好处</h3><ul><li>减少重复代码，使代码变得简介</li><li>提高系统扩展性</li></ul><p>举个例子：比如，我现在有很多种类的动物，要喂它们吃东西。如果不用向上转型，那我需要这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Cat c)</span></span>&#123;</span><br><span class="line">  c.eat();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Dog d)</span></span>&#123;</span><br><span class="line">  d.eat();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">eat(<span class="keyword">new</span> Cat());</span><br><span class="line">eat(<span class="keyword">new</span> Dog());</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一种动物写一个方法，如果我有一万种动物，我不得写一万个方法？假设你很厉害，耐着性子写完了，突然又来一个新的动物，你是不是又要单独为它写一个 eat() 方法？</p><p>那如果我用向上转型呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Animal a)</span></span>&#123;</span><br><span class="line">    a.eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eat(<span class="keyword">new</span> Cat());</span><br><span class="line">eat(<span class="keyword">new</span> Cat());</span><br><span class="line">eat(<span class="keyword">new</span> Dog());</span><br><span class="line"><span class="comment">//.....</span></span><br></pre></td></tr></table></figure><p>这样代码是不是简洁了许多？而且这个时候，如果我又有一种新的动物加进来，我只需要实现它自己的类，让他继承Animal就可以了，而不需要为它单独写一个eat方法。是不是提高了扩展性？</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>多态的实现可以通过向上转型和动态绑定机制来完成，向上转型实现了将子类对象向上转型为父类类型，而动态绑定机制能识别出对象转型前的类型，从而自动调用该类的方法，两者相辅相成。</p><p>绑定就是将一个方法调用同一个方法所在的类连接到一起就是绑定。绑定分为静态绑定和动态绑定两种。</p><h3 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h3><p>在程序运行之前进行绑定（由编译器和链接程序完成的），也叫作前期绑定。</p><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>在程序运行期间由 JVM 根据对象的类型自动的判断应该调用那个方法，也叫做后期绑定。</p><h3 id="静态绑定的例子"><a href="#静态绑定的例子" class="headerlink" title="静态绑定的例子"></a>静态绑定的例子</h3><p>如有一个父类 Human，它派生出来三个字类 Chinese 类、American 类、British类，三个子类中都重写了父类中的 speak() 方法，在测试类中用静态绑定的方式调用方法 speak()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Human speak..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"speak chinese."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">American</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"speak American English."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">British</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"speak English."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Chinese c = <span class="keyword">new</span> Chinese();</span><br><span class="line">        c.speak();</span><br><span class="line">        American a = <span class="keyword">new</span> American();</span><br><span class="line">        a.speak();</span><br><span class="line">        British b = <span class="keyword">new</span> British();</span><br><span class="line">        b.speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种调用方式是在代码里指定的，编译时编译器就知道 c 调动的是 Chinese 中的 speak() 方法，a 调用的是 American 的 speak() 方法。</p><h3 id="动态绑定的例子"><a href="#动态绑定的例子" class="headerlink" title="动态绑定的例子"></a>动态绑定的例子</h3><p>如果我们在测试类中做如下改动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生成父类对象数组，数组长度为5。</span></span><br><span class="line">        Human[] humans = <span class="keyword">new</span> Human[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; humans.length; i++) &#123;</span><br><span class="line">            n = (<span class="keyword">int</span>) (Math.random()*<span class="number">3</span>);<span class="comment">//随机生成从0到2中的一个数</span></span><br><span class="line">            <span class="keyword">switch</span>(n)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    humans[i] = <span class="keyword">new</span> Chinese();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    humans[i] = <span class="keyword">new</span> American();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    humans[i] = <span class="keyword">new</span> British();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环输出，循环体中每个对象分别调用 speak() 方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; humans.length; i++) &#123;</span><br><span class="line">            humans[i].speak();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>speak English.<br>speak chinese.<br>speak English.<br>speak American English.<br>speak English.</p></blockquote><p>此时，Human 类中随机生成 Chinese 类、American 类和 British 类的对象，编译器不能根据代码直接确定调用那个类中的 speak() 方法，直到运行时才能根据产生的随机数 n 的值来确定 humans[i]到底代表哪一个子类的对象，这样才能最终确定调用的是哪个类中的 speak() 方法，这就是动态绑定。</p><h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><p>与向上转型相对应的就是向下转型了。向下转型是把父类对象转为子类对象。(请注意！这里是有坑的。)它是用子类引用指向父类实例。</p><p>下图，在进行转换是会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line">Cat c = a；</span><br></pre></td></tr></table></figure><p>这就告诉我们向下转型不能自动转换，我们需要强转，所以乡下转型又叫做强制类型转换。</p><p>正确的语句是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//还是上面的animal和cat dog</span></span><br><span class="line">Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line">Cat c = (Cat) a;</span><br><span class="line">c.eat();</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>猫吃鱼</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog d = (Dog) a;</span><br><span class="line">d.eat();</span><br></pre></td></tr></table></figure><blockquote><p>报错：java.lang.ClassCastException: Cat cannot be cast to Dog</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal a1 = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat c1 = (Cat) a1;</span><br><span class="line">c1.eat();</span><br></pre></td></tr></table></figure><blockquote><p>报错：java.lang.ClassCastException: Animal cannot be cast to Cat</p></blockquote><p>为什么第一段代码不报错呢？相比你也知道了，因为a本身就是 Cat 对象，所以它理所当然的可以向下转型为Cat，也理所当然的不能转为 Dog，你见过一条狗突然就变成一只猫这种现象？</p><p>而a1为 Animal 对象，它也不能被向下转型为任何子类对象。比如你去考古，发现了一个新生物，知道它是一种动物，但是你不能直接说，啊，它是猫，或者说它是狗。</p><h3 id="向下转型注意事项"><a href="#向下转型注意事项" class="headerlink" title="向下转型注意事项"></a>向下转型注意事项</h3><ul><li>向下转型的前提是父类对象指向的是子类对象（也就是说，在向下转型之前，它得先向上转型）</li><li>向下转型只能转型为本类对象，兄弟类之间不能进行强制类型转换。（猫是不能变成狗的）。</li></ul><blockquote><p>大概你会说，我特么有病啊，我先向上转型再向下转型？？</p><p>声明上转型对象是为了可以直接调用子类中重写的方法，但是不能调用子类新增的方法。而下转型对象可以调用子类新增的方法</p></blockquote><p>我们回到上面的问题：喂动物吃饭，吃了饭做点什么呢？不同的动物肯定做不同的事，怎么做呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Animal a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog)&#123;  </span><br><span class="line">        Dog d = (Dog)a;</span><br><span class="line">        d.eat();</span><br><span class="line">        d.run();<span class="comment">//狗有一个跑的方法      </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat)&#123;  </span><br><span class="line">        Cat c = (Cat)a;</span><br><span class="line">        c.eat();</span><br><span class="line">        System.out.println(<span class="string">"我也想跑，但是不会"</span>); <span class="comment">//猫会抱怨    </span></span><br><span class="line">    &#125; </span><br><span class="line">    a.eat();<span class="comment">//其他动物只会吃</span></span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">eat(<span class="keyword">new</span> Cat());</span><br><span class="line">eat(<span class="keyword">new</span> Cat());</span><br><span class="line">eat(<span class="keyword">new</span> Dog());</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>现在，你懂了么？这就是向下转型的简单应用，可能举得例子不恰当，但是也可以说明一些问题。</p><blockquote><p>敲黑板，划重点！看到那个 <strong>instanceof</strong> 了么？  </p></blockquote><h2 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h2><p>instanceof 运算符用来判断对象是否可满足某个特定类型实例特征，简单的来说，就是判断其左边对象是否为其右边类的实例，返回boolean类型的数据。可以用来判断继承中的子类的实例是否为父类的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对象实例化</span></span><br><span class="line">        Animal c = <span class="keyword">new</span> Cat();</span><br><span class="line">        Animal d = <span class="keyword">new</span> Dog();</span><br><span class="line">        <span class="comment">//用 instanceof 运算符判断对象是否满足某个特定对象实例特征</span></span><br><span class="line">        System.out.println(c <span class="keyword">instanceof</span> Animal);</span><br><span class="line">        System.out.println(c <span class="keyword">instanceof</span> Cat);</span><br><span class="line">        System.out.println(c <span class="keyword">instanceof</span> Dog);</span><br><span class="line">        System.out.println(c <span class="keyword">instanceof</span> Object);</span><br><span class="line"></span><br><span class="line">        System.out.println(d <span class="keyword">instanceof</span> Animal);</span><br><span class="line">        System.out.println(d <span class="keyword">instanceof</span> Cat);</span><br><span class="line">        System.out.println(d <span class="keyword">instanceof</span> Dog);</span><br><span class="line">        System.out.println(d <span class="keyword">instanceof</span> Object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>true<br>true<br>false<br>true<br>true<br>false<br>true<br>true</p></blockquote><hr><h1 id="抽象类-amp-抽象方法"><a href="#抽象类-amp-抽象方法" class="headerlink" title="抽象类 &amp; 抽象方法"></a>抽象类 &amp; 抽象方法</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>某个父类只是限定其子类应该包括怎样的方法，但不需要准确知道这些子类如何实现这些方法。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p> Java 中使用抽象类，限制实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>abstract 也可用于方法——抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>抽象类不能直接实例化，必须借助子类完成相应的实例化操作</li><li>子类如果没有重写父类中所有的抽象方法，则也要定义为抽象类</li><li>抽象方法所在的类一定是抽象类</li><li>抽象类中可以没有抽象方法</li></ul><hr><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul><li>接口定义了某一批类所需要遵守的规范</li><li>接口不关心这些类的内部数据，也不关心这些类里方法的实现细节，它只规定这些类里必须提供某些方法</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口[extends 父接口1，父接口2..]&#123;</span><br><span class="line">  零到多个常量定义...</span><br><span class="line">  零到多个抽象方法的定义...</span><br><span class="line">  零到多个默认方法的定义...（jdk1.8 新增）</span><br><span class="line">  零到多个静态方法的定义...（jdk1.8 新增）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ul><li>接口可以实现多继承，即一个子接口可以同时继承多个父接口</li><li>实现接口的类如果不能实现接口中所有待重写的方法，则必须设置为抽象类</li><li>一个类可以继承自一个父类，同时实现多个接口</li></ul><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><ul><li><p>在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类</p></li><li><p>与之对应，包含内部类的类被称为外部类</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多态是同一个行为具有多个不同表现形式或形态的能力。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="多态" scheme="https://cuizhe1023.github.io/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="向上转型&amp;向下转型" scheme="https://cuizhe1023.github.io/tags/%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java基础六--继承</title>
    <link href="https://cuizhe1023.github.io/2018/10/17/Java%E5%9F%BA%E7%A1%80%E5%85%AD/"/>
    <id>https://cuizhe1023.github.io/2018/10/17/Java基础六/</id>
    <published>2018-10-17T00:16:32.885Z</published>
    <updated>2018-10-21T02:29:11.767Z</updated>
    
    <content type="html"><![CDATA[<p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p><p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><a id="more"></a><h1 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h1><ul><li>继承是类与类之间的一种关系</li><li>使用已存在的类的定义作为基础建立新的类</li><li>新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</li><li>当两个类之间满足 “A is a B” 的关系，我们就说它们满足继承关系</li></ul><hr><h1 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h1><ul><li>利于代码复用</li><li>缩短开发周期</li></ul><hr><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><ul><li>使用 extends 实现继承</li><li>Java 只支持单继承，一个类只能有一个父类（也称为超类、基类） </li></ul><hr><h1 id="继承后的初始化顺序"><a href="#继承后的初始化顺序" class="headerlink" title="继承后的初始化顺序"></a>继承后的初始化顺序</h1><p>父类的静态成员</p><p>子类静态成员</p><p>父类对象构建【属性（赋值）、构造代码块、构造方法】</p><p>子类对象构建【属性（赋值）、构造代码块、构造方法】</p><hr><h1 id="Super关键字"><a href="#Super关键字" class="headerlink" title="Super关键字"></a>Super关键字</h1><h2 id="如何区分调用的是继承父类的方法还是子类自己重写的方法"><a href="#如何区分调用的是继承父类的方法还是子类自己重写的方法" class="headerlink" title="如何区分调用的是继承父类的方法还是子类自己重写的方法?"></a>如何区分调用的是继承父类的方法还是子类自己重写的方法?</h2><ul><li><p>访问父类成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.print();</span><br></pre></td></tr></table></figure></li><li><p>访问父类属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.name;</span><br></pre></td></tr></table></figure></li></ul><h2 id="子类对象实例化时，能否选择父类的构造形式（调用指定的构造方法）？"><a href="#子类对象实例化时，能否选择父类的构造形式（调用指定的构造方法）？" class="headerlink" title="子类对象实例化时，能否选择父类的构造形式（调用指定的构造方法）？"></a>子类对象实例化时，能否选择父类的构造形式（调用指定的构造方法）？</h2><ul><li><p>访问父类构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>();<span class="comment">//无参的构造方法</span></span><br><span class="line"><span class="keyword">super</span>(<span class="string">"name"</span>);<span class="comment">//有参的构造方法</span></span><br></pre></td></tr></table></figure></li><li><p>子类的构造过程中必须调用其父类的构造方法，默认调用无参的构造方法</p></li><li><p>如果子类构造方法中既没有显示标注，而父类有没有无参的构造方法，则编译出错</p></li><li><p>使用 super 调用父类指定构造方法，必须在子类的构造方法的第一行</p></li></ul><hr><h1 id="this-关键字-amp-super-关键字"><a href="#this-关键字-amp-super-关键字" class="headerlink" title="this 关键字 &amp; super 关键字"></a>this 关键字 &amp; super 关键字</h1><table><thead><tr><th>this 关键字——当前类对象的引用</th><th>super 关键字——父类对象的引用</th></tr></thead><tbody><tr><td>访问当前类的成员方法<br>访问当前类的成员属性<br>访问当前类的构造方法<br>不能再静态方法中使用</td><td>访问父类的成员方法<br>访问父类的成员属性<br>访问父类的构造方法<br>不能再静态方法中使用</td></tr></tbody></table><p>构造方法调用时，super 和 this 不能同时出现</p><hr><h1 id="重写-amp-重载"><a href="#重写-amp-重载" class="headerlink" title="重写 &amp; 重载"></a>重写 &amp; 重载</h1><table><thead><tr><th>方法重写</th><th>方法重载</th></tr></thead><tbody><tr><td>在满足继承关系的子类中<br>方法名、参数个数、顺序、返回值与父类相同<br>返回值类型与父类的返回值类型向下兼容<br>访问修饰符的限定范围大于等于父类方法</td><td>在同一个类中<br>方法名相同<br>参数个数、顺序、类型不同<br>返回值类型、访问修饰符任意</td></tr></tbody></table><p><strong>方法重写存在，属性重写不存在</strong></p><hr><h1 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h1><ul><li><p>Object 类是所有类的父类</p></li><li><p>一个类没有使用 extends 关键字明确标识继承关系，则默认继承 Object 类（包括数组）</p></li><li><p>Java 中的每个类都可以使用 Object 中定义的方法</p><p>Object  类的常用方法</p></li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>toString()</td><td>返回当前对象本身的有关信息，按字符串对象返回</td></tr><tr><td>equals()</td><td>比较两个对象是否是同一个对象，是则返回true</td></tr><tr><td>hashCode()</td><td>返回该对象的哈希代码值</td></tr><tr><td>getClass()</td><td>获取当前对象所属的类信息，返回Class对象</td></tr></tbody></table><hr><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><p>final 表示“最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</p><ul><li>被 final 修饰的类表示不允许被继承</li><li>被 final 修饰的方法表示不允许被子类重写<ul><li>final 修饰的方法可以被继承</li><li>不能修饰构造方法</li></ul></li><li>被 final 修饰的变量表示不允许被修改<ul><li>方法内部的局部变量 —&gt; 在使用之前被初始化赋值即可</li><li>类中的成员变量 —&gt; 只能在定义时或者构造代码块、构造方法中进行初始化设置</li><li>基本数据类型的变量 —&gt; 初始赋值之后不能更改</li><li>引用类型的变量—&gt;初始化之后不能再指向另一个对象，但指向的对象的内容时可变的</li><li>不能修饰构造方法</li></ul></li><li>可配合 static 使用，表示静态的、不允许被修改的信息</li><li>使用 final 修饰可以提高性能，但会降低可扩展性</li></ul><hr><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>可以声明在包、类、属性、方法、局部变量、方法参数等的前面，用来对这些元素进行说明、注释</p><h2 id="按照运行机制分"><a href="#按照运行机制分" class="headerlink" title="按照运行机制分"></a>按照运行机制分</h2><ul><li>源码注解</li><li>编译时注解</li><li>运行时注解</li></ul><h2 id="按照来源分"><a href="#按照来源分" class="headerlink" title="按照来源分"></a>按照来源分</h2><ul><li><p>来自 JDK 的注解</p></li><li><p>来自第三方的注解</p></li><li><p>自定义注解</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。&lt;/p&gt;
&lt;p&gt;继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="继承" scheme="https://cuizhe1023.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="super关键字" scheme="https://cuizhe1023.github.io/tags/super%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
      <category term="this关键字" scheme="https://cuizhe1023.github.io/tags/this%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
      <category term="final关键字" scheme="https://cuizhe1023.github.io/tags/final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
      <category term="重写&amp;重载" scheme="https://cuizhe1023.github.io/tags/%E9%87%8D%E5%86%99-%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>数据结构概述</title>
    <link href="https://cuizhe1023.github.io/2018/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
    <id>https://cuizhe1023.github.io/2018/10/14/数据结构概述/</id>
    <published>2018-10-14T03:08:40.000Z</published>
    <updated>2018-10-21T02:30:04.990Z</updated>
    
    <content type="html"><![CDATA[<p>算法 + 数据结构 = 编程</p><p>什么是数据结构？</p><p>通俗的来说，数据结构是计算机存储、组织数据的方式。</p><p>常用的数据机构有：</p><ul><li>数组</li><li>栈</li><li>队列</li><li>链表</li><li>树</li><li>图</li><li>字典树（这是一种高效的树形结构，但值得单独说明）</li><li>散列表（哈希表）</li></ul><a id="more"></a><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是最简单、也是使用最广泛的数据结构。栈、队列等其他数据结构均是由数组演变过来的。</p><p>下图是一个包含元素（1、2、3、4）的简单数组，数组长度为4。</p><p><img src="/2018/10/14/数据结构概述/数组.jpg" alt="数组"></p><p>每个数据元素都关联一个正数值，我们称之为索引，它表明数组中每个元素所在的位置。大部分语言将初始索引定义为零。</p><h2 id="数组的两种类型："><a href="#数组的两种类型：" class="headerlink" title="数组的两种类型："></a>数组的两种类型：</h2><ul><li>一维数组</li><li>多维数组</li></ul><h2 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h2><ul><li>Insert——在指定索引位置插入一个元素</li><li>Get——返回指定索引位置的元素</li><li>Delete——删除指定索引位置的元素</li><li>Size——得到数组所有元素的数量</li></ul><h2 id="面试中关于数组的常见问题"><a href="#面试中关于数组的常见问题" class="headerlink" title="面试中关于数组的常见问题"></a>面试中关于数组的常见问题</h2><ul><li>寻找数组中第二小的元素</li><li>找到数组中第一个不重复出现的整数</li><li>合并两个有序数组</li><li>重新排列数组中的正值和负值</li></ul><hr><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>著名的撤销操作几乎遍布任意一个应用。但是你有没有想过他是如何实现的？这个问题的解决思路是按照将最后的状态排列在前的顺序，在内存中存储历史工作状态。这没办法用数组实现，但是有了栈，这就变得很方便了。</p><p>可以把栈想象成一摞书，为了拿到中间的书，你需要移除放置在这上面的所有书。这就是LIFO（后进先出）的工作原理。</p><p>下图是包含三个数据元素（1、2、3）的栈，其中顶部的3将被最先移除：</p><p><img src="/2018/10/14/数据结构概述/栈.jpg" alt="栈"></p><h2 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h2><ul><li>Push——在顶部插入一个元素</li><li>Pop——返回并移除栈顶元素</li><li>isEmpty——如果栈为空，则返回true</li><li>Top——返回顶部元素，但并不移除它</li></ul><h2 id="面试中关于栈的常见问题"><a href="#面试中关于栈的常见问题" class="headerlink" title="面试中关于栈的常见问题"></a>面试中关于栈的常见问题</h2><ul><li>使用栈计算后缀表达式</li><li>对栈的元素进行排序</li><li>判断表达式是否括号平衡</li></ul><hr><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>与栈类似，队列是另一种顺序存储元素的线性数据结构。栈与队列的最大差别在于栈是LIFO（后进先出），而队列是FIFO（先进先出）</p><p>常见的队列：排队上车，如果有新人加入，他需要到队尾排队，而非队首。排在前面的人会先上车，然后离开队伍。</p><p>下图是包含四个元素（1，2，3，4）的队列，其中在顶部的1将被最先移除：</p><p><img src="/2018/10/14/数据结构概述/队列.jpg" alt="队列"></p><p>移除先入队的元素、插入新元素</p><h2 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h2><ul><li>Enqueue() —— 在队列尾部插入元素</li><li>Dequeue() ——移除队列头部的元素</li><li>isEmpty()——如果队列为空，则返回true</li><li>Top() ——返回队列的第一个元素</li></ul><h2 id="面试中关于队列的常见问题"><a href="#面试中关于队列的常见问题" class="headerlink" title="面试中关于队列的常见问题"></a>面试中关于队列的常见问题</h2><ul><li>使用队列表示栈</li><li>对队列的前k个元素倒序</li><li>使用队列生成从1到n的二进制数</li></ul><hr><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表是另一个重要的数据结构，乍一看可能有点像数组，但在内存分配，内部结构以及数据插入和删除的基本操作方面均有所不同。</p><p>链表就像一个节点链，其中每个节点包含着数据和指向后续节点的指针。链表还包含一个头指针，它指向链表的第一个元素，但当列表为空时，它指向null或无具体内容。</p><p>链表一般用于实现文件系统、哈希表和邻接表。</p><p>这是链表内部结构的展示：</p><p><img src="/2018/10/14/数据结构概述/链表.jpg" alt="链表"></p><h2 id="链表包括以下类型："><a href="#链表包括以下类型：" class="headerlink" title="链表包括以下类型："></a>链表包括以下类型：</h2><ul><li>单链表</li><li>双向链表</li></ul><h2 id="链表的基本操作："><a href="#链表的基本操作：" class="headerlink" title="链表的基本操作："></a>链表的基本操作：</h2><ul><li>InsertAtEnd - 在链表的末尾插入指定元素</li><li>InsertAtHead - 在链接列表的开头/头部插入指定元素</li><li>Delete  - 从链接列表中删除指定元素</li><li>DeleteAtHead - 删除链接列表的第一个元素</li><li>Search  - 从链表中返回指定元素</li><li>isEmpty - 如果链表为空，则返回true</li></ul><h2 id="面试中关于链表的常见问题"><a href="#面试中关于链表的常见问题" class="headerlink" title="面试中关于链表的常见问题"></a>面试中关于链表的常见问题</h2><ul><li>反转链表</li><li>检测链表中的循环</li><li>返回链表倒数第N个节点</li><li>删除链表中的重复项</li></ul><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>图是一组以网络形式相互连接的节点，节点也称为顶点。一对节点（x，y）称为边（edge），表示顶点x连接到顶点y。边可以包含权重/成本，显示从顶点x到y所需的成本。</p><p><img src="/2018/10/14/数据结构概述/图.jpg" alt="图"></p><h2 id="图的类型"><a href="#图的类型" class="headerlink" title="图的类型"></a>图的类型</h2><ul><li>无向图</li><li>有向图</li></ul><p>在程序语言中，图可以用两种形式表示</p><ul><li>邻接矩阵</li><li>邻接表</li></ul><h2 id="常见的图遍历算法"><a href="#常见的图遍历算法" class="headerlink" title="常见的图遍历算法"></a>常见的图遍历算法</h2><ul><li>广度优先搜索</li><li>深度优先搜索</li></ul><h2 id="面试中关于图的常见问题"><a href="#面试中关于图的常见问题" class="headerlink" title="面试中关于图的常见问题"></a>面试中关于图的常见问题</h2><ul><li>实现广度和深度优先搜索</li><li>检查图是否为树</li><li>计算图的边数</li><li>找到两个顶点之间的最短路径</li></ul><hr><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树形结构是一种层级式的数据结构，由顶点（节点）和连接他们的边组成。数类似于图，但区分树和图的重要特征是树种不存在环路。</p><p>这是一个简单树的示意图，以及树数据结构中使用的基本术语：</p><p><img src="/2018/10/14/数据结构概述/树.jpg" alt="树"></p><p>Root - 根节点</p><p>Parent - 父节点</p><p>Child - 子节点</p><p>Leaf - 叶子节点</p><p>Sibling - 兄弟节点</p><h2 id="树形结构的主要类型"><a href="#树形结构的主要类型" class="headerlink" title="树形结构的主要类型"></a>树形结构的主要类型</h2><ul><li>N元树</li><li>平衡树</li><li>二叉树</li><li>二叉搜索树</li><li>AVL树</li><li>红黑树</li><li>2-3树</li><li>B 树</li><li>B+ 树</li></ul><p>其中，二叉树和二叉搜索树是最常用的树。</p><h2 id="面试中关于树结构的常见问题"><a href="#面试中关于树结构的常见问题" class="headerlink" title="面试中关于树结构的常见问题"></a>面试中关于树结构的常见问题</h2><ul><li>求二叉树的高度</li><li>在二叉搜索树中查找第k个最大值</li><li>查找与根节点距离k的节点</li><li>在二叉树中查找给定节点的祖先节点</li></ul><h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><p>字典树，也称为“前缀树”，是一种特殊的树形数据结构，对于解决字符串相关问题非常有效。他能够提供快速减速，主要用于搜索字典中的单词，在搜索引擎中自动提供建议，甚至被用于 IP 的路由。</p><p>以下是在字典树中存储三个单词“top”，“thus”和“their”的例子：</p><p><img src="/2018/10/14/数据结构概述/字典树.jpg" alt="字典树"></p><p>这些单词以顶部到底部的方式存储，其中绿色节点“p”，“s”和“r”分别表示“top”，“thus”和“their”的底部。</p><h2 id="面试中关于字典树的常见问题"><a href="#面试中关于字典树的常见问题" class="headerlink" title="面试中关于字典树的常见问题"></a>面试中关于字典树的常见问题</h2><ul><li>计算字典树中的总单词数</li><li>打印存储在字典树中的所有单词</li><li>使用字典树对数组的元素进行排序</li><li>使用字典树从字典中形成单词</li><li>构建T9字典（字典树+ DFS ）</li></ul><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希法（Hashing）是一个用于唯一标识对象并将每个对象存储在一些预先计算的唯一索引（称为“键key”）中的过程。因此，对象以键值对的形式存储，这些键值对集合被称为“字典”。可以使用键搜索每个对象。基于哈希法有很多不同的数据结构，但最常用的数据结构是哈希表。</p><p>哈希表通常用数组实现。</p><p>散列数据结构的性能取决于以下三个因素：</p><ul><li>哈希函数</li><li>哈希表的大小</li><li>碰撞处理方法</li></ul><p>下图为如何在数组中映射哈希键值对的说明。该数组的索引是通过哈希函数计算的。</p><p><img src="/2018/10/14/数据结构概述/哈希表.jpg" alt="哈希表"></p><h2 id="面试中关于哈希结构的常见问题："><a href="#面试中关于哈希结构的常见问题：" class="headerlink" title="面试中关于哈希结构的常见问题："></a>面试中关于哈希结构的常见问题：</h2><ul><li>在数组中查找对称键值对</li><li>追踪遍历的完整路径</li><li>查找数组是否是另一个数组的子集</li><li>检查给定的数组是否不相交</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法 + 数据结构 = 编程&lt;/p&gt;
&lt;p&gt;什么是数据结构？&lt;/p&gt;
&lt;p&gt;通俗的来说，数据结构是计算机存储、组织数据的方式。&lt;/p&gt;
&lt;p&gt;常用的数据机构有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组&lt;/li&gt;
&lt;li&gt;栈&lt;/li&gt;
&lt;li&gt;队列&lt;/li&gt;
&lt;li&gt;链表&lt;/li&gt;
&lt;li&gt;树&lt;/li&gt;
&lt;li&gt;图&lt;/li&gt;
&lt;li&gt;字典树（这是一种高效的树形结构，但值得单独说明）&lt;/li&gt;
&lt;li&gt;散列表（哈希表）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://cuizhe1023.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://cuizhe1023.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java基础五--封装</title>
    <link href="https://cuizhe1023.github.io/2018/10/14/Java%E5%9F%BA%E7%A1%80%E4%BA%94/"/>
    <id>https://cuizhe1023.github.io/2018/10/14/Java基础五/</id>
    <published>2018-10-14T00:35:35.658Z</published>
    <updated>2018-10-21T02:20:24.840Z</updated>
    
    <content type="html"><![CDATA[<p>什么是封装？</p><ul><li>通过该类提供的方法来实现对隐藏信息的操作和访问</li><li>隐藏对象的信息</li><li>留出访问的接口</li></ul><a id="more"></a><h1 id="封装的优点"><a href="#封装的优点" class="headerlink" title="封装的优点"></a>封装的优点</h1><ul><li>良好的封装能减少耦合</li><li>类内部的结构可以自由修改</li><li>可以对成员变量进行更精确的控制</li><li>隐藏信息，实现细节</li></ul><hr><h1 id="实现Java封装的步骤"><a href="#实现Java封装的步骤" class="headerlink" title="实现Java封装的步骤"></a>实现Java封装的步骤</h1><ul><li><p>隐藏对象</p><p><strong>修改属性的可见性——设置为 private</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，将 name 和 age 属性设置为私有的，只有本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。</p></li><li><p>留出接口</p><p><strong>创建 getter / setter 方法——设置为 public 用于属性的读写</strong></p><p><strong>在 getter / setter 方法中加入属性控制语句——对属性值的合法性进行判断</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name）之间发生的同名的冲突。</p></li></ul><hr><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>管理 Java 文件</li><li>解决同名文件冲突</li></ul><h2 id="定义包"><a href="#定义包" class="headerlink" title="定义包"></a>定义包</h2><p><strong>语法：</strong>package 包名;</p><p><strong>注意：</strong></p><p>1.必须放在 Java 源文件中的第一行</p><p>2.一个 Java 源文件中只能有一个 package 语句</p><p>3.包名全部英文小写</p><p>4.命名方式：域名倒序 + 模块 + 功能</p><p>eg：package com.nuc.zigbee;</p><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><p><strong>语法：</strong></p><p>import 包名.类名;</p><p>eg:</p><p>import com.nuc.*;</p><p>import com.nuc.zigbee;</p><h2 id="常用系统包"><a href="#常用系统包" class="headerlink" title="常用系统包"></a>常用系统包</h2><p>java.lang 包含 Java 语言基础的类</p><p>java.util 包含 Java 语言中的各种工具类</p><p>java.io 包含输入、输出相关功能的类</p><hr><h1 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h1><p>static 翻译为静态，从面向对象的角度讲，当一个类中的变量或方法用 static 修饰时，这些变量和方法就成了类本身的，他们和对象的关系并不大。但是从直观的角度讲，这些被修饰的量确实被该类所有对象所拥有，并且被这个类的所有对象所共享，求其是当使用该类对象进行引用他们时。其实当使用对象进行引用 static 修饰成员时，在底层代码的实现中，其实还是转换为类名进行引用，这表明这个成员属于类。</p><ul><li>static + 属性——静态属性、类属性</li><li>static + 方法——静态方法、类方法</li><li>static + 类——不存在，不能加载类前</li><li>static + 方法内局部变量——不能加载局部变量前</li><li>static + 代码块——静态代码块</li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ul><li>通过{}可以形成代码块</li><li>方法内的代码块称为：普通代码块</li><li>类内的代码块称为：构造代码块</li><li>构造代码块前 + static：静态代码块</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>初学这个关键字时，书上有个重点，那就是一个类中， static 修饰的成员不能访问势力成员，只能访问静态成员。这个很好理解，static 修饰的成员叫做类成员，属于类本身的属性，随着类的编译进行初始化，而此时实例成员未必进行初始化，这就会带来很多错误，所以类成员访问实例成员是不能通过编译的。</li><li>静态方法中不可以定义 this，super 关键字，因为静态元素优先于对象存在。</li></ul><h3 id="静态成员的声明周期"><a href="#静态成员的声明周期" class="headerlink" title="静态成员的声明周期"></a>静态成员的声明周期</h3><p>静态成员随着类的加载而产生，销毁时释放，生命周期伴随着类的整个的生命周期，生命周期长，这就意味着对内存资源的占用也会相对比较长。</p><h3 id="静态方法中的成员调用"><a href="#静态方法中的成员调用" class="headerlink" title="静态方法中的成员调用"></a>静态方法中的成员调用</h3><ul><li>可以直接调用同类中的静态成员。</li><li>不可以直接调用同类中的非静态成员。</li><li>只能通过对象实例化后，对象.成员方法 的方式访问非静态成员。</li></ul><h3 id="各种代码块的执行顺序"><a href="#各种代码块的执行顺序" class="headerlink" title="各种代码块的执行顺序"></a>各种代码块的执行顺序</h3><p>无论实例产生多少对象，静态代码块只执行一次。</p><p>构造代码块在每次对象构造的时候调用。</p><p>方法中的普通代码块则是在每次调用方法的时候顺序调用。</p><h3 id="什么时候定义静态变量"><a href="#什么时候定义静态变量" class="headerlink" title="什么时候定义静态变量"></a>什么时候定义静态变量</h3><p>当对象中出现共享数据时，该数据被修饰成静态，对象中的特有数据，修饰为非静态，存在于堆内存中。</p><h3 id="什么时候定义静态方法"><a href="#什么时候定义静态方法" class="headerlink" title="什么时候定义静态方法"></a>什么时候定义静态方法</h3><p>当功能内部没有访问到非静态数据（对象中特有的数据），该函数可以定义为静态的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是封装？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过该类提供的方法来实现对隐藏信息的操作和访问&lt;/li&gt;
&lt;li&gt;隐藏对象的信息&lt;/li&gt;
&lt;li&gt;留出访问的接口&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="封装" scheme="https://cuizhe1023.github.io/tags/%E5%B0%81%E8%A3%85/"/>
    
      <category term="static" scheme="https://cuizhe1023.github.io/tags/static/"/>
    
  </entry>
  
  <entry>
    <title>Java基础四--面向对象基础</title>
    <link href="https://cuizhe1023.github.io/2018/10/13/Java%E5%9F%BA%E7%A1%80%E5%9B%9B/"/>
    <id>https://cuizhe1023.github.io/2018/10/13/Java基础四/</id>
    <published>2018-10-13T10:20:01.898Z</published>
    <updated>2018-10-14T00:25:01.681Z</updated>
    
    <content type="html"><![CDATA[<p>如果你现实中没有对象，至少你在java世界里会有茫茫多的对象，听起来是不是很激动呢？<br><a id="more"></a></p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>对象是类的一个实例，有状态和行为。</p><p>我们所在的世界，周围的一切事物都是对象，车、人、狗等等。这些对象都有自己的状态和行为。</p><p>我们用一只猫来举例，它的状态有：名字、品种、颜色，行为由：跑，叫，睡觉。</p><p>软件的对象也有状态和行为。软件对象的状态称为<strong>属性</strong>，行为通过<strong>方法</strong>体现。</p><h2 id="那么什么是面向对象？"><a href="#那么什么是面向对象？" class="headerlink" title="那么什么是面向对象？"></a>那么什么是面向对象？</h2><p>关注现实存在的事物的各方面的信息，从对象的角度出发，根据事物的特征进行程序设计</p><hr><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类是一个模子，确定对象将会拥有的特性（属性）和行为（方法）</p><p>类的特点：</p><ul><li>类是对象的类型</li><li>具有相同属性和方法的一组对象的集合</li></ul><p>对象是类的实例表现</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>对象具有的静态特征。对象“有什么”。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>对象具有的各种动态行为。对象“能做什么”。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>一个类中可以包含以下类型变量：</p><ul><li><p>局部变量</p><p>在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都在方法中，方法结束后，变量就会自动销毁</p></li><li><p>成员变量</p><p>成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问</p></li><li><p>类变量</p><p>类变量也声明在类中，方法体之外，但必须声明为static类型</p></li></ul><hr><h1 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h1><p>类是抽象的概念，仅仅是模板</p><p>对象是一个你能看得见，摸得着的具体实体</p><p>类是对象的类型</p><p>对象是特定类型的数据</p><hr><h1 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h1><p>实例化对象的过程可以分为两部分:</p><p>- 声明对象 Cat one</p><p>- 实例化对象 new Cat()</p><p>- Cat one = new Cat();//类名 对象名 = new  构造方法();</p><p>声明对象，就是在内存的<strong>栈区域</strong>开辟一块空间，此时这个空间里的值是空的</p><p>实例化对象，在内存的<strong>堆区域</strong>开辟一块空间，完成初始化操作</p><p><img src="/2018/10/13/Java基础四/对象实例化1.png" alt="对象实例化1"></p><p>经过赋值操作，我们将堆空间中的地址，传递到了栈当中的内存空间里。此后，我们就可以通过对象名去调用对象的属性和方法了。</p><p><img src="/2018/10/13/Java基础四/对象实例化2.png" alt="对象实例化2"></p><p>每次 new 对象就会产生新的实例化方法</p><p>- Cat one  = new Cat();</p><p>- Cat two = new Cat();</p><p><img src="/2018/10/13/Java基础四/对象实例化3.png" alt="对象实例化3"></p><p>多个对象也可以指向同一块实例化空间</p><p>- Cat one = new Cat();</p><p>- Cat two = one;</p><p><img src="/2018/10/13/Java基础四/对象实例化4.png" alt="对象实例化4"></p><h2 id="对象实例化-1"><a href="#对象实例化-1" class="headerlink" title="对象实例化"></a>对象实例化</h2><p>对象必须被实例化之后才能使用</p><p>对象间的引用传递，实际上传递的是堆内存空间的使用权</p><hr><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><ul><li>构造方法与类同名且没有返回值</li><li>只能在对象实例化的时候调用</li><li>一个类可以有多个构造方法—构造方法重载</li><li>当没有指定构造方法时，系统会自动调用无参的构造方法</li><li>当有指定构造方法，无论是有参、无参的构造方法，都不会自动调用无参的构造方法。</li><li>构造方法不可被重写</li></ul><hr><h1 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h1><p>this: 当前对象的默认引用</p><p>this 的使用</p><p>- 调用成员属性，解决成员属性和局部变量同名冲突</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  System.out.println(<span class="string">"我是单参构造"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>- 调用成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.eat();</span><br><span class="line">    System.out.println(<span class="string">"小猫快跑"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>- 调用重载的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"我是无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>();<span class="comment">//通过this()调用构造方法，必须放在方法体内的第一行。</span></span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">    System.out.println(<span class="string">"我是单参构造"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h1><p>当在一个源文件中定义多个类，并且还有 import 语句和 package 语句时，要特别注意这些规则</p><ul><li>一个源文件中只能有一个 public 类</li><li>一个源文件可以有多个非public类</li><li>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是  Employee，那么源文件应该命名为 Employee.java</li><li>如果一个类定义在某个包中，那么 package 语句应该在源文件的首行</li><li>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么import 语句应该在源文件中最前面</li><li>import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你现实中没有对象，至少你在java世界里会有茫茫多的对象，听起来是不是很激动呢？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面向对象" scheme="https://cuizhe1023.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java基础三--运算符</title>
    <link href="https://cuizhe1023.github.io/2018/10/13/Java%E5%9F%BA%E7%A1%80%E4%B8%89/"/>
    <id>https://cuizhe1023.github.io/2018/10/13/Java基础三/</id>
    <published>2018-10-13T10:15:29.982Z</published>
    <updated>2018-10-21T02:31:15.216Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 中运算符有一下几组</p><ul><li>算数运算符</li><li>关系运算符</li><li>位运算符</li><li>逻辑运算符</li><li>赋值运算符</li><li>其他运算符</li></ul><a id="more"></a><h1 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h1><p>算数运算符用在数学表达式中，作用和在数学中的作用一样。</p><p>在表格中 A = 10, B = 20</p><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">描述</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">+</td><td style="text-align:left">加法</td><td style="text-align:left">A + B = 30</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">减法</td><td style="text-align:left">A - B = -10</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">乘法</td><td style="text-align:left">A * B = 200</td></tr><tr><td style="text-align:left">/</td><td style="text-align:left">除法</td><td style="text-align:left">B / A = 2</td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">取余</td><td style="text-align:left">B % A = 0</td></tr><tr><td style="text-align:left">++</td><td style="text-align:left">自增</td><td style="text-align:left">A++ 或 ++A 等于11</td></tr><tr><td style="text-align:left">–</td><td style="text-align:left">自减</td><td style="text-align:left">B– 或者 –B 等于19</td></tr></tbody></table><h2 id="i-和-i-的区别"><a href="#i-和-i-的区别" class="headerlink" title="i++ 和 ++i 的区别"></a>i++ 和 ++i 的区别</h2><ul><li>++i 先进行自增操作，在进行表达式运算</li><li>i++ 先进行表达式运算，在进行自增操作</li></ul><p>简单的来说，i++ 与 ++i 在单独使用的时候，都代表了 i = i + 1;</p><p>表达式 a = ++i; 等价于 i = i + 1;a = i;</p><p>表达式 a = i++; 等价于 a = i;i = i + 1;</p><hr><h1 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h1><p>A = 10, B = 20</p><table><thead><tr><th style="text-align:left">运算符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td style="text-align:left">==</td><td>检查两个操作数的值是否相等，如果相等则返回true</td><td>(A = B) false</td></tr><tr><td style="text-align:left">!=</td><td>检查两个操作数的值是否相等，如果不相等则返回true</td><td>(A != B) true</td></tr><tr><td style="text-align:left">&gt;</td><td>检查左操作数的值是否大于右操作数的值，如果是，返回true</td><td>(A &gt; B) false</td></tr><tr><td style="text-align:left">&lt;</td><td>检查左操作数的值是否小于右操作数的值，如果是，返回true</td><td>(A &lt; B) true</td></tr><tr><td style="text-align:left">&gt;=</td><td>检查左操作数的值是否大于或者等于右操作数的值，如果是，返回true</td><td>(A &gt;= B) false</td></tr><tr><td style="text-align:left">&lt;=</td><td>检查左操作数的值是否小于或者等于右操作数的值，如果是，返回true</td><td>(A &lt;= B) true</td></tr></tbody></table><hr><h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>位运算应用于整数类型（int），长整型（long），短整型（short），字符型（char）和字节型（byte）等类型。</p><p>位运算符作用在所有的位上，并且按位运算。假设 A = 60, B = 13,则二进制表示如下</p><blockquote><p>A = 0011 1100</p><p>B = 0000 1101</p></blockquote><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与运算符，如果相对应位都是1，则结果为1，否则为0</td><td>(A &amp; B) = 0000 1100 即12</td></tr><tr><td>丨</td><td>按位或运算符，如果相对应位都是0，则结果为0，否则为1</td><td>(A 丨 B) = 0011 1101 即61</td></tr><tr><td>^</td><td>按位异或运算符，如果相对应位值相同，则结果为0，否则为1</td><td>(A ^ B) = 0011 0001 即49</td></tr><tr><td>~</td><td>取反运算符，按位取反运算符翻转操作数的每一位，即0变成1，1变成0</td><td>(~ A) = 1100 0011 即-61</td></tr><tr><td>&lt;&lt;</td><td>按位左移运算符。左操作数按位左移右操作数指定的位数</td><td>(A &lt;&lt; 2) = 1111 0000 即240</td></tr><tr><td>&gt;&gt;</td><td>按位右移运算符。左操作数按位右移右操作数指定的位数</td><td>(A &gt;&gt; 2) = 1111 即15</td></tr><tr><td>&gt;&gt;&gt;</td><td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充</td><td>(A &gt;&gt;&gt; 2) = 00001111 即15</td></tr></tbody></table><hr><h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><p>假设 A = true, B = false</p><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td><td>(A &amp;&amp; B) = false</td></tr><tr><td>丨丨</td><td>逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td><td>(A 丨丨 B) = true</td></tr><tr><td>！</td><td>逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td><td>! (A &amp;&amp; B)=  true</td></tr></tbody></table><h2 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h2><p>当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。</p><ul><li>短路逻辑与</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b = (a &lt; <span class="number">4</span>) &amp;&amp; (a++&lt;<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"使用短路逻辑运算符的结果为"</span>+b);</span><br><span class="line">        System.out.println(<span class="string">"a的结果为"</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用短路逻辑运算符的结果为false<br>a的结果为5</p></blockquote><p><strong>解析</strong>：该程序使用到了短路逻辑运算符(&amp;&amp;)，首先判断 a&lt;4 的结果为 false，则 b 的结果必定是 false，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。</p><ul><li>短路逻辑或</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b = (a &gt; <span class="number">4</span>) || (a++&lt;<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"使用短路逻辑运算符的结果为"</span>+b);</span><br><span class="line">        System.out.println(<span class="string">"a的结果为"</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用短路逻辑运算符的结果为true<br>a的结果为5</p></blockquote><p><strong>解析</strong>：该程序使用到了短路逻辑运算符(||)，首先判断 a &gt; 4 的结果为 true，则 b 的结果必定是 true，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。</p><hr><h1 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h1><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符，将右操作数的值赋给左侧操作数</td><td>C = A + B将把A + B得到的值赋给C</td></tr><tr><td>+=</td><td>加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td><td>C += A等价于C = C + A</td></tr><tr><td>-=</td><td>减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td><td>C -= A等价于C = C -  A</td></tr><tr><td>*=</td><td>乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td><td>C <em>= A等价于C = C </em> A</td></tr><tr><td>/=</td><td>除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td><td>C / = A等价于C = C / A</td></tr><tr><td>(％)=</td><td>取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td><td>C％= A等价于C = C％A</td></tr><tr><td>&lt;&lt; =</td><td>左移位赋值运算符</td><td>C &lt;&lt; = 2等价于C = C &lt;&lt; 2</td></tr><tr><td>&gt;&gt; =</td><td>右移位赋值运算符</td><td>C &gt;&gt; = 2等价于C = C &gt;&gt; 2</td></tr><tr><td>&amp;=</td><td>按位与赋值运算符</td><td>C＆= 2等价于C = C＆2</td></tr><tr><td>^ =</td><td>按位异或赋值操作符</td><td>C ^ = 2等价于C = C ^ 2</td></tr><tr><td>丨=</td><td>按位或赋值操作符</td><td>C 丨 = 2等价于C = C 丨 2</td></tr></tbody></table><hr><h1 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h1><h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p><p>对于条件表达式b ? x : y，先计算条件b，然后进行判断。如果b的值为true，计算x的值，运算结果为x的值；否则，计算y的值，运算结果为y的值。一个条件表达式绝不会既计算x，又计算y。条件运算符是右结合的，也就是说，从右向左分组计算。例如，a ? b : c ? d : e将按a ? b : (c ? d : e)执行。</p><h2 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h2><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p><p>用法：<br>result = object instanceof class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">"James"</span>;</span><br><span class="line"><span class="keyword">boolean</span> result = name <span class="keyword">instanceof</span> String; <span class="comment">// 由于 name 是 String 类型，所以返回 true</span></span><br></pre></td></tr></table></figure><hr><h1 id="Java-运算符优先级"><a href="#Java-运算符优先级" class="headerlink" title="Java 运算符优先级"></a>Java 运算符优先级</h1><table><thead><tr><th>类别</th><th>操作符</th><th>关联性</th></tr></thead><tbody><tr><td>后缀</td><td>() [] . (点操作符)</td><td>左到右</td></tr><tr><td>一元</td><td>+ - ! ~</td><td>从右到左</td></tr><tr><td>乘性</td><td>* / ％</td><td>左到右</td></tr><tr><td>加性</td><td>+ -</td><td>左到右</td></tr><tr><td>移位</td><td>&gt;&gt; &gt;&gt;&gt;  &lt;&lt;</td><td>左到右</td></tr><tr><td>关系</td><td>&gt; &gt;= &lt; &lt;=</td><td>左到右</td></tr><tr><td>相等</td><td>==  !=</td><td>左到右</td></tr><tr><td>按位与</td><td>＆</td><td>左到右</td></tr><tr><td>按位异或</td><td>^</td><td>左到右</td></tr><tr><td>按位或</td><td>丨</td><td>左到右</td></tr><tr><td>逻辑与</td><td>&amp;&amp;</td><td>左到右</td></tr><tr><td>逻辑或</td><td>丨丨</td><td>左到右</td></tr><tr><td>条件</td><td>？：</td><td>从右到左</td></tr><tr><td>赋值</td><td>= += -= *= /= ％= &gt;&gt;= &lt;&lt;= &amp;= ^= 丨=</td><td>从右到左</td></tr><tr><td>逗号</td><td>，</td><td>左到右</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Java 中运算符有一下几组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算数运算符&lt;/li&gt;
&lt;li&gt;关系运算符&lt;/li&gt;
&lt;li&gt;位运算符&lt;/li&gt;
&lt;li&gt;逻辑运算符&lt;/li&gt;
&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;li&gt;其他运算符&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="运算符" scheme="https://cuizhe1023.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
</feed>
