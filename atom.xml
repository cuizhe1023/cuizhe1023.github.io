<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CuiZhe&#39;s Blog</title>
  
  <subtitle>CuiZhe&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cuizhe1023.github.io/"/>
  <updated>2018-10-28T12:45:24.645Z</updated>
  <id>https://cuizhe1023.github.io/</id>
  
  <author>
    <name>Cui Zhe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础九--字符串</title>
    <link href="https://cuizhe1023.github.io/2018/10/27/Java%E5%9F%BA%E7%A1%80%E4%B9%9D/"/>
    <id>https://cuizhe1023.github.io/2018/10/27/Java基础九/</id>
    <published>2018-10-27T09:13:02.000Z</published>
    <updated>2018-10-28T12:45:24.645Z</updated>
    
    <content type="html"><![CDATA[<p>字符串广泛应用在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String、StringBuffer、StringBuilder类来创建和操作字符串。</p><a id="more"></a><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"这是字符串1"</span>;</span><br><span class="line">        String s2 = <span class="keyword">new</span> String();<span class="comment">//这里创建了一个空字符串</span></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">"这是字符串3"</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>这是字符串1</p><p>这是字符串3</p></blockquote><p>String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，比如提供一个字符数组参数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] name = &#123;<span class="string">'C'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>,<span class="string">'n'</span>,<span class="string">'a'</span>&#125;;</span><br><span class="line">        String str = <span class="keyword">new</span> String(name);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>China</p></blockquote><p><strong>注意：</strong>String 类是不可改变的，所以你一旦创建了 String 对象，那么它的值就不能改了。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int length()</td><td>返回当前字符串的长度</td></tr><tr><td>int indexOf(int ch)</td><td>查找ch字符在该字符串中第一次出现的位置</td></tr><tr><td>int indexOf(String str)</td><td>查找str子字符串在该字符串中第一次出现的位置</td></tr><tr><td>int lastIndexOf(int ch)</td><td>查找ch字符在该字符串中最后一次出现的位置</td></tr><tr><td>int lastIndexOf(String str)</td><td>查找str子字符串在该字符串中最后一次出现的位置</td></tr><tr><td>String substring(int beginIndex)</td><td>获取从beginIndex位置开始到结束的子字符串</td></tr><tr><td>String substring(int beginIndex,int endIndex)</td><td>获取从beginIndex位置开始到endIndex位置的子字符串[beginIndex,endIndex)</td></tr><tr><td>String trim()</td><td>返回去除了前后空格的字符串</td></tr><tr><td>boolean equals(Object obj)</td><td>将该字符串与指定对象比较，返回true或者false</td></tr><tr><td>String toLowerCase()</td><td>将字符串转换为小写</td></tr><tr><td>String toUpperCase()</td><td>将字符串转换为大写</td></tr><tr><td>char charAt(int index)</td><td>获取字符串中指定位置的字符</td></tr><tr><td>String[] split(String regex,int li)</td><td>将字符串分割为子字符串，返回字符串数组</td></tr><tr><td>byte[] getBytes()</td><td>将该字符串转换为byte数组</td></tr></tbody></table><p>这里先介绍length()、charAt()、substring()、indexOf()、lastIndexOf()的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"Java编程基础，我喜欢Java编程"</span>;</span><br><span class="line">        System.out.println(<span class="string">"字符串长度："</span>+str.length());</span><br><span class="line">        System.out.println(<span class="string">"字符串中第5个位置是："</span>+str.charAt(<span class="number">5</span>));</span><br><span class="line">        System.out.println(<span class="string">"从4位置开始到结束的子字符串："</span>+str.substring(<span class="number">4</span>));</span><br><span class="line">        System.out.println(<span class="string">"从4位置开始到6位置结束的子字符串[4,6)："</span>+str.substring(<span class="number">4</span>,<span class="number">6</span>));</span><br><span class="line">        System.out.println(<span class="string">"查找“编程”在该字符串中第一次出现的位置："</span>+str.indexOf(<span class="string">"编程"</span>));</span><br><span class="line">        System.out.println(<span class="string">"查找“编程”在该字符串中最后一次出现的位置："</span>+str.lastIndexOf(<span class="string">"编程"</span>));</span><br><span class="line">        System.out.println(<span class="string">"从8位置开始，查找子串“编程”第一次出现的位置："</span>+str.indexOf(<span class="string">"编程"</span>, <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>字符串长度：18<br>字符串中第5个位置是：程<br>从4位置开始到结束的子字符串：编程基础，我喜欢Java编程<br>从4位置开始到6位置结束的子字符串：编程<br>查找“编程”在该字符串中第一次出现的位置：4<br>查找“编程”在该字符串中最后一次出现的位置：16<br>从8位置开始，查找子串“编程”第一次出现的位置：16</p></blockquote><p>字符串和 byte 数组之间相互转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"Java 编程 基础"</span>;</span><br><span class="line">        <span class="comment">//将字符串转换为 byte 数组，并打印输出</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> i :</span><br><span class="line">                bytes) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//将 byte 数组转换为字符串</span></span><br><span class="line">        String str1 = <span class="keyword">new</span> String(bytes);</span><br><span class="line">        System.out.println(str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>74 97 118 97 32 -25 -68 -106 -25 -88 -117 32 -27 -97 -70 -25 -95 -128<br>Java 编程 基础</p></blockquote><p>为什么会出现这么一堆东西？</p><p>这一堆数字其实就是字符串每一位所对应的ASCII码值，J的ASCII码值是74，a的ASCII码值是97，空格的ASCII码值是32，以此类推。那么负数是什么呢，因为默认用的是UTF-8编码，所以这里每三个负数对应一个汉字，即“编”对应-25 -68 -106，“程”对应-25 -88 -117。</p><p>在 String 中，除了有<code>String(byte[] bytes)</code>这个构造方法以外，还有一个构造方法<code>String(byte[] bytes,Charset charset)</code>，Charset 字符集。我们来看下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"Java 编程 基础"</span>;</span><br><span class="line">        <span class="comment">//将字符串转换为 byte 数组，并打印输出</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> i :</span><br><span class="line">                bytes) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//将 byte 数组转换为字符串</span></span><br><span class="line">        String str1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            str1 = <span class="keyword">new</span> String(bytes,<span class="string">"GBK"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>74 97 118 97 32 -25 -68 -106 -25 -88 -117 32 -27 -97 -70 -25 -95 -128<br>Java 缂栫▼ 鍩虹</p></blockquote><p>出现乱码了！为什么会这样？</p><p>这是因为 String 转 byte 数组的时候用的是UTF-8，而 byte 转 String 的时候用的却是 GBK，编码不统一导致的。</p><p>如果你就是想用 GBK 编码的话，可以这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"Java 编程 基础"</span>;</span><br><span class="line">        <span class="comment">//将字符串转换为 byte 数组，并打印输出</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bytes = str.getBytes(<span class="string">"GBK"</span>);<span class="comment">//byte[] getBytes(Charset charset) </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> i :</span><br><span class="line">                bytes) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//将 byte 数组转换为字符串</span></span><br><span class="line">        String str1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            str1 = <span class="keyword">new</span> String(bytes,<span class="string">"GBK"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>74 97 118 97 32 -25 -68 -106 -25 -88 -117 32 -27 -97 -70 -25 -95 -128<br>Java 编程 基础</p></blockquote><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>我们来看这么一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"string"</span>;</span><br><span class="line">        String s2 = <span class="string">"string"</span>;</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">"string"</span>);</span><br><span class="line">        String s4 = <span class="keyword">new</span> String(<span class="string">"string"</span>);</span><br><span class="line">        System.out.println(s1==s2);</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">        System.out.println(s1==s3);</span><br><span class="line">        System.out.println(s1.equals(s3));</span><br><span class="line">        System.out.println(s3==s4);</span><br><span class="line">        System.out.println(s3.equals(s4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>true<br>true<br>false<br>true<br>false<br>true</p></blockquote><p>为什么会出现这样的情况呢？当你用<code>String s1 = “string”;</code>创建字符串的时候，“string” 是存放在常量池里的。当你又用创建 s2 的时候，因为在常量池中已经存在了一个 “string”，所以 s2 里存放的是 “string” 中的内存地址。但当你用<code>String s3 = new String(“string”);</code>创建对象时，他是存放在堆内存的（实例化对象都是在堆内存中开辟空间）。每创建一个对象，它就开辟一个空间。</p><p><img src="/2018/10/27/Java基础九/String在内存中的存储.png" alt="String在内存中的存储"></p><hr><h1 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h1><p>前面有提到，String 是不可变的，一旦创建了 String 对象，那么它的值就不能改了。那么我们要是想要进行多次修改，就要用到 StringBuffer 和 StringBuilder 了。</p><p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p><p>StringBuilder 和 StringBuffer 之间最大的不同是在于 StringBuilder 的方法是线程不安全的（不能同步访问）。</p><p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder。然而在要求线程安全的情况下，必须要用 StringBuffer。</p><h2 id="StringBuilder的常用方法"><a href="#StringBuilder的常用方法" class="headerlink" title="StringBuilder的常用方法"></a>StringBuilder的常用方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String toString()</td><td>将StringBuilder对象转换为String对象</td></tr><tr><td>StringBuilder reverse()</td><td>将此字符序列用其反转形式取代</td></tr><tr><td>StringBuilder append()</td><td>追加内容到当前StringBuilder对象的末尾</td></tr><tr><td>StringBuilder delete()</td><td>移除此序列的子字符串中的字符。</td></tr><tr><td>StringBuilder insert()</td><td>将内容插入到StringBuilder对象的指定位置</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">"String"</span>);</span><br><span class="line">        System.out.println(<span class="string">"StringBuilder字符串为："</span>+str.toString();</span><br><span class="line">        System.out.println(<span class="string">"反转之后："</span>+str.reverse());</span><br><span class="line">        System.out.println(<span class="string">"再反转回来："</span>+str.reverse());</span><br><span class="line">        System.out.println(<span class="string">"在末尾添加“String”："</span>+str.append(<span class="string">"String"</span>));</span><br><span class="line">        System.out.println(<span class="string">"删除从6位置到12位置的字符[6,12)："</span>+str.delete(<span class="number">6</span>,<span class="number">12</span>));</span><br><span class="line">        System.out.println(<span class="string">"在位置5上加入“nnnnn”："</span>+str.insert(<span class="number">5</span>,<span class="string">"nnnnn"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>StringBuilder字符串为：String<br>反转之后：gnirtS<br>再反转回来：String<br>在末尾添加“String”：StringString<br>删除从6位置到12位置的字符[6,12)：String<br>在位置5上加入“nnnnn”：Strinnnnnng</p></blockquote><h2 id="String、StringBuffer和StringBuilder区别"><a href="#String、StringBuffer和StringBuilder区别" class="headerlink" title="String、StringBuffer和StringBuilder区别"></a>String、StringBuffer和StringBuilder区别</h2><h3 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h3><p>String 类中使用字符数组保存字符串，<code>private final char value[];</code>,所以 String 对象是不可变的。</p><p>StringBuffer 和 StringBuilder 是继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也使用字符数组保存字符串<code>char[] value;</code>没有被 final修饰，所以 StringBuffer 和 StringBuilder 都是可变的。</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>String 中的对象是不可变的，也就可以理解为常量，所以是线程安全的。</p><p>AbstractStringBuilder 是 StringBuffer 和 StringBuilder 的公共父类，定义了一些字符串的基本操作，如 append()、insert()、indexOf()等公共方法。</p><p>StringBuffer 对方法加了 synchronized 或者对调用的方法加了 synchronized，所以是线程安全的。</p><p>StringBuilder 并没有对方法加锁，所以是非线程安全的。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后指针指向新的 String</p><p>对象。</p><p>StringBuffer 每次都会对 StringBuffer 对象本身进行改变，而不是生成新的对象并改变对象的引用。</p><p>相同情况下，使用 StringBuilder 相比使用 StringBuffer 仅能获得10%-15%的性能提升，但是要冒着线程不安全的风险。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>String：操作少量的数据</p><p>StringBuilder：单线程下操作大量数据</p><p>StringBuffer：多线程下操作大量数据</p><hr><h1 id="和equals-方法"><a href="#和equals-方法" class="headerlink" title="==和equals()方法"></a>==和equals()方法</h1><h2 id=""><a href="#" class="headerlink" title="=="></a>==</h2><p>它的作用是比较两个对象的地址是不是相等的。即，判断两个对象是不是同一个对象。（基本数据类型\==比较的是值，引用数据类型\==比较的是内存地址）</p><h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><p>它的作用也是判断两个对象是否相等，但它一般有两种使用情况：</p><h3 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h3><p>类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象是，等价于通过“==”比较这两个对象。</p><h3 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h3><p>类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来判断两个对象的内容是否相等。若他们的内容相等，则返回 true（即，认为这两个对象是相等的）。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>);<span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>);<span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>;<span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>;<span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (a == b)&#123;<span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a == b"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (aa == bb)&#123;<span class="comment">//true</span></span><br><span class="line">            System.out.println(<span class="string">"aa == bb "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b))&#123;<span class="comment">//true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>)&#123;<span class="comment">//true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>aa == bb<br>aEQb<br>true</p></blockquote><p>说明：</p><ul><li>String 中的 equals() 方法是被重写过的，因为 Object 的 equals() 是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值</li><li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有，就把它赋给当前的引用，如果没有就在常量池中重新创建一个 String 对象。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字符串广泛应用在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String、StringBuffer、StringBuilder类来创建和操作字符串。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="String、StringBuffer、StringBuilder" scheme="https://cuizhe1023.github.io/tags/String%E3%80%81StringBuffer%E3%80%81StringBuilder/"/>
    
  </entry>
  
  <entry>
    <title>Java基础八--异常</title>
    <link href="https://cuizhe1023.github.io/2018/10/25/Java%E5%9F%BA%E7%A1%80%E5%85%AB/"/>
    <id>https://cuizhe1023.github.io/2018/10/25/Java基础八/</id>
    <published>2018-10-25T03:41:16.000Z</published>
    <updated>2018-10-26T09:10:38.258Z</updated>
    
    <content type="html"><![CDATA[<p>异常字面翻译就是“意外、例外”的意思，也就是说非正常情况。</p><p>在程序运行过程中，意外发生的情况，背离我们程序本身的意图的表现，都可以理解为异常</p><p>Java 中的异常本质上是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。</p><a id="more"></a><p>利用 Java 中的异常处理机制，我们可以更好地提升程序的健壮性</p><p>要理解 Java 异常处理是如何工作的，需要掌握以下三种类型的异常：</p><ul><li>检查型异常：最具代表的检查性异常时用户错误或问题引起的异常，这是我们无法预见的。例如要打开一个不存在的文件，一个异常就发生了，这些异常在编译时不能被简单的忽略。</li><li>运行时异常：运行时异常时可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略</li><li>错误：错误不是异常，而是脱离我们控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，他们在编译也检查不到。</li></ul><h1 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h1><p>在程序开发中，异常指不期而至的各种状况。他是一个事件，当发生在程序运行期间时，会干扰正常的指令流程。</p><p>在 Java 中，通过 Throwable 及其子类描述各种不同的异常类型</p><p><img src="/2018/10/25/Java基础八/Throwable及其子类.png" alt="Throwable及其子类"></p><p>Throwable 有两个重要的子类：Exception 和 Error</p><hr><h1 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h1><p>Error 是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而代表代码运行时 JVM 出现的问题</p><p>例如，Java 虚拟机运行错误，当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError</p><ul><li><p>这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。</p></li><li><p>对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。</p></li><li>因此我们编写程序时不需要关心这类异常</li></ul><hr><h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><p>Exception 是程序本身可以处理的异常。异常处理通常指针对这种类型异常的处理。</p><p>Exception 类的异常包括 unchecked exception（非检查型异常） 和 checked exception（检查型异常）</p><h2 id="unchecked-exception"><a href="#unchecked-exception" class="headerlink" title="unchecked exception"></a>unchecked exception</h2><ul><li><p>unchecked exception：编译器不要求强制处置的异常。</p></li><li><p>包含 RunntimeException 类及其子类异常</p></li><li><p>如 NullPointerException（空指针异常）、IndexOutOfBoundsException（下标越界异常）等，这些异常时unchecked exception。</p></li><li><p>Java 编译器不会检查这些异常，在程序中可以选择捕获处理，也可以不处理，照样正常编译通过</p></li></ul><h2 id="checked-exception"><a href="#checked-exception" class="headerlink" title="checked exception"></a>checked exception</h2><ul><li><p>checked exception：编译器要求必须处置的异常</p></li><li><p>是 RunntimeException 类及其子类以外，其他的 Exception 类的子类</p></li><li>如 IOException、SQLException 等</li><li>Java 编译器会检查这些异常，当程序中可能出现这类异常时，要求必须进行异常处理，否则编译不会通过</li></ul><hr><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>在 Java 应用程序中，异常处理机制为：抛出异常、捕获异常</p><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><ul><li>当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统</li><li>异常对象中包含了异常类型和异常出现时的程序状态等异常信息</li><li>运行时系统负责寻找处置异常的代码并执行</li></ul><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><ul><li>在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器</li><li>运行时系统从发生异常的方法开始，依次回查调用栈中的方法，当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器</li><li>当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着 Java 程序的终止</li><li>对于运行时异常、错误或可查异常，Java 技术所要求的的异常处理方式有所不同</li><li>总体来说，Java 规定：对于可查异常必捕获、或者声明抛出。允许忽略不可查的 RuntimeException 和 Error</li><li>简单的来说，异常总是先被抛出，后被捕获的</li></ul><h2 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h2><p>通过5个关键字来实现：try、catch、finally、throw、throws</p><p><img src="/2018/10/25/Java基础八/异常处理.PNG" alt="异常处理"></p><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//代码段1</span></span><br><span class="line">    <span class="comment">//产生异常的代码段2</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">    <span class="comment">//对异常进行处理的代码段3</span></span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//代码段4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h3><ul><li>使用 try-catch 块捕获并处理异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//代码段</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">    <span class="comment">//对异常进行处理的代码段</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//代码段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 try-catch 块捕获并处理异常——无异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//代码段（此处不会产生异常）</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">    <span class="comment">//对异常进行处理的代码段</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//代码段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/25/Java基础八/try-catch无异常.png" alt="try-catch无异常"></p><ul><li>使用 try-catch 块捕获并处理异常——有异常并能正常匹配处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//代码段1</span></span><br><span class="line">    <span class="comment">//产生异常的代码段2</span></span><br><span class="line">    <span class="comment">//代码段3</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">    <span class="comment">//对异常进行处理的代码段4</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//代码段5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/25/Java基础八/try-catch有异常且能处理.png" alt="try-catch有异常且能处理"></p><ul><li>使用 try-catch 块捕获并处理异常——有异常不能正常匹配处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//代码段1</span></span><br><span class="line">    <span class="comment">//产生异常的代码段2</span></span><br><span class="line">    <span class="comment">//代码段3</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">    <span class="comment">//对异常进行处理的代码段4</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//代码段5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/25/Java基础八/try-catch有异常但不能处理.png" alt="try-catch有异常但不能处理"></p><h3 id="多重-catch-块"><a href="#多重-catch-块" class="headerlink" title="多重 catch 块"></a>多重 catch 块</h3><ul><li>一旦某个 catch 捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个 tr-catch 语句结束。其他的 catch 子句不再有匹配和捕获异常类型的机会。</li><li>对于有多个 catch 子句的异常程序而言，应该尽量将捕获底层异常类的 catch 子句放在前面，同时尽量将捕获相对高层的异常类的 catch 子句放在后面。否则，捕获底层异常类 catch 子句将可能会被屏蔽。</li><li><p>引发多种类型的异常</p><ul><li><p>排列 catch 语句的顺序：先子类后父类</p></li><li><p>发生异常时按顺序逐个匹配</p><p><img src="/2018/10/25/Java基础八/多重catch块发生异常时按顺序逐个匹配.png" alt="多重catch块发生异常时按顺序逐个匹配"></p></li><li><p>只执行第一个与异常类型匹配的 catch 语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//代码段</span></span><br><span class="line">    <span class="comment">//产生异常（类型2）</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> e)&#123;</span><br><span class="line">    <span class="comment">//对异常处理的代码</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> e)&#123;</span><br><span class="line">    <span class="comment">//对异常处理的代码</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> e)&#123;</span><br><span class="line">    <span class="comment">//对异常处理的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//代码段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="try-ctach-finally"><a href="#try-ctach-finally" class="headerlink" title="try-ctach-finally"></a>try-ctach-finally</h3><ul><li><p>try 块后可以接零个或者多个 catch 块</p></li><li><p>如果没有 catch，则必须跟一个 finally 块</p></li><li><p>catch、finally可选</p><ul><li>语法组合：<ul><li>try-catch</li><li>try-finally</li><li>try-catch-finally</li><li>try-catch-catch-finally</li></ul></li></ul></li><li><p>在 try-catch 块后加入 finally 块</p><ul><li><p>是否发生异常都执行</p></li><li><p>不执行的唯一情况</p><p><img src="/2018/10/25/Java基础八/finally不执行的情况.png" alt="finally不执行的情况"></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通代码"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"try"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"catch"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p> 普通代码<br> try<br> catch</p></blockquote></li><li><p>一旦在 try 块或者 catch 块中加入 System.exit(1) 这个语句 finally 语句块将会强制终止执行</p><p>其实还要一种情况，当 try 块没有执行的话，finally 也不会被执行，也就是说，当一个方法在 try 块之前就返回了，那么他的 finally 块就不会被执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String str= method();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (a&lt;<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"finally 没有执行"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"普通代码"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"try"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"catch"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"finally 执行了"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>finally 没有执行</p></blockquote></li></ul></li></ul><ul><li><p>try-catch-finally的执行情况</p><p><img src="/2018/10/25/Java基础八/try-catch-finally的执行流程.png" alt="try-catch-finally的执行流程"></p></li></ul><hr><h1 id="实际应用中的经验与总结"><a href="#实际应用中的经验与总结" class="headerlink" title="实际应用中的经验与总结"></a>实际应用中的经验与总结</h1><ul><li>处理运行时异常时，采用逻辑去合理规避同时辅助 try-catch 处理</li><li>在多重 catch 块后面，可以加上 catch(Exception e)来处理可能会被遗漏的异常</li><li>对于不确定的代码，也可以加上 try-catch，处理潜在的异常</li><li>尽量去处理异常，切记只是简单地调用 printStackTrace() 去打印输出</li><li>具体如何处理异常，要根据不同的业务需求和异常类型去决定</li><li>尽量添加 finally 语句块去释放占用的资源</li><li>不执行 finally 块有两种方式<ul><li>try 语句没有被执行到，如在 try 语句之前 return 就返回了，这样 finally 语句就不会执行。这也说明了 finally 语句被执行的必要而非充分条件是：相应的 try 语句一定被执行到</li><li>在 try 块 catch 块中有 System.exit(0); 这样的语句。System.exit(0) 是终止 Java 虚拟机 JVM 的，连 JVM 都停止了，所有都结束了，当然 finally 语句也不会被执行到。</li></ul></li><li>在 try-catch-finally 中, 当 return 遇到 finally，return 对 finally 无效<ul><li>在try catch块里return的时候，finally也会被执行</li><li>finally 里的 return 语句会把 try catch 块里的 return 语句效果给覆盖掉</li></ul></li></ul><hr><h1 id="throw-amp-throws"><a href="#throw-amp-throws" class="headerlink" title="throw&amp;throws"></a>throw&amp;throws</h1><p>可以通过 throws 声明将要抛出何种类型的异常，通过 throw将产生的异常抛出</p><h2 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h2><ul><li><p>如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用 throws 子句来声明抛出异常</p></li><li><p>例如：汽车在运行时可能会出现故障，汽车本身没有办法处理这个故障，那就让开车的人来处理</p></li><li><p>throws 语句用在方法定义时声明该方法要抛出的异常类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception1，Exception2,...,ExceptionN</span>&#123;</span><br><span class="line">  <span class="comment">//可能产生异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当方法抛出异常列表中的异常时，方法不对这些类型及其子类类型的异常作处理，而抛向调用该方法的方法，由他去处理</p></li></ul><h3 id="throws的使用规则"><a href="#throws的使用规则" class="headerlink" title="throws的使用规则"></a>throws的使用规则</h3><ul><li>如果是不可检查异常（unchecked exception），即 Error 、RuntimeException 或他们的子类，那么可以不适用 throws 关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出</li><li>如果一个方法中可能出现可查异常，要么用 try-catch 语句捕获，要么用 throws 子句声明将它抛出，否则会导致编译错误</li><li>当抛出了异常，则该方法的调用者必须处理或者重新抛出该异常</li><li>当子类重写父类抛出异常的方法时，声明的异常必须是父类方法所声明异常的同类或子类</li></ul><h2 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h2><ul><li><p>throw 用来抛出一个异常</p><p>例如：throw new IOException();</p></li><li><p>trhow 抛出的只能是可抛出类 Throwable 或其子类的实例对象</p><p>例如：throw new String(“出错啦！”);//是错误的</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//代码段1</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> 异常类型();</span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">    <span class="comment">//对异常进行处理的代码段2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> throw 异常类型</span>&#123;</span><br><span class="line">  <span class="comment">//代码段1</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> 异常类型();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><ul><li>使用 Java 内置的异常类可以描述在编程时出现的大部分异常情况</li><li>也可以通过自定义异常描述特定业务产生的异常类型</li><li>所谓自定义异常，就是定义一个类，去继承 Throwable 类或者它的子类</li><li>如果希望写一个检查性异常类，则需要继承 Exception 类</li><li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类</li></ul><hr><h1 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h1><ul><li><p>有时候我们会捕捉一个异常后再抛出另一个异常</p></li><li><p>顾名思义就是：将异常发生的原因一个传一个穿起来，即把底层的异常信息传给上层，这样逐层抛出</p></li></ul><hr><h1 id="Java-常见异常类型及原因分析"><a href="#Java-常见异常类型及原因分析" class="headerlink" title="Java 常见异常类型及原因分析"></a>Java 常见异常类型及原因分析</h1><h1 id="常见的异常类型"><a href="#常见的异常类型" class="headerlink" title="常见的异常类型"></a>常见的异常类型</h1><table><thead><tr><th>异常类型</th><th>说明</th></tr></thead><tbody><tr><td>Exception</td><td>异常层次结构的父类</td></tr><tr><td>ArithmeticException</td><td>算术错误情形，如以零作除数</td></tr><tr><td>ArrayIndexOutOfBoundsException</td><td>数组下标越界</td></tr><tr><td>NullPointerException</td><td>尝试访问 null 对象成员</td></tr><tr><td>ClassNotFoundException</td><td>不能加载所需的类</td></tr><tr><td>IllegalArgumentException</td><td>方法接受到非法参数</td></tr><tr><td>ClassCastException</td><td>对象强制类型转换出错</td></tr><tr><td>NumberFormatException</td><td>数字格式转换异常，如把“abc”转换为数字</td></tr></tbody></table><h2 id="NullPointerException-异常"><a href="#NullPointerException-异常" class="headerlink" title="NullPointerException 异常"></a>NullPointerException 异常</h2><p>顾名思义，空指针异常，这可能是最常遇见的异常了。但是在 Java 中没有指针，怎么会有空指针异常呢？</p><p>在 C++ 中，声明的指针需要指向一个实例（通过 new 方法构造），这个指针可以理解为地址。在 Java 中，虽然没有指针，但是有引用（通常称为对象引用，一般直接说对象），引用也是要指向一个实例对象（通过 new 方法构造）的，从某种意义上说，Java 中的引用与 C++ 中的指针没有本质区别，不同的是，出于安全的目的，在 Java 中不能对引用进行操作，而在 C++ 中可以直接进行指针的运算。</p><p>所以这里的 NullPointerException 虽然不是真正的空指针异常，但本质上差不多，是因为引用没有指向具体的实例，所以当访问这个引用的时候就会产生这种异常。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"这是一个测试字符串"</span>;</span><br><span class="line">        System.out.println(str.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>9</p></blockquote><p>这段代码是没有问题的，但是如果改成下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(str.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>Exception in thread “main” java.lang.NullPointerException<br>​    at Main.main(Main.java:4)</p></blockquote><p>这就产生了 NullPointerException 异常了</p><h3 id="这种异常是如何产生的呢"><a href="#这种异常是如何产生的呢" class="headerlink" title="这种异常是如何产生的呢"></a>这种异常是如何产生的呢</h3><ul><li><p>把调用某个方法的返回值直接赋值给某个引用，然后调用这个引用的方法。在这种情况下，如果返回的值是Null，必然会产生 NullPointerException 异常。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String Name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        People p = <span class="keyword">null</span>;</span><br><span class="line">        p.setName(<span class="string">"张三"</span>);</span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：声明一个 People对象，并打印出该对象的 Name 值</p><p>说明：这个时候你的 p 就出现了空指针异常，因为你只是声明了 People 类型的对象，并没有创建对象，所以它的堆里面没有地址引用，切记你要用对象调用方法的时候，一定要先创建对象。</p></li><li><p>在方法体中调用参数的方法</p><p>如果调用方法的时候传递进来的值是 null，也要产生 NullPointerException 异常。</p><p>要避免程序产生这种异常，比较好的解决方法是在调用某个对象的方法时候判断这个对象是否可能为空，如果可能，则增加判断语句，例如上面的代码就可以写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        People p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = <span class="keyword">new</span> People();</span><br><span class="line">            p.setName(<span class="string">"张三"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            p.setName(<span class="string">"张三"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="ClassCastException-异常"><a href="#ClassCastException-异常" class="headerlink" title="ClassCastException 异常"></a>ClassCastException 异常</h2><p>从字面上看，是类型转换异常，通常是进行强制类型转换时候出现的错误。下面对产生 ClassCastException 异常的原因进行分析，然后给出这种异常的解决方法</p><h3 id="这种异常是如何产生的呢-1"><a href="#这种异常是如何产生的呢-1" class="headerlink" title="这种异常是如何产生的呢"></a>这种异常是如何产生的呢</h3><p>我们来看下面这段代码</p><p>这里 Animal 表示动物类，Dog 类表示狗类，Cat 类表示猫类，Dog 和 Cat 是 Animal 类的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Animal a1 = <span class="keyword">new</span> Dog();</span><br><span class="line">        Animal a2 = <span class="keyword">new</span> Cat();</span><br><span class="line">        Dog d1 = (Dog) a1;</span><br><span class="line">        Dog d2 = (Dog) a2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>Exception in thread “main” java.lang.ClassCastException: Cat cannot be cast to Dog<br>​    at Main.main(Main.java:6)</p></blockquote><p>第5行和第6行代码基本相同，从字面意思上来看都是把 Animal 强制转换为 Dog，但是第六行代码产生了 ClassCastException 异常，说 Cat cannot be cast to Dog 。</p><p>这下就很好理解了，我在 Java 基础七-多态里的<a href="https://cuizhe1023.github.io/2018/10/18/Java%E5%9F%BA%E7%A1%80%E4%B8%83/">向下转型</a>中有说到，因为 a1 本身就是 Dog 对象，所以它理所当然的可以转型为 Dog，a2 本身是 Cat 对象，所以它也理所当然的不能转为 Dog 。猫狗之间能互换吗？</p><p>从上面的例子可以看出，ClassCastException 是进行强制类型转换的时候产生的异常。</p><p>强制类型转换的前提是父类引用指向的对象的类型是子类的时候才可以进行强制类型转换，如果父类引用指向的对象类型不是子类的时候就会产生 ClassCastException 异常。</p><p>遇到这个异常该怎么办呢？如果你知道要访问的对象的具体类型，直接转换成该类型即可。如果不能确定类型可以通过下面的两种方式进行处理（假设对象为 o ）：</p><ul><li>通过<code>o.getClass().getName()</code>&gt;得到具体的类型，可以通过输出语句输出这个类型，然后根据类型进行具体的处理</li><li>通过<code>if(o instanceof 类型)</code>的语句来判断 o 的类型是什么</li></ul><h2 id="ArrayIndexOutOfBoundsException-异常"><a href="#ArrayIndexOutOfBoundsException-异常" class="headerlink" title="ArrayIndexOutOfBoundsException 异常"></a>ArrayIndexOutOfBoundsException 异常</h2><p>这是一个非常常见的异常，从名字上看是数组下标越界错误，解决这个异常的方法就是查看为什么数组下标越界。</p><p>下面有一个错误实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>1 2 3 4 5 Exception in thread “main” java.lang.ArrayIndexOutOfBoundsException: 5<br>​    at Main.main(Main.java:5)</p></blockquote><p>1.我们可以看到错误在第5行</p><p>2.发生错误的时候，下标的值是5</p><p>接下来，我们分析为什么下标值是5的会出错就可以了。</p><h2 id="NumberFormatException-异常"><a href="#NumberFormatException-异常" class="headerlink" title="NumberFormatException 异常"></a>NumberFormatException 异常</h2><p>数字转换异常，在把一个表示数字的字符串转换成数字类型的时候会后可能会报这个异常，原因是作为参数的字符串不是由数字组成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String num1 = <span class="string">"123"</span>;</span><br><span class="line">        String num2 = <span class="string">"123 "</span>;</span><br><span class="line">        System.out.println(Integer.parseInt(num1));</span><br><span class="line">        System.out.println(Integer.parseInt(num2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>123<br>Exception in thread “main” java.lang.NumberFormatException: For input string: “123 “<br>​    at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)<br>​    at java.lang.Integer.parseInt(Integer.java:580)<br>​    at java.lang.Integer.parseInt(Integer.java:615)<br>​    at Main.main(Main.java:6)</p></blockquote><p>这是因为 num2 后面有一个空格。</p><h2 id="堆栈溢出和内存溢出"><a href="#堆栈溢出和内存溢出" class="headerlink" title="堆栈溢出和内存溢出"></a>堆栈溢出和内存溢出</h2><p>在递归调用的时候可能会产生堆栈溢出的情况，因为递归调用的时候需要把调用的状态保存起来，如果递归的深度达到一定程度，将产生堆栈溢出的异常。</p><p>如果虚拟机内存比较小，而程序对内存要求比较高，则可能产生内存溢出错误</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;异常字面翻译就是“意外、例外”的意思，也就是说非正常情况。&lt;/p&gt;
&lt;p&gt;在程序运行过程中，意外发生的情况，背离我们程序本身的意图的表现，都可以理解为异常&lt;/p&gt;
&lt;p&gt;Java 中的异常本质上是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="异常" scheme="https://cuizhe1023.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构一--数组</title>
    <link href="https://cuizhe1023.github.io/2018/10/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/"/>
    <id>https://cuizhe1023.github.io/2018/10/23/数据结构一/</id>
    <published>2018-10-23T13:33:42.000Z</published>
    <updated>2018-10-25T03:31:43.615Z</updated>
    
    <content type="html"><![CDATA[<p>所谓数组，就是<strong>相同类型的数据</strong>按照<strong>顺序</strong>组成的一种引用数据类型。</p><a id="more"></a><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。</p><p>Java 语言中提供的数组是用来存储固定大小的同类型元素。</p><h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><p>在 Java 中有两种声明数组的方式</p><ul><li><p>type[] 变量名</p><p>int[] myIntArray;    //首选的方法</p></li><li><p>type 变量名[]</p><p>int myIntArray[];    //效果相同，但不是首选的方法</p></li></ul><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>Java 中使用 new 操作符来创建数组</p><ul><li><p>语法格式一：先声明后创建</p><p>type[] 变量名;</p><p>变量名 = new type[数组中元素的个数];</p><p>int[] arr;</p><p>arr = new int[10];</p><p>创建一个长度为10的数组</p></li><li><p>语法格式二：声明的同时创建数组</p><p>type 变量名[] = new type[数组中元素的个数];</p><p>int[] arr = new int[10]；</p><p>创建一个长度为10的数组</p></li></ul><p><strong>注意：</strong>数组长度必须指定</p><blockquote><p>以上两种方式都叫做动态初始化，也就是说，只有在程序运行之后，你才能知道数组里到底存了那些数据。</p><p>语法格式二的命名方式 C 和 C++ 程序员比较熟悉，但是 Java 官方推荐使用第一种，一看知道是 int 型数组，叫 arr。</p></blockquote><ul><li><p>静态初始化：int[] arr = new int[]{1,2,3};</p><p>在定义的时候直接初始化，大括号里就是数组的值</p></li><li><p>隐式初始化：数据类型[] 数组名 = {value0，value1…valuek};</p><p>可以不写 new ,直接使用大括号，其实本质上还是调用了 new 的，只是可以不写出来而已，所以叫隐式初始化。</p></li></ul><blockquote><p>我们回过头来看看下面这句代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]；</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这句代码都做了什么？</p><blockquote><p>1.int[] arr：定义了一个 int 型数组的引用，名字叫做 arr，存放在栈中</p><p>2.new int[10]：初始化了一个长度为10的 int 型数组，在堆中开辟相应大小的内存</p><p>3.int[] arr = new int[10]：将堆中开辟的数组内存地址赋值给数组引用 arr</p></blockquote><p>这样，就可以通过 arr 这个变量，来操作这个数组了</p><p>是不是觉得这个过程很熟悉？没错！我们创建对象的过程也是这样的！那是不是证明，数组其实是一个对象呢？</p><p><strong>也没错！</strong> Java 中的数组的确是一个对象，但是是一个特殊的对象，实在是太特殊了，以致我们都不好把它多做对象处理。</p><p>这个数组对象并不是从某个类实例化来的，而是由JVM直接创建的，因此查看类名的时候会发现是很奇怪的样子，这个直接创建的对象的父类就是Object，所以可以调用Object中的所有方法，包括你用到的toString()。</p><h2 id="数组在内存中的存储"><a href="#数组在内存中的存储" class="headerlink" title="数组在内存中的存储"></a>数组在内存中的存储</h2><p>数组会被分配连续的内存空间</p><p>比如，我们定义一个数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 定义数组</span></span><br><span class="line">        <span class="keyword">double</span>[] myList = <span class="keyword">new</span> <span class="keyword">double</span>[size];</span><br><span class="line">        myList[<span class="number">0</span>] = <span class="number">5.6</span>;</span><br><span class="line">        myList[<span class="number">1</span>] = <span class="number">4.5</span>;</span><br><span class="line">        myList[<span class="number">2</span>] = <span class="number">3.3</span>;</span><br><span class="line">        myList[<span class="number">3</span>] = <span class="number">13.2</span>;</span><br><span class="line">        myList[<span class="number">4</span>] = <span class="number">4.0</span>;</span><br><span class="line">        myList[<span class="number">5</span>] = <span class="number">34.33</span>;</span><br><span class="line">        myList[<span class="number">6</span>] = <span class="number">34.0</span>;</span><br><span class="line">        myList[<span class="number">7</span>] = <span class="number">45.45</span>;</span><br><span class="line">        myList[<span class="number">8</span>] = <span class="number">99.993</span>;</span><br><span class="line">        myList[<span class="number">9</span>] = <span class="number">11123</span>;</span><br><span class="line">        <span class="comment">// 计算所有元素的总和</span></span><br><span class="line">        <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            total += myList[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"总和为： "</span> + total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它在内存空间中的存储如下图所示：</p><p><img src="/2018/10/23/数据结构一/数组在内存中的存储.jpg" alt="数组在内存中的存储"></p><p>若数组没有赋值，则整型数组的默认值为0，其他类型的数组按照数据类型确定数组的默认值。</p><h1 id="处理数组"><a href="#处理数组" class="headerlink" title="处理数组"></a>处理数组</h1><p>数组的元素类型和数组的大小都是确定的，所以当处理数组元素的时候，我们通常用基本循环或者 foreach 循环</p><p>下面的例子就展示了数组的创建、初始化和操纵数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] myList = &#123;<span class="number">1.9</span>, <span class="number">2.9</span>, <span class="number">3.5</span>, <span class="number">3.4</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"打印数组："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myList.length; i++) &#123;</span><br><span class="line">            System.out.print(myList[i] + <span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"计算所有元素的和"</span>);</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myList.length; i++) &#123;</span><br><span class="line">            sum += myList[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"数组myList元素的和为："</span> + sum);</span><br><span class="line">        <span class="keyword">double</span> max = myList[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myList.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max&lt;myList[i])&#123;</span><br><span class="line">                max = myList[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"数组myList中的最大值为："</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>打印数组：<br>1.9  2.9  3.5  3.4<br>计算所有元素的和<br>数组myList元素的和为：11.700000000000001<br>数组myList中的最大值为：3.5</p></blockquote><h2 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h2><p>foreach 循环可以在不适用下标的情况下遍历数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] myList = &#123;<span class="number">1.9</span>, <span class="number">2.9</span>, <span class="number">3.5</span>, <span class="number">3.4</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"打印数组："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> i :</span><br><span class="line">                myList) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>打印数组：<br>1.9  2.9  3.5  3.4  </p></blockquote><h2 id="数组作为函数的参数"><a href="#数组作为函数的参数" class="headerlink" title="数组作为函数的参数"></a>数组作为函数的参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] myList = &#123;<span class="number">1.9</span>, <span class="number">2.9</span>, <span class="number">3.5</span>, <span class="number">3.4</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"打印数组:"</span>);</span><br><span class="line">        printArray(myList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">double</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> i :</span><br><span class="line">                arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>打印数组:<br>1.9  2.9  3.5  3.4  </p></blockquote><h2 id="数组作为函数的返回值"><a href="#数组作为函数的返回值" class="headerlink" title="数组作为函数的返回值"></a>数组作为函数的返回值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] myList = &#123;<span class="number">1.9</span>, <span class="number">2.9</span>, <span class="number">3.5</span>, <span class="number">3.4</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"打印数组:"</span>);</span><br><span class="line">        <span class="keyword">double</span>[] result = reverse(myList);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> i :</span><br><span class="line">                result) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] reverse(<span class="keyword">double</span>[] list) &#123;</span><br><span class="line">        <span class="keyword">double</span>[] result = <span class="keyword">new</span> <span class="keyword">double</span>[list.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = result.length - <span class="number">1</span>; i &lt; list.length; i++, j--) &#123;</span><br><span class="line">            result[j] = list[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>打印数组:<br>3.4  3.5  2.9  1.9  </p></blockquote><h2 id="数组内容的比较"><a href="#数组内容的比较" class="headerlink" title="数组内容的比较"></a>数组内容的比较</h2><p>数组内容的比较可以通过 equals() 吗？我们先来看个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(a.equals(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>false</p></blockquote><p>所以，不能直接用 equals() 比较数组内容。那么该怎么比较呢？</p><p>有两种方法：一种是自己实现，另一种是利用 Arrays。</p><p>Arrays 中的方法全是static的。其中包括了 equals() 方法的各种重载版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEquals</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a==<span class="keyword">null</span> || b==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.length!=b.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i]!=b[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(isEquals(a,b));</span><br><span class="line">        System.out.println(Arrays.equals(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>true<br>true</p></blockquote><h2 id="Arrays类的使用"><a href="#Arrays类的使用" class="headerlink" title="Arrays类的使用"></a>Arrays类的使用</h2><p>Arrays 能方便的操作数组，他提供的方法都是静态的。</p><p>具有以下功能</p><ul><li>对数组赋值：通过 fill 方法</li><li>对数组排序：用过 sort 方法，按升序。</li><li>比较数组：通过 equals 方法，比较数组中的元素是否相等</li><li>查找数组元素：通过 binarySearch 方法能对<strong>排序好的数组</strong>进行二分查找。</li><li>…….</li></ul><hr><h1 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h1><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。</p><p>其实 Java 只有一维数组，但是由于数组可以存放任意类型的数据，当然也就可以存放数组了，这个时候，就可以模拟多维数组了。</p><p>基本的定义方法同样有两种</p><blockquote><p>type[][] i = new type[2][3];//（推荐）</p><p>type i[][] = new type[2][3];//（推荐）</p></blockquote><h2 id="变长的二维数组"><a href="#变长的二维数组" class="headerlink" title="变长的二维数组"></a>变长的二维数组</h2><p>二维数组的每个元素是一个一维数组，这些数组不一定都是等长的。</p><p>声明二维数组的时候可以只指定第一维的大小，空缺处第二维的大小，之后在指定不同长度的数组。但是注意，第一维大小不能空缺（可以指定行数不指定列数，不能只指定列数不指定行数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维数组也可以在定义的时候初始化，使用花括号的嵌套完成，这时候不指定两个维数的大小，并且根据初始化值的个数不同，可以生成不同长度的数组元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>&#125;,&#123;<span class="number">7</span>,&#125;,&#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>有时候，你需要一个方法，但是你调用它之前不知道要传递几个参数给它，这个时候你就需要可变参数了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(add(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">        System.out.println(add(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> ...args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            sum = sum + args[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那个奇怪的<code>int ...args</code>就是可变参数，这样你就可以传递任意个你想传递的数据了。</p><p>java把可变参数当做数组处理。</p><blockquote><p><strong>注意：</strong>可变参数必须位于最后一项。当可变参数个数多余一个时，必将有一个不是最后一项，所以只支持有一个可变参数。因为参数个数不定，所以当其后边还有相同类型参数时，java无法区分传入的参数属于前一个可变参数还是后边的参数，所以只能让可变参数位于最后一项。</p></blockquote><h1 id="面试中关于数组的常见问题"><a href="#面试中关于数组的常见问题" class="headerlink" title="面试中关于数组的常见问题"></a>面试中关于数组的常见问题</h1><h2 id="寻找数组中第二小的元素"><a href="#寻找数组中第二小的元素" class="headerlink" title="寻找数组中第二小的元素"></a>寻找数组中第二小的元素</h2><p>1.做容易想到的方法，先排序，然后找到第二个数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] array=&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">31</span>,<span class="number">27</span>,<span class="number">27</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"第二大的是:"</span> + FindSecMax(array));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FindSecMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> sec_max = arr[arr.length-<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> sec_max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>第二大的是:27</p></blockquote><p>不过这个方法的时间复杂度和空间复杂度都比较大。</p><p>2.先定义两个变量：一个变量用来存储数组的最大数，初始值为数组首元素，另一个变量用来存储第二大的数，初始值为最小负整数，然后遍历数组元素，如果数组元素的值比最大数变量还大，更新最大数；若数组元素的值比最大值还小，则与第二大的数比较，若该数比第二大数大，则更新第二大的数；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] array=&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">31</span>,<span class="number">27</span>,<span class="number">27</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"第二大的是:"</span> + FindSecMax(array));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FindSecMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sec_max=Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&gt;max)&#123;</span><br><span class="line">                sec_max = max;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i]&gt;sec_max)&#123;</span><br><span class="line">                    sec_max = arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sec_max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>第二大的是:27</p></blockquote><h2 id="合并两个数组"><a href="#合并两个数组" class="headerlink" title="合并两个数组"></a>合并两个数组</h2><p>不管数组有没有顺序，都有一个统一的思路：定义一个新数组，长度为两个数组长度之和，然后对新数组排序</p><ul><li>如果数组是有序的<ul><li>定义一个新数组，长度为两个数组长度之和</li><li>分别定义 i：a数组下标, j：b数组下标, k：新数组下标</li><li>按位循环比较两个数组，较小元素的放入新数组，下标加一（较大元素对应的下标不加一），直到某个小标等于数组长度时退出循环</li><li>再写两个 while 循环来保证两个数组作比较完后剩下的数组还能顺利传入</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[] arrayA=&#123;1,8,3,6,9,3,5,7,2,6,18,19,20,20,31,27,27&#125;;</span></span><br><span class="line"><span class="comment">//        int[] arrayB = &#123;37,3,8,85,87,44,22,39,40,80,58,10,69,75,90&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] arrayA = &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arrayB = &#123;<span class="number">37</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">85</span>,<span class="number">87</span>&#125;;</span><br><span class="line">        Arrays.sort(arrayA);</span><br><span class="line">        Arrays.sort(arrayB);</span><br><span class="line">        System.out.print(<span class="string">"arrayA："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i :</span><br><span class="line">                arrayA) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.print(<span class="string">"arrayB："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i :</span><br><span class="line">                arrayB) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并两个有序数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arrayC = combineSortedArray(arrayA,arrayB);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.print(<span class="string">"arrayC："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i :</span><br><span class="line">                arrayC) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] combineSortedArray(<span class="keyword">int</span>[] arrA, <span class="keyword">int</span>[] arrB)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arrA == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arrB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arrB == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arrA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] arrayC = <span class="keyword">new</span> <span class="keyword">int</span>[arrA.length+arrB.length];</span><br><span class="line">        System.out.println(arrayC.length);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; arrA.length &amp;&amp; j &lt; arrB.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arrA[i] &lt;= arrB[j])&#123;</span><br><span class="line">                arrayC[k++] = arrA[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                arrayC[k++] = arrB[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i&lt; arrA.length)&#123;</span><br><span class="line">            arrayC[k++] = arrA[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j&lt; arrB.length)&#123;</span><br><span class="line">            arrayC[k++] = arrB[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayC;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果数组是无序的<ul><li>将两个数组分别排序，然后按照上面的思路</li></ul></li></ul><h2 id="重新排列数组中的正值和负值"><a href="#重新排列数组中的正值和负值" class="headerlink" title="重新排列数组中的正值和负值"></a>重新排列数组中的正值和负值</h2><p>给定一个包含正数和负数的整数数组，重新排列它，使得所有的负数排在前面，所有的正数排在后面。正数间和负数间的相对顺序保持不变。</p><p>eg： 给定 [-1,2,-2,3,5,-4], 重新排列后变成 [-1,-2,-4,2,3,5]</p><ul><li>思路一：先遍历第一遍，将负数挑出来放在一个新的数组中，再遍历一遍，将正数放进去</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arrayA = &#123;<span class="number">1</span>,<span class="number">7</span>,-<span class="number">5</span>,-<span class="number">12</span>,-<span class="number">13</span>,<span class="number">99</span>,-<span class="number">6</span>,<span class="number">31</span>,<span class="number">15</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arrayB = positiveAndMinus(arrayA);</span><br><span class="line">        System.out.println(Arrays.toString(arrayB));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] positiveAndMinus(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                result[j] = arr[i];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                result[j] = arr[i];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>思路二：冒泡排序的一种改进，将负数逐个“冒”出来。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[]x=&#123;<span class="number">1</span>,<span class="number">7</span>,-<span class="number">5</span>,-<span class="number">12</span>,-<span class="number">13</span>,<span class="number">99</span>,-<span class="number">6</span>,<span class="number">31</span>,<span class="number">15</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=x.length-<span class="number">1</span>;i&gt;p;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x[i]&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j=i;</span><br><span class="line">                <span class="keyword">while</span>(j!=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> t=x[j];</span><br><span class="line">                    x[j]=x[j-<span class="number">1</span>];</span><br><span class="line">                    x[j-<span class="number">1</span>]=t;<span class="comment">//交换</span></span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> i--;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓数组，就是&lt;strong&gt;相同类型的数据&lt;/strong&gt;按照&lt;strong&gt;顺序&lt;/strong&gt;组成的一种引用数据类型。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://cuizhe1023.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数组" scheme="https://cuizhe1023.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="数据结构" scheme="https://cuizhe1023.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java基础七--内部类</title>
    <link href="https://cuizhe1023.github.io/2018/10/22/Java%E5%9F%BA%E7%A1%80%E4%B8%83-%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>https://cuizhe1023.github.io/2018/10/22/Java基础七-内部类/</id>
    <published>2018-10-22T14:07:13.803Z</published>
    <updated>2018-10-23T09:39:36.472Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。</p><p>与之对应，包含内部类的类被称为外部类。</p><a id="more"></a><p>一般来说，内部类有四种：</p><ul><li>成员内部类</li><li>局部内部类</li><li>匿名内部类</li><li>静态内部类</li></ul><h1 id="为什么要使用内部类"><a href="#为什么要使用内部类" class="headerlink" title="为什么要使用内部类"></a>为什么要使用内部类</h1><p>在《Think in java》中有这样一句话：<strong>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</strong></p><p>在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，<strong>接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。</strong></p><hr><h1 id="内部类的优势"><a href="#内部类的优势" class="headerlink" title="内部类的优势"></a>内部类的优势</h1><ul><li><p>内部类提供了更好的封装，可以把内部类隐藏在外部类之中，不允许同一个包中的其他类访问该类，更好的实现了信息隐藏。</p></li><li><p>也是最吸引人的原因，每个内部类都能独立地继承一个接口，而无论外部类是否已经继承了某个接口。<br>因此，内部类使多重继承的解决方案变得更加完整。<br>在项目中，需要多重继承，如果是两个接口，那么好办，接口支持多重继承。<br>如果是两个类呢？这时只有使用内部类了。</p></li></ul><hr><h1 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h1><p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;<span class="comment">//外部类</span></span><br><span class="line">    <span class="keyword">double</span> r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span></span>&#123;<span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Draw Sahpe."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看起来，Draw 类像是 Circle 类的一个成员，Circle 称为外部类，Draw 类称为 Circle 类的成员内部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括 private 成员和静态成员）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(r);<span class="comment">//外部类的private成员</span></span><br><span class="line">            System.out.println(count);<span class="comment">//外部类的静态成员</span></span><br><span class="line">            System.out.println(<span class="string">"Draw Sahpe."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然成员内部类可以无条件的访问外部类的成员，但是外部类想访问成员内部类的成员缺不是那么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">        getDrawInstance().drawSahpe();      <span class="comment">//必须先创建成员内部类的对象，再进行访问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Draw <span class="title">getDrawInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span></span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(r);<span class="comment">//外部类的private成员</span></span><br><span class="line">            System.out.println(<span class="string">"Draw Sahpe."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员内部类是依附于外部类而成在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Inner inner = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inner == <span class="keyword">null</span>)&#123;</span><br><span class="line">            inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一种方法：外部类对象.new 内部类</span></span><br><span class="line">        Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">        Outter.Inner inner = outter.new Inner();</span><br><span class="line">        <span class="comment">//第二种方法：外部类对象.获取方法</span></span><br><span class="line">        Outter.Inner inner1 = outter.getInnerInstance();</span><br><span class="line">        <span class="comment">//第三种方法：new 外部类.new 内部类</span></span><br><span class="line">        Outter.Inner inner2 = <span class="keyword">new</span> Outter().new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类可以拥有 private 访问权限、protected 访问权限、public 访问权限及包访问权限。比如上面的例子，如果成员内部类 Inner 用 private 修饰，则只能在外部类的内部访问，如果用 public 修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被 public 和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>内部类在外部使用时，无法直接实例化，需要借由外部类信息才能完成实例化</li><li>成员内部类中不能存在任何static的变量和方法</li><li>内部类的访问修饰符，可以任意，但是访问范围会受到影响</li><li>内部类可以直接访问外部类的成员；如果出现同名属性，有限访问内部类中定义的</li><li>可以使用<strong>外部类.this.成员</strong>的方法，访问外部类中同名的信息</li><li>外部类访问内部类信息，需要通过内部类实例，无法直接访问</li><li>内部类编译后.class文件命名:<strong>外部类$内部类.class</strong></li><li>内部类中可以包含与外部类相同方法签名的方法，内部类对象在调用的时候调用的是内部类中的方法</li></ul><hr><h1 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h1><p>有这样一种内部类，它是嵌套在方法和作用域内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//局部内部类 Inner</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"局部内部类..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul><li><p>局部内部类类似方法的局部变量，所以在类外或者类的其他方法中不能访问这个内部类，但这并不代表局部内部类的实例和定义了它的方法中的局部变量具有相同的生命周期。</p><p><img src="/2018/10/22/Java基础七-内部类/局部内部类.png" alt="局部内部类"></p><p>我们可以看到，这里的局部内部类 Inner 定义在了一个 if 条件作用域中，因此，在 if 之外的部分，尽管没有离开 function() 方法，就会编译报错，无法访问到 Inner 这个内部类。因此，还要广义的理解局部内部类的含义和访问条件，不可以片面的理解为仅仅是方法中定义的内部类。</p></li><li><p>只能在方法内部，局部内部类定义之后使用，不存在外部可见性问题，因此没有访问修饰符，即 class 前面不可以添加public、private、protected、static</p></li><li><p>不能再局部内部类中使用可变的局部变量</p></li><li><p>类中不能包含静态成员</p></li><li><p>类中可以包含final、abstract修饰的成员</p></li></ul><p>综上，就是局部内部类的知识，其实局部内部类的名气远没有匿名内部类的名气大，但是作为一个匿名内部类的父概念，其定义了匿名内部类和普通的局部内部类的概念和特性，因此可以作为匿名内部类的知识补充。</p><hr><h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><p>匿名内部类也就是没有名字的内部类。</p><p>正因为没有名字，所以匿名内部类只能用一次，它通常是用来简化代码编写</p><p>但使用匿名内部类还有一个前提条件:必须继承一个父类或实现一个接口</p><p>这应该是我最经常用的内部类了，写 Android 的时候，使用点击事件就会用到它，来举个例子吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">  setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">  bt = findViewById(R.id.bt1);</span><br><span class="line">  <span class="comment">//1.匿名内部类</span></span><br><span class="line">  bt.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      Log.i(<span class="string">"匿名内部类"</span>, <span class="string">"点击事件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是匿名内部类的使用。代码中需要给 Button 设置一个监听器对象，使用匿名内部类能够在实现父类或者接口的方法的情况下同时产生一个相应的对象，但是前提是父类或者这个接口的方法是存在的。当然，也可以按照下面这么写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setListener</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bt.setOnClickListener(<span class="keyword">new</span> Listener1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Listener1</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      Log.i(<span class="string">"匿名内部类"</span>, <span class="string">"点击事件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的写法虽然能达到同样的效果，但是及冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也不能有访问修饰符和 static 修饰符的。</p><h2 id="匿名内部类初始化"><a href="#匿名内部类初始化" class="headerlink" title="匿名内部类初始化"></a>匿名内部类初始化</h2><p>我们一般用构造器来完成某个实例的初始化工作，但是匿名内部类是没有构造器的，那怎么来初始化匿名内部类呢？答案是使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>匿名内部类有不能的表现形式，下面为大家展示一下：</p><h3 id="继承式的匿名内部类"><a href="#继承式的匿名内部类" class="headerlink" title="继承式的匿名内部类"></a>继承式的匿名内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Driving another car"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        car.drive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>Driving another car</p></blockquote><p>引用变量不是引用 Car 对象，而是 Car 匿名子类的对象</p><p>建立匿名内部类的关键是重写父类的一个或者多个方法，这里再强调一下，是重写父类的方法，而不是建立新的方法。因为父类的引用不可能调用父类本身没有的方法，所以建立新的方法是多余的。</p><h3 id="接口式的匿名内部类"><a href="#接口式的匿名内部类" class="headerlink" title="接口式的匿名内部类"></a>接口式的匿名内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vehicle v = <span class="keyword">new</span> Vehicle() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Driving a car"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>Driving a car</p></blockquote><p>这段代码很奇怪，乍一看以为实例化了个接口。事实并非如此，接口式的匿名内部类是实现了一个接口的匿名类。而且只能实现一个借口。</p><h3 id="参数式的匿名内部类"><a href="#参数式的匿名内部类" class="headerlink" title="参数式的匿名内部类"></a>参数式的匿名内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doStuff</span><span class="params">(Foo f)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BarOne</span> <span class="keyword">extends</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doStuff</span><span class="params">(Foo f)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Bar b = <span class="keyword">new</span> BarOne();</span><br><span class="line">        b.doStuff(<span class="keyword">new</span> Foo() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"foofy"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面3个例子可以看出，只要一个类是抽象的或者是一个接口，那么其子类中的方法都可以使用匿名内部类来实现。最常用的情况就是在多线程的实现上，因为要实现多线程必须继承 Thread 类或是实现 Runable 接口</p><h3 id="Thread-类的匿名内部类实现"><a href="#Thread-类的匿名内部类实现" class="headerlink" title="Thread 类的匿名内部类实现"></a>Thread 类的匿名内部类实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Runnable-接口的匿名内部类实现"><a href="#Runnable-接口的匿名内部类实现" class="headerlink" title="Runnable 接口的匿名内部类实现"></a>Runnable 接口的匿名内部类实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><ul><li>匿名内部类没有类型名称、实例对象名称</li><li><p>编译后的文件命名：外部类$数字.class</p></li><li><p>无法使用private、public、protected、abstract、static修饰，匿名内部类不能出现抽象方法</p></li><li>无法编写构造方法，可以添加构造代码块</li><li>不能出现静态成员</li><li>匿名内部类可以实现接口也可以继承父类，但不可以兼得</li><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现接口的所有抽象方法</li></ul><hr><h1 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h1><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字 static 。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非 static 成员变量或方法。这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非 static 成员就会产生矛盾，因为外部类的非 static 必须依附于具体的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"外部类"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是外部类的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"这是内部类的静态方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Outter().say();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Outter().name + <span class="string">"到此一游"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outter.Inner in = <span class="keyword">new</span> Outter.Inner();</span><br><span class="line">        System.out.println(in.print());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>这是外部类的静态方法<br>外部类到此一游</p></blockquote><p>可以看到，如果用 static 将内部类静态化，那么内部类就只能访问外部类的静态成员变量，具有局限性。</p><p>其次，因为内部类被静态化，因此 Outter.Inner 可以当做一个整体看，可以直接 new 出内部类的对象。(因为类名访问 static ，生不成外部类对象都没关系)</p><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><ul><li><p>静态内部类中，只能直接访问外部类的静态成员，如果需要调用非静态成员，可以通过对象实例</p><p><code>new Outter().say();</code> 这样调用</p></li><li><p>静态内部类对象实例时，可以不依赖于外部类对象</p></li><li><p>可以通过<strong>外部类.内部类.静态成员</strong>的方式，访问内部类中的静态成员</p></li><li><p>当内部类属性与外部类属性同名时，默认直接调用内部类中的成员</p></li><li><p>如果需要访问外部类中的静态属性，则可以通过<strong>外部类.属性</strong>的方式</p></li><li><p>如果需要访问外部类中的非静态属性，则可以通过<strong>new 外部类().属性</strong>的方式</p></li></ul><hr><h1 id="接口中的内部类"><a href="#接口中的内部类" class="headerlink" title="接口中的内部类"></a>接口中的内部类</h1><p>我们在实际开发中，如果想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么接口内部的嵌套类会显得很方便。也就是说，在接口中可以含有内部类。</p><ul><li>首先创建接口，接口中定义了普通内部类 InnerClass 和抽象内部类 AbInnerClass</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IOuterInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> TEMP = <span class="number">100</span>;<span class="comment">//常亮</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">abMethod</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">deMethod</span><span class="params">()</span></span>&#123;<span class="comment">//jdk1.8后可添加</span></span><br><span class="line">        System.out.println(<span class="string">"接口中的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stMethod</span><span class="params">()</span></span>&#123;<span class="comment">//jdk1.8后可添加</span></span><br><span class="line">        System.out.println(<span class="string">"接口中的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"接口中可定义普通成员内部类"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbInnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abInfo</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"接口中可以定义抽象成员内部类"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>普通成员内部类的实例化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> <span class="keyword">implements</span> <span class="title">IOuterInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取接口中内部类方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">getInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一种实例化对象方式</span></span><br><span class="line">        <span class="comment">//通过 接口名.类名 进行实例化</span></span><br><span class="line">        IOuterInterface.InnerClass innerClass = <span class="keyword">new</span> IOuterInterface.InnerClass();</span><br><span class="line">        innerClass.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种实例化对象方式</span></span><br><span class="line">        <span class="comment">//通过在实现类中创建接口中内部类获取方法</span></span><br><span class="line">        <span class="comment">//用实现类对象调用获取方法</span></span><br><span class="line">        ClassDemo demo = <span class="keyword">new</span> ClassDemo();</span><br><span class="line">        demo.getInner().show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>接口中可定义普通成员内部类<br>接口中可定义普通成员内部类</p></blockquote><ul><li>抽象成员内部类的实例化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbClassDemo</span> <span class="keyword">implements</span> <span class="title">IOuterInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//继承抽象类AbInnerClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbDemo</span> <span class="keyword">extends</span> <span class="title">AbInnerClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"重写了接口中国抽象类中的抽象方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一种实例化对象方式</span></span><br><span class="line">        <span class="comment">//通过 接口名.类名 进行实例化</span></span><br><span class="line">        <span class="comment">//但是对于抽象类而言，不能直接实例化，所以这里可以使用匿名内部类的方式</span></span><br><span class="line">        IOuterInterface.AbInnerClass abInner = <span class="keyword">new</span> IOuterInterface.AbInnerClass() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"重写抽象类中的抽象方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        abInner.abInfo();</span><br><span class="line">        abInner.info();</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//第二种实例化对象方式</span></span><br><span class="line">        <span class="comment">//在实现类中定义内部类继承接口中的抽象内部类</span></span><br><span class="line">        IOuterInterface.AbInnerClass abInnerOne = <span class="keyword">new</span> AbClassDemo().new AbDemo();</span><br><span class="line">        abInnerOne.abInfo();</span><br><span class="line">        abInnerOne.info();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>重写抽象类中的抽象方法<br>接口中可以定义抽象成员内部类</p><p>重写了接口中国抽象类中的抽象方法<br>接口中可以定义抽象成员内部类</p></blockquote><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>这里只是提供给大家几种实例化接口中内部类的思路和方式，大家也可以用其他方式去进行对象实例化，当然前提是要满足代码规则。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。&lt;/p&gt;
&lt;p&gt;与之对应，包含内部类的类被称为外部类。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="多态" scheme="https://cuizhe1023.github.io/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="内部类" scheme="https://cuizhe1023.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java基础七--接口</title>
    <link href="https://cuizhe1023.github.io/2018/10/18/Java%E5%9F%BA%E7%A1%80%E4%B8%83-%E6%8E%A5%E5%8F%A3/"/>
    <id>https://cuizhe1023.github.io/2018/10/18/Java基础七-接口/</id>
    <published>2018-10-18T03:27:33.126Z</published>
    <updated>2018-10-21T02:28:11.914Z</updated>
    
    <content type="html"><![CDATA[<p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><a id="more"></a><p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p><p>除非实现接口的类是抽象类，否则该类要定义接口中的<strong>所有</strong>方法。</p><p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><h1 id="接口与类相似点"><a href="#接口与类相似点" class="headerlink" title="接口与类相似点"></a>接口与类相似点</h1><ul><li>一个接口可以有多个方法</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名</li><li>接口的字节码文件保存在 .class 结尾的文件中</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中</li></ul><h1 id="接口与类的区别"><a href="#接口与类的区别" class="headerlink" title="接口与类的区别"></a>接口与类的区别</h1><ul><li>接口不能用于实例化对象</li><li>接口没有构造方法</li><li>接口中所有的方法必须是抽象方法</li><li>接口不能包含成员变量，除了 static 和 final 变量</li><li>接口不是被类继承了，而是被类实现了</li><li>接口支持多继承</li></ul><h1 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h1><ul><li>接口中每个方法也是隐式抽象的，接口中的方法会被隐式的指定为 public abstract （只能是 public abstract，其他修饰符都会报错）</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）</li><li>接口中的方法不能再接口中实现，只能由实现了接口的类来实现接口中的方法</li></ul><h1 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h1><ul><li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的</li><li>接口中不能含有静态代码块以及静态方法（用 static 修饰的方法），而抽象类是可以有静态代码块和静态方法</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口</li></ul><h1 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口名[extends 父接口1，父接口2..]&#123;</span><br><span class="line">  零到多个常量定义...</span><br><span class="line">  零到多个抽象方法的定义...</span><br><span class="line">  零到多个默认方法的定义...（jdk1.8 新增）</span><br><span class="line">  零到多个静态方法的定义...（jdk1.8 新增）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interface 关键字用来声明一个接口。下面是接口声明的一个简单例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Animal &#123;</span><br><span class="line">    static int age = 6;</span><br><span class="line">    final String name = &quot;名字&quot;;</span><br><span class="line">    public void sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口的特性"><a href="#接口的特性" class="headerlink" title="接口的特性"></a>接口的特性</h1><ul><li>接口是隐式抽象的，当声明一个接口的时候，不必使用 abstract 关键字</li><li>接口中每一个方法也是隐式抽象的，声明时同样不需要 abstract 关键字</li><li>接口中的方法都是共有的</li></ul><h1 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h1><p>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象类</p><p>类使用 implements 关键字实现接口。在类声明中，implements 关键字放在 class 声明后面</p><p>实现一个接口的语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...implements 接口名[,其他接口名称,其他接口名称..,...]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">final</span> String name = <span class="string">"名字"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我不想跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫爱睡觉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cat c = <span class="keyword">new</span> Cat();</span><br><span class="line">        c.run();</span><br><span class="line">        c.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>我不想跑<br>猫爱睡觉</p></blockquote><p>重写接口中声明的方法时，需要注意以下规则：</p><ul><li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常</li><li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型</li><li>如果实现接口的类是抽象类，那么就没有必要实现该接口的方法</li></ul><p>在实现接口的时候，也要注意一些规则：</p><ul><li><p>一个类可以<strong>同时</strong>实现多个接口</p></li><li><p>一个类只能继承一个类，但是能实现多个接口</p></li><li>一个接口可以继承另一个接口，这和类之间的继承比较相似</li></ul><h1 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h1><p>上面说到，一个接口可以继承另一个接口，这和类之间的继承比较相似。接口之间的继承也是使用的 extedns 关键字，子接口继承父接口的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//猫科动物接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClimbTree</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虎类接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Cat</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shape</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//东北虎类实现虎类这个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManchuriaTiger</span> <span class="keyword">implements</span> <span class="title">Tiger</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shape</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClimbTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有一个父接口 Animal ，猫科动物接口 Cat 继承 Animal，而 Tiger 接口又继承 Cat 接口，最后ManchuriaTiger实现了 Tiger 接口。这时编译器提示需要实现接口中的方法。</p><p>Tiger 接口自己声明了一个方法，从 Cat 接口继承了一个方法，Cat 接口自己声明了一个方法，又从 Animal 接口继承了两个方法。这样，实现 Tiger 接口的 ManchuriaTiger 类需要实现四个方法。</p><h1 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h1><p>在 Java 中，类的多继承是不合法的，但是接口允许多继承</p><p>在接口的多继承中 extends 关键字只需要使用一次，在其后跟着继承接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Cat</span>,<span class="title">Animal</span></span></span><br></pre></td></tr></table></figure><p>以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Cat 及 Animal 可能定义或者是继承相同的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="多态" scheme="https://cuizhe1023.github.io/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="接口" scheme="https://cuizhe1023.github.io/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java基础七--抽象类</title>
    <link href="https://cuizhe1023.github.io/2018/10/18/Java%E5%9F%BA%E7%A1%80%E4%B8%83-%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>https://cuizhe1023.github.io/2018/10/18/Java基础七-抽象类/</id>
    <published>2018-10-18T03:26:57.362Z</published>
    <updated>2018-10-21T02:27:31.041Z</updated>
    
    <content type="html"><![CDATA[<p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p><a id="more"></a><p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p><p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p><p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><h1 id="抽象类和抽象方法的声明格式"><a href="#抽象类和抽象方法的声明格式" class="headerlink" title="抽象类和抽象方法的声明格式"></a>抽象类和抽象方法的声明格式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> &lt;类名&gt; </span>&#123;</span><br><span class="line">成员变量;</span><br><span class="line">  方法()&#123;</span><br><span class="line">      方法体</span><br><span class="line">    &#125;<span class="comment">//一般方法</span></span><br><span class="line">    <span class="keyword">abstract</span> 方法（）&#123;&#125;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal eating..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从例子中可以看出，抽象类是用关键字 abstract 修饰的。抽象类中有一种特殊方法，即用 abstract 关键字来修饰的方法，称为”抽象方法“。</p><hr><h1 id="抽象类和抽象方法的特点"><a href="#抽象类和抽象方法的特点" class="headerlink" title="抽象类和抽象方法的特点"></a>抽象类和抽象方法的特点</h1><ul><li><p>抽象方法不允许直接实例化，换句话说抽象类不能创建对象，他只能作为其他类的父类。但可以通过向上转型，指向实例化。</p></li><li><p>抽象方法只有声明，不能实现，也就是说仅有方法头，而没有方法体和操作实现。</p><p>如：<code>abstract void sleep()；</code></p></li></ul><hr><h1 id="抽象类的意义"><a href="#抽象类的意义" class="headerlink" title="抽象类的意义"></a>抽象类的意义</h1><ul><li><p>为其子类提供一个公共的类型（父类引用指向子类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal a = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure></li><li><p>封装子类中重复内容（成员变量和方法）</p></li><li><p>将父类设计成抽象类后，既可借由父子继承关系限制子类的设计随意性，在一定程度上避免了无意义父类的实例化</p></li></ul><hr><h1 id="重点注意"><a href="#重点注意" class="headerlink" title="重点注意"></a>重点注意</h1><ul><li><p>含有抽象方法的类，只能被定义成抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;<span class="comment">//这里报错了</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal eating..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象类不一定包含抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal eating..."</span>);<span class="comment">//一般方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在抽象类中的成员方法可以包括一般方法和抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal eating..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象类不能实例化，及时抽象类里不包含抽象方法 ，这个抽象类 也不能创建实例，抽象类的构造方法主要是用于被其子类调用</p><p>例子：</p><p>Animal 抽象类中不包含抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal eating..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类中实例化 Animal ，编译器会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();<span class="comment">//这里报错了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个类继承抽象类后，必须实现其所有抽象方法，否则也是抽象类，不同的子类对父类的抽象方法可以有不同的实现</p><p>如父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal eating..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则其子类 Cat 有两种做法</p><p>方案一：重写抽象方法 sleep()，使方法得以实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫要睡大觉！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我不想跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案二：子类 Cat 类也定义为抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;<span class="comment">//没有实现父类中的抽象方法，所以是抽象类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我不想跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>即使父类是具体的，但其子类也可以是抽象的，如 Object 是具体的，但可以创建抽象子类</p></li><li><p>abstract 方法不能用 static 和 private 修饰；对于类，不能同时用 final 和 abstract 修饰，因为 final 关键字使得类不可继承，而 abstract 修饰的类如果不可以继承将没有任何意义。两者放一起回起冲突</p></li></ul><hr><h1 id="一个完整的抽象类的例子"><a href="#一个完整的抽象类的例子" class="headerlink" title="一个完整的抽象类的例子"></a>一个完整的抽象类的例子</h1><p>父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象父类 Shape</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> r;</span><br><span class="line">    Circle()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建带参构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setR</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">3.14</span>*r*r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Circle c = <span class="keyword">new</span> Circle(<span class="number">3.5</span>);</span><br><span class="line">        System.out.println(<span class="string">"圆的面积为："</span>+c.area());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>圆的面积为：38.465</p></blockquote><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>抽象类不能被实例化，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象</li><li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类</li><li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现</li><li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法</li><li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="多态" scheme="https://cuizhe1023.github.io/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="抽象类" scheme="https://cuizhe1023.github.io/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java基础七--多态</title>
    <link href="https://cuizhe1023.github.io/2018/10/18/Java%E5%9F%BA%E7%A1%80%E4%B8%83/"/>
    <id>https://cuizhe1023.github.io/2018/10/18/Java基础七/</id>
    <published>2018-10-18T02:34:58.013Z</published>
    <updated>2018-10-21T02:25:11.129Z</updated>
    
    <content type="html"><![CDATA[<p>多态是同一个行为具有多个不同表现形式或形态的能力。</p><a id="more"></a><h1 id="多态的分类"><a href="#多态的分类" class="headerlink" title="多态的分类"></a>多态的分类</h1><ul><li>编译时多态（设计时多态）：方法重载</li><li>运行时多态：Java 运行时系统根据调用该方法的实例的类型来决定选择调用哪个方法则被称为运行时多态</li></ul><p>我们平时说的多态，多指运行时多态</p><hr><h1 id="多态的实现方法"><a href="#多态的实现方法" class="headerlink" title="多态的实现方法"></a>多态的实现方法</h1><ul><li><p>重写</p><p>这个内容写过了，可以访问 <a href="https://cuizhe1023.github.io/2018/10/17/Java%E5%9F%BA%E7%A1%80%E5%85%AD/">Java基础六</a> 中的<strong><em>重写 &amp; 重载</em></strong>。</p></li><li><p>接口</p><ul><li>生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。</li><li>java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 <a href="https://cuizhe1023.github.io/2018/10/18/Java%E5%9F%BA%E7%A1%80%E4%B8%83-%E6%8E%A5%E5%8F%A3/">Java基础七-接口</a> 这一章节的内容</li></ul></li><li><p>抽象类和抽象方法</p><p>详情请看<a href="https://cuizhe1023.github.io/2018/10/18/Java%E5%9F%BA%E7%A1%80%E4%B8%83-%E6%8A%BD%E8%B1%A1%E7%B1%BB/">Java基础七-抽象类</a> 。</p></li></ul><hr><h1 id="向上转型-amp-向下转型"><a href="#向上转型-amp-向下转型" class="headerlink" title="向上转型 &amp; 向下转型"></a>向上转型 &amp; 向下转型</h1><p>要转型，首先要有继承。</p><ul><li><p>向上类型转换（Upcast）：将子类对象转换为父类，父类可以是接口</p><p>隐式/自动类型转换，是小类型到大类型的转换。</p></li><li><p>向下类型转换（Downcast）：将父类型转换为子类型</p><p>强制类型转换，是大类型到小类型。</p></li><li><p>通过 instanceof 运算符，来解决引用对象的类型，避免类型转换的安全性问题，提高代码的健壮性。</p></li></ul><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>举一个大家都知道的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal eating..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狗吃肉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狗爱跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Cat();<span class="comment">//向上转型</span></span><br><span class="line">        animal.eat();</span><br><span class="line">        animal = <span class="keyword">new</span> Dog();</span><br><span class="line">        animal.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>猫吃鱼<br>狗吃肉</p></blockquote><p>这就是向上转型，向上转型是安全的，因为任何子类都继承并接受了父类的方法。从例子中也可以看出猫和狗都属于他们的父类——Animal，这是可行的。但是向下转型就不行，若所所有的动物都是猫或者都是狗就不成立的。（所以向下转型要通过强制类型转换）</p><p>Animal animal = new Cat(); 将子类对象 Cat 转换为父类对象 Animal 。这个时候 animal 这个引用调用的方法是子类方法。</p><h3 id="转型过程中需要注意的问题"><a href="#转型过程中需要注意的问题" class="headerlink" title="转型过程中需要注意的问题"></a>转型过程中需要注意的问题</h3><ul><li>向上转型时，子类单独定义的方法会丢失。比如上面 Dog 类中定义的 run 方法，当 animal 引用指向 Dog 类实例时是访问不到 run 方法的，<code>animal.run()；</code>会报错。</li><li>子类引用引用不能指向父类对象。<code>Cat c = (Cat)new Animal()</code>这样是不行的。</li></ul><h3 id="向上转型的应用"><a href="#向上转型的应用" class="headerlink" title="向上转型的应用"></a>向上转型的应用</h3><ul><li><p>当一个子类对象向上转型父类类型后，就被当成了父类的对象，所能调用的方法会减少，只能调用子类重写了父类的方法以及父类派生的方法（如 set(),get()方法），而不能调用子类独有的方法。</p><p>继续用上面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Cat();<span class="comment">//向上转型</span></span><br><span class="line">        animal.eat();</span><br><span class="line">        animal = <span class="keyword">new</span> Dog();</span><br><span class="line">        animal.eat();</span><br><span class="line">      <span class="comment">//如果调用 Dog 类中的 run() 方法。</span></span><br><span class="line">      animal.run();<span class="comment">//这个会报错，编译不通过</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以调用子类重写父类的方法 eat()，但调用子类独有的方法 run() 时就是无效的</p></li><li><p>父类中的静态方法是不允许被子类重写的</p><p>如父类 Animal 中含有静态方法 sleep()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal eating..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal sleep..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当子类 Cat 中也定义同名方法时，此时 sleep() 算 Cat 类自己独有的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫要睡大觉！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Cat();</span><br><span class="line">        animal.eat();</span><br><span class="line">        animal.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>猫吃鱼<br>animal sleep…</p></blockquote><p>实际上调用的是父类的静态方法 sleep()</p><p>这是因为父类的静态方法可以被子类继承，但是不能重写。</p></li></ul><h3 id="向上转型的好处"><a href="#向上转型的好处" class="headerlink" title="向上转型的好处"></a>向上转型的好处</h3><ul><li>减少重复代码，使代码变得简介</li><li>提高系统扩展性</li></ul><p>举个例子：比如，我现在有很多种类的动物，要喂它们吃东西。如果不用向上转型，那我需要这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Cat c)</span></span>&#123;</span><br><span class="line">  c.eat();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Dog d)</span></span>&#123;</span><br><span class="line">  d.eat();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">eat(<span class="keyword">new</span> Cat());</span><br><span class="line">eat(<span class="keyword">new</span> Dog());</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一种动物写一个方法，如果我有一万种动物，我不得写一万个方法？假设你很厉害，耐着性子写完了，突然又来一个新的动物，你是不是又要单独为它写一个 eat() 方法？</p><p>那如果我用向上转型呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Animal a)</span></span>&#123;</span><br><span class="line">    a.eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eat(<span class="keyword">new</span> Cat());</span><br><span class="line">eat(<span class="keyword">new</span> Cat());</span><br><span class="line">eat(<span class="keyword">new</span> Dog());</span><br><span class="line"><span class="comment">//.....</span></span><br></pre></td></tr></table></figure><p>这样代码是不是简洁了许多？而且这个时候，如果我又有一种新的动物加进来，我只需要实现它自己的类，让他继承Animal就可以了，而不需要为它单独写一个eat方法。是不是提高了扩展性？</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>多态的实现可以通过向上转型和动态绑定机制来完成，向上转型实现了将子类对象向上转型为父类类型，而动态绑定机制能识别出对象转型前的类型，从而自动调用该类的方法，两者相辅相成。</p><p>绑定就是将一个方法调用同一个方法所在的类连接到一起就是绑定。绑定分为静态绑定和动态绑定两种。</p><h3 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h3><p>在程序运行之前进行绑定（由编译器和链接程序完成的），也叫作前期绑定。</p><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>在程序运行期间由 JVM 根据对象的类型自动的判断应该调用那个方法，也叫做后期绑定。</p><h3 id="静态绑定的例子"><a href="#静态绑定的例子" class="headerlink" title="静态绑定的例子"></a>静态绑定的例子</h3><p>如有一个父类 Human，它派生出来三个字类 Chinese 类、American 类、British类，三个子类中都重写了父类中的 speak() 方法，在测试类中用静态绑定的方式调用方法 speak()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Human speak..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"speak chinese."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">American</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"speak American English."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">British</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"speak English."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Chinese c = <span class="keyword">new</span> Chinese();</span><br><span class="line">        c.speak();</span><br><span class="line">        American a = <span class="keyword">new</span> American();</span><br><span class="line">        a.speak();</span><br><span class="line">        British b = <span class="keyword">new</span> British();</span><br><span class="line">        b.speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种调用方式是在代码里指定的，编译时编译器就知道 c 调动的是 Chinese 中的 speak() 方法，a 调用的是 American 的 speak() 方法。</p><h3 id="动态绑定的例子"><a href="#动态绑定的例子" class="headerlink" title="动态绑定的例子"></a>动态绑定的例子</h3><p>如果我们在测试类中做如下改动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生成父类对象数组，数组长度为5。</span></span><br><span class="line">        Human[] humans = <span class="keyword">new</span> Human[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; humans.length; i++) &#123;</span><br><span class="line">            n = (<span class="keyword">int</span>) (Math.random()*<span class="number">3</span>);<span class="comment">//随机生成从0到2中的一个数</span></span><br><span class="line">            <span class="keyword">switch</span>(n)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    humans[i] = <span class="keyword">new</span> Chinese();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    humans[i] = <span class="keyword">new</span> American();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    humans[i] = <span class="keyword">new</span> British();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环输出，循环体中每个对象分别调用 speak() 方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; humans.length; i++) &#123;</span><br><span class="line">            humans[i].speak();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>speak English.<br>speak chinese.<br>speak English.<br>speak American English.<br>speak English.</p></blockquote><p>此时，Human 类中随机生成 Chinese 类、American 类和 British 类的对象，编译器不能根据代码直接确定调用那个类中的 speak() 方法，直到运行时才能根据产生的随机数 n 的值来确定 humans[i]到底代表哪一个子类的对象，这样才能最终确定调用的是哪个类中的 speak() 方法，这就是动态绑定。</p><h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><p>与向上转型相对应的就是向下转型了。向下转型是把父类对象转为子类对象。(请注意！这里是有坑的。)它是用子类引用指向父类实例。</p><p>下图，在进行转换是会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line">Cat c = a；</span><br></pre></td></tr></table></figure><p>这就告诉我们向下转型不能自动转换，我们需要强转，所以乡下转型又叫做强制类型转换。</p><p>正确的语句是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//还是上面的animal和cat dog</span></span><br><span class="line">Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line">Cat c = (Cat) a;</span><br><span class="line">c.eat();</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>猫吃鱼</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog d = (Dog) a;</span><br><span class="line">d.eat();</span><br></pre></td></tr></table></figure><blockquote><p>报错：java.lang.ClassCastException: Cat cannot be cast to Dog</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal a1 = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat c1 = (Cat) a1;</span><br><span class="line">c1.eat();</span><br></pre></td></tr></table></figure><blockquote><p>报错：java.lang.ClassCastException: Animal cannot be cast to Cat</p></blockquote><p>为什么第一段代码不报错呢？相比你也知道了，因为a本身就是 Cat 对象，所以它理所当然的可以向下转型为Cat，也理所当然的不能转为 Dog，你见过一条狗突然就变成一只猫这种现象？</p><p>而a1为 Animal 对象，它也不能被向下转型为任何子类对象。比如你去考古，发现了一个新生物，知道它是一种动物，但是你不能直接说，啊，它是猫，或者说它是狗。</p><h3 id="向下转型注意事项"><a href="#向下转型注意事项" class="headerlink" title="向下转型注意事项"></a>向下转型注意事项</h3><ul><li>向下转型的前提是父类对象指向的是子类对象（也就是说，在向下转型之前，它得先向上转型）</li><li>向下转型只能转型为本类对象，兄弟类之间不能进行强制类型转换。（猫是不能变成狗的）。</li></ul><blockquote><p>大概你会说，我特么有病啊，我先向上转型再向下转型？？</p><p>声明上转型对象是为了可以直接调用子类中重写的方法，但是不能调用子类新增的方法。而下转型对象可以调用子类新增的方法</p></blockquote><p>我们回到上面的问题：喂动物吃饭，吃了饭做点什么呢？不同的动物肯定做不同的事，怎么做呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Animal a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog)&#123;  </span><br><span class="line">        Dog d = (Dog)a;</span><br><span class="line">        d.eat();</span><br><span class="line">        d.run();<span class="comment">//狗有一个跑的方法      </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat)&#123;  </span><br><span class="line">        Cat c = (Cat)a;</span><br><span class="line">        c.eat();</span><br><span class="line">        System.out.println(<span class="string">"我也想跑，但是不会"</span>); <span class="comment">//猫会抱怨    </span></span><br><span class="line">    &#125; </span><br><span class="line">    a.eat();<span class="comment">//其他动物只会吃</span></span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">eat(<span class="keyword">new</span> Cat());</span><br><span class="line">eat(<span class="keyword">new</span> Cat());</span><br><span class="line">eat(<span class="keyword">new</span> Dog());</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>现在，你懂了么？这就是向下转型的简单应用，可能举得例子不恰当，但是也可以说明一些问题。</p><blockquote><p>敲黑板，划重点！看到那个 <strong>instanceof</strong> 了么？  </p></blockquote><h2 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h2><p>instanceof 运算符用来判断对象是否可满足某个特定类型实例特征，简单的来说，就是判断其左边对象是否为其右边类的实例，返回boolean类型的数据。可以用来判断继承中的子类的实例是否为父类的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对象实例化</span></span><br><span class="line">        Animal c = <span class="keyword">new</span> Cat();</span><br><span class="line">        Animal d = <span class="keyword">new</span> Dog();</span><br><span class="line">        <span class="comment">//用 instanceof 运算符判断对象是否满足某个特定对象实例特征</span></span><br><span class="line">        System.out.println(c <span class="keyword">instanceof</span> Animal);</span><br><span class="line">        System.out.println(c <span class="keyword">instanceof</span> Cat);</span><br><span class="line">        System.out.println(c <span class="keyword">instanceof</span> Dog);</span><br><span class="line">        System.out.println(c <span class="keyword">instanceof</span> Object);</span><br><span class="line"></span><br><span class="line">        System.out.println(d <span class="keyword">instanceof</span> Animal);</span><br><span class="line">        System.out.println(d <span class="keyword">instanceof</span> Cat);</span><br><span class="line">        System.out.println(d <span class="keyword">instanceof</span> Dog);</span><br><span class="line">        System.out.println(d <span class="keyword">instanceof</span> Object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>true<br>true<br>false<br>true<br>true<br>false<br>true<br>true</p></blockquote><hr><h1 id="抽象类-amp-抽象方法"><a href="#抽象类-amp-抽象方法" class="headerlink" title="抽象类 &amp; 抽象方法"></a>抽象类 &amp; 抽象方法</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>某个父类只是限定其子类应该包括怎样的方法，但不需要准确知道这些子类如何实现这些方法。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p> Java 中使用抽象类，限制实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>abstract 也可用于方法——抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>抽象类不能直接实例化，必须借助子类完成相应的实例化操作</li><li>子类如果没有重写父类中所有的抽象方法，则也要定义为抽象类</li><li>抽象方法所在的类一定是抽象类</li><li>抽象类中可以没有抽象方法</li></ul><hr><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul><li>接口定义了某一批类所需要遵守的规范</li><li>接口不关心这些类的内部数据，也不关心这些类里方法的实现细节，它只规定这些类里必须提供某些方法</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口[extends 父接口1，父接口2..]&#123;</span><br><span class="line">  零到多个常量定义...</span><br><span class="line">  零到多个抽象方法的定义...</span><br><span class="line">  零到多个默认方法的定义...（jdk1.8 新增）</span><br><span class="line">  零到多个静态方法的定义...（jdk1.8 新增）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ul><li>接口可以实现多继承，即一个子接口可以同时继承多个父接口</li><li>实现接口的类如果不能实现接口中所有待重写的方法，则必须设置为抽象类</li><li>一个类可以继承自一个父类，同时实现多个接口</li></ul><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><ul><li><p>在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类</p></li><li><p>与之对应，包含内部类的类被称为外部类</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多态是同一个行为具有多个不同表现形式或形态的能力。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="多态" scheme="https://cuizhe1023.github.io/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="向上转型&amp;向下转型" scheme="https://cuizhe1023.github.io/tags/%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java基础六--继承</title>
    <link href="https://cuizhe1023.github.io/2018/10/17/Java%E5%9F%BA%E7%A1%80%E5%85%AD/"/>
    <id>https://cuizhe1023.github.io/2018/10/17/Java基础六/</id>
    <published>2018-10-17T00:16:32.885Z</published>
    <updated>2018-10-21T02:29:11.767Z</updated>
    
    <content type="html"><![CDATA[<p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p><p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><a id="more"></a><h1 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h1><ul><li>继承是类与类之间的一种关系</li><li>使用已存在的类的定义作为基础建立新的类</li><li>新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</li><li>当两个类之间满足 “A is a B” 的关系，我们就说它们满足继承关系</li></ul><hr><h1 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h1><ul><li>利于代码复用</li><li>缩短开发周期</li></ul><hr><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><ul><li>使用 extends 实现继承</li><li>Java 只支持单继承，一个类只能有一个父类（也称为超类、基类） </li></ul><hr><h1 id="继承后的初始化顺序"><a href="#继承后的初始化顺序" class="headerlink" title="继承后的初始化顺序"></a>继承后的初始化顺序</h1><p>父类的静态成员</p><p>子类静态成员</p><p>父类对象构建【属性（赋值）、构造代码块、构造方法】</p><p>子类对象构建【属性（赋值）、构造代码块、构造方法】</p><hr><h1 id="Super关键字"><a href="#Super关键字" class="headerlink" title="Super关键字"></a>Super关键字</h1><h2 id="如何区分调用的是继承父类的方法还是子类自己重写的方法"><a href="#如何区分调用的是继承父类的方法还是子类自己重写的方法" class="headerlink" title="如何区分调用的是继承父类的方法还是子类自己重写的方法?"></a>如何区分调用的是继承父类的方法还是子类自己重写的方法?</h2><ul><li><p>访问父类成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.print();</span><br></pre></td></tr></table></figure></li><li><p>访问父类属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.name;</span><br></pre></td></tr></table></figure></li></ul><h2 id="子类对象实例化时，能否选择父类的构造形式（调用指定的构造方法）？"><a href="#子类对象实例化时，能否选择父类的构造形式（调用指定的构造方法）？" class="headerlink" title="子类对象实例化时，能否选择父类的构造形式（调用指定的构造方法）？"></a>子类对象实例化时，能否选择父类的构造形式（调用指定的构造方法）？</h2><ul><li><p>访问父类构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>();<span class="comment">//无参的构造方法</span></span><br><span class="line"><span class="keyword">super</span>(<span class="string">"name"</span>);<span class="comment">//有参的构造方法</span></span><br></pre></td></tr></table></figure></li><li><p>子类的构造过程中必须调用其父类的构造方法，默认调用无参的构造方法</p></li><li><p>如果子类构造方法中既没有显示标注，而父类有没有无参的构造方法，则编译出错</p></li><li><p>使用 super 调用父类指定构造方法，必须在子类的构造方法的第一行</p></li></ul><hr><h1 id="this-关键字-amp-super-关键字"><a href="#this-关键字-amp-super-关键字" class="headerlink" title="this 关键字 &amp; super 关键字"></a>this 关键字 &amp; super 关键字</h1><table><thead><tr><th>this 关键字——当前类对象的引用</th><th>super 关键字——父类对象的引用</th></tr></thead><tbody><tr><td>访问当前类的成员方法<br>访问当前类的成员属性<br>访问当前类的构造方法<br>不能再静态方法中使用</td><td>访问父类的成员方法<br>访问父类的成员属性<br>访问父类的构造方法<br>不能再静态方法中使用</td></tr></tbody></table><p>构造方法调用时，super 和 this 不能同时出现</p><hr><h1 id="重写-amp-重载"><a href="#重写-amp-重载" class="headerlink" title="重写 &amp; 重载"></a>重写 &amp; 重载</h1><table><thead><tr><th>方法重写</th><th>方法重载</th></tr></thead><tbody><tr><td>在满足继承关系的子类中<br>方法名、参数个数、顺序、返回值与父类相同<br>返回值类型与父类的返回值类型向下兼容<br>访问修饰符的限定范围大于等于父类方法</td><td>在同一个类中<br>方法名相同<br>参数个数、顺序、类型不同<br>返回值类型、访问修饰符任意</td></tr></tbody></table><p><strong>方法重写存在，属性重写不存在</strong></p><hr><h1 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h1><ul><li><p>Object 类是所有类的父类</p></li><li><p>一个类没有使用 extends 关键字明确标识继承关系，则默认继承 Object 类（包括数组）</p></li><li><p>Java 中的每个类都可以使用 Object 中定义的方法</p><p>Object  类的常用方法</p></li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>toString()</td><td>返回当前对象本身的有关信息，按字符串对象返回</td></tr><tr><td>equals()</td><td>比较两个对象是否是同一个对象，是则返回true</td></tr><tr><td>hashCode()</td><td>返回该对象的哈希代码值</td></tr><tr><td>getClass()</td><td>获取当前对象所属的类信息，返回Class对象</td></tr></tbody></table><hr><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><p>final 表示“最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</p><ul><li>被 final 修饰的类表示不允许被继承</li><li>被 final 修饰的方法表示不允许被子类重写<ul><li>final 修饰的方法可以被继承</li><li>不能修饰构造方法</li></ul></li><li>被 final 修饰的变量表示不允许被修改<ul><li>方法内部的局部变量 —&gt; 在使用之前被初始化赋值即可</li><li>类中的成员变量 —&gt; 只能在定义时或者构造代码块、构造方法中进行初始化设置</li><li>基本数据类型的变量 —&gt; 初始赋值之后不能更改</li><li>引用类型的变量—&gt;初始化之后不能再指向另一个对象，但指向的对象的内容时可变的</li><li>不能修饰构造方法</li></ul></li><li>可配合 static 使用，表示静态的、不允许被修改的信息</li><li>使用 final 修饰可以提高性能，但会降低可扩展性</li></ul><hr><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>可以声明在包、类、属性、方法、局部变量、方法参数等的前面，用来对这些元素进行说明、注释</p><h2 id="按照运行机制分"><a href="#按照运行机制分" class="headerlink" title="按照运行机制分"></a>按照运行机制分</h2><ul><li>源码注解</li><li>编译时注解</li><li>运行时注解</li></ul><h2 id="按照来源分"><a href="#按照来源分" class="headerlink" title="按照来源分"></a>按照来源分</h2><ul><li><p>来自 JDK 的注解</p></li><li><p>来自第三方的注解</p></li><li><p>自定义注解</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。&lt;/p&gt;
&lt;p&gt;继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="继承" scheme="https://cuizhe1023.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="super关键字" scheme="https://cuizhe1023.github.io/tags/super%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
      <category term="this关键字" scheme="https://cuizhe1023.github.io/tags/this%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
      <category term="final关键字" scheme="https://cuizhe1023.github.io/tags/final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
      <category term="重写&amp;重载" scheme="https://cuizhe1023.github.io/tags/%E9%87%8D%E5%86%99-%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>数据结构概述</title>
    <link href="https://cuizhe1023.github.io/2018/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
    <id>https://cuizhe1023.github.io/2018/10/14/数据结构概述/</id>
    <published>2018-10-14T03:08:40.000Z</published>
    <updated>2018-10-21T02:30:04.990Z</updated>
    
    <content type="html"><![CDATA[<p>算法 + 数据结构 = 编程</p><p>什么是数据结构？</p><p>通俗的来说，数据结构是计算机存储、组织数据的方式。</p><p>常用的数据机构有：</p><ul><li>数组</li><li>栈</li><li>队列</li><li>链表</li><li>树</li><li>图</li><li>字典树（这是一种高效的树形结构，但值得单独说明）</li><li>散列表（哈希表）</li></ul><a id="more"></a><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是最简单、也是使用最广泛的数据结构。栈、队列等其他数据结构均是由数组演变过来的。</p><p>下图是一个包含元素（1、2、3、4）的简单数组，数组长度为4。</p><p><img src="/2018/10/14/数据结构概述/数组.jpg" alt="数组"></p><p>每个数据元素都关联一个正数值，我们称之为索引，它表明数组中每个元素所在的位置。大部分语言将初始索引定义为零。</p><h2 id="数组的两种类型："><a href="#数组的两种类型：" class="headerlink" title="数组的两种类型："></a>数组的两种类型：</h2><ul><li>一维数组</li><li>多维数组</li></ul><h2 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h2><ul><li>Insert——在指定索引位置插入一个元素</li><li>Get——返回指定索引位置的元素</li><li>Delete——删除指定索引位置的元素</li><li>Size——得到数组所有元素的数量</li></ul><h2 id="面试中关于数组的常见问题"><a href="#面试中关于数组的常见问题" class="headerlink" title="面试中关于数组的常见问题"></a>面试中关于数组的常见问题</h2><ul><li>寻找数组中第二小的元素</li><li>找到数组中第一个不重复出现的整数</li><li>合并两个有序数组</li><li>重新排列数组中的正值和负值</li></ul><hr><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>著名的撤销操作几乎遍布任意一个应用。但是你有没有想过他是如何实现的？这个问题的解决思路是按照将最后的状态排列在前的顺序，在内存中存储历史工作状态。这没办法用数组实现，但是有了栈，这就变得很方便了。</p><p>可以把栈想象成一摞书，为了拿到中间的书，你需要移除放置在这上面的所有书。这就是LIFO（后进先出）的工作原理。</p><p>下图是包含三个数据元素（1、2、3）的栈，其中顶部的3将被最先移除：</p><p><img src="/2018/10/14/数据结构概述/栈.jpg" alt="栈"></p><h2 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h2><ul><li>Push——在顶部插入一个元素</li><li>Pop——返回并移除栈顶元素</li><li>isEmpty——如果栈为空，则返回true</li><li>Top——返回顶部元素，但并不移除它</li></ul><h2 id="面试中关于栈的常见问题"><a href="#面试中关于栈的常见问题" class="headerlink" title="面试中关于栈的常见问题"></a>面试中关于栈的常见问题</h2><ul><li>使用栈计算后缀表达式</li><li>对栈的元素进行排序</li><li>判断表达式是否括号平衡</li></ul><hr><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>与栈类似，队列是另一种顺序存储元素的线性数据结构。栈与队列的最大差别在于栈是LIFO（后进先出），而队列是FIFO（先进先出）</p><p>常见的队列：排队上车，如果有新人加入，他需要到队尾排队，而非队首。排在前面的人会先上车，然后离开队伍。</p><p>下图是包含四个元素（1，2，3，4）的队列，其中在顶部的1将被最先移除：</p><p><img src="/2018/10/14/数据结构概述/队列.jpg" alt="队列"></p><p>移除先入队的元素、插入新元素</p><h2 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h2><ul><li>Enqueue() —— 在队列尾部插入元素</li><li>Dequeue() ——移除队列头部的元素</li><li>isEmpty()——如果队列为空，则返回true</li><li>Top() ——返回队列的第一个元素</li></ul><h2 id="面试中关于队列的常见问题"><a href="#面试中关于队列的常见问题" class="headerlink" title="面试中关于队列的常见问题"></a>面试中关于队列的常见问题</h2><ul><li>使用队列表示栈</li><li>对队列的前k个元素倒序</li><li>使用队列生成从1到n的二进制数</li></ul><hr><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表是另一个重要的数据结构，乍一看可能有点像数组，但在内存分配，内部结构以及数据插入和删除的基本操作方面均有所不同。</p><p>链表就像一个节点链，其中每个节点包含着数据和指向后续节点的指针。链表还包含一个头指针，它指向链表的第一个元素，但当列表为空时，它指向null或无具体内容。</p><p>链表一般用于实现文件系统、哈希表和邻接表。</p><p>这是链表内部结构的展示：</p><p><img src="/2018/10/14/数据结构概述/链表.jpg" alt="链表"></p><h2 id="链表包括以下类型："><a href="#链表包括以下类型：" class="headerlink" title="链表包括以下类型："></a>链表包括以下类型：</h2><ul><li>单链表</li><li>双向链表</li></ul><h2 id="链表的基本操作："><a href="#链表的基本操作：" class="headerlink" title="链表的基本操作："></a>链表的基本操作：</h2><ul><li>InsertAtEnd - 在链表的末尾插入指定元素</li><li>InsertAtHead - 在链接列表的开头/头部插入指定元素</li><li>Delete  - 从链接列表中删除指定元素</li><li>DeleteAtHead - 删除链接列表的第一个元素</li><li>Search  - 从链表中返回指定元素</li><li>isEmpty - 如果链表为空，则返回true</li></ul><h2 id="面试中关于链表的常见问题"><a href="#面试中关于链表的常见问题" class="headerlink" title="面试中关于链表的常见问题"></a>面试中关于链表的常见问题</h2><ul><li>反转链表</li><li>检测链表中的循环</li><li>返回链表倒数第N个节点</li><li>删除链表中的重复项</li></ul><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>图是一组以网络形式相互连接的节点，节点也称为顶点。一对节点（x，y）称为边（edge），表示顶点x连接到顶点y。边可以包含权重/成本，显示从顶点x到y所需的成本。</p><p><img src="/2018/10/14/数据结构概述/图.jpg" alt="图"></p><h2 id="图的类型"><a href="#图的类型" class="headerlink" title="图的类型"></a>图的类型</h2><ul><li>无向图</li><li>有向图</li></ul><p>在程序语言中，图可以用两种形式表示</p><ul><li>邻接矩阵</li><li>邻接表</li></ul><h2 id="常见的图遍历算法"><a href="#常见的图遍历算法" class="headerlink" title="常见的图遍历算法"></a>常见的图遍历算法</h2><ul><li>广度优先搜索</li><li>深度优先搜索</li></ul><h2 id="面试中关于图的常见问题"><a href="#面试中关于图的常见问题" class="headerlink" title="面试中关于图的常见问题"></a>面试中关于图的常见问题</h2><ul><li>实现广度和深度优先搜索</li><li>检查图是否为树</li><li>计算图的边数</li><li>找到两个顶点之间的最短路径</li></ul><hr><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树形结构是一种层级式的数据结构，由顶点（节点）和连接他们的边组成。数类似于图，但区分树和图的重要特征是树种不存在环路。</p><p>这是一个简单树的示意图，以及树数据结构中使用的基本术语：</p><p><img src="/2018/10/14/数据结构概述/树.jpg" alt="树"></p><p>Root - 根节点</p><p>Parent - 父节点</p><p>Child - 子节点</p><p>Leaf - 叶子节点</p><p>Sibling - 兄弟节点</p><h2 id="树形结构的主要类型"><a href="#树形结构的主要类型" class="headerlink" title="树形结构的主要类型"></a>树形结构的主要类型</h2><ul><li>N元树</li><li>平衡树</li><li>二叉树</li><li>二叉搜索树</li><li>AVL树</li><li>红黑树</li><li>2-3树</li><li>B 树</li><li>B+ 树</li></ul><p>其中，二叉树和二叉搜索树是最常用的树。</p><h2 id="面试中关于树结构的常见问题"><a href="#面试中关于树结构的常见问题" class="headerlink" title="面试中关于树结构的常见问题"></a>面试中关于树结构的常见问题</h2><ul><li>求二叉树的高度</li><li>在二叉搜索树中查找第k个最大值</li><li>查找与根节点距离k的节点</li><li>在二叉树中查找给定节点的祖先节点</li></ul><h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><p>字典树，也称为“前缀树”，是一种特殊的树形数据结构，对于解决字符串相关问题非常有效。他能够提供快速减速，主要用于搜索字典中的单词，在搜索引擎中自动提供建议，甚至被用于 IP 的路由。</p><p>以下是在字典树中存储三个单词“top”，“thus”和“their”的例子：</p><p><img src="/2018/10/14/数据结构概述/字典树.jpg" alt="字典树"></p><p>这些单词以顶部到底部的方式存储，其中绿色节点“p”，“s”和“r”分别表示“top”，“thus”和“their”的底部。</p><h2 id="面试中关于字典树的常见问题"><a href="#面试中关于字典树的常见问题" class="headerlink" title="面试中关于字典树的常见问题"></a>面试中关于字典树的常见问题</h2><ul><li>计算字典树中的总单词数</li><li>打印存储在字典树中的所有单词</li><li>使用字典树对数组的元素进行排序</li><li>使用字典树从字典中形成单词</li><li>构建T9字典（字典树+ DFS ）</li></ul><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希法（Hashing）是一个用于唯一标识对象并将每个对象存储在一些预先计算的唯一索引（称为“键key”）中的过程。因此，对象以键值对的形式存储，这些键值对集合被称为“字典”。可以使用键搜索每个对象。基于哈希法有很多不同的数据结构，但最常用的数据结构是哈希表。</p><p>哈希表通常用数组实现。</p><p>散列数据结构的性能取决于以下三个因素：</p><ul><li>哈希函数</li><li>哈希表的大小</li><li>碰撞处理方法</li></ul><p>下图为如何在数组中映射哈希键值对的说明。该数组的索引是通过哈希函数计算的。</p><p><img src="/2018/10/14/数据结构概述/哈希表.jpg" alt="哈希表"></p><h2 id="面试中关于哈希结构的常见问题："><a href="#面试中关于哈希结构的常见问题：" class="headerlink" title="面试中关于哈希结构的常见问题："></a>面试中关于哈希结构的常见问题：</h2><ul><li>在数组中查找对称键值对</li><li>追踪遍历的完整路径</li><li>查找数组是否是另一个数组的子集</li><li>检查给定的数组是否不相交</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法 + 数据结构 = 编程&lt;/p&gt;
&lt;p&gt;什么是数据结构？&lt;/p&gt;
&lt;p&gt;通俗的来说，数据结构是计算机存储、组织数据的方式。&lt;/p&gt;
&lt;p&gt;常用的数据机构有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组&lt;/li&gt;
&lt;li&gt;栈&lt;/li&gt;
&lt;li&gt;队列&lt;/li&gt;
&lt;li&gt;链表&lt;/li&gt;
&lt;li&gt;树&lt;/li&gt;
&lt;li&gt;图&lt;/li&gt;
&lt;li&gt;字典树（这是一种高效的树形结构，但值得单独说明）&lt;/li&gt;
&lt;li&gt;散列表（哈希表）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://cuizhe1023.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://cuizhe1023.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java基础五--封装</title>
    <link href="https://cuizhe1023.github.io/2018/10/14/Java%E5%9F%BA%E7%A1%80%E4%BA%94/"/>
    <id>https://cuizhe1023.github.io/2018/10/14/Java基础五/</id>
    <published>2018-10-14T00:35:35.658Z</published>
    <updated>2018-10-21T02:20:24.840Z</updated>
    
    <content type="html"><![CDATA[<p>什么是封装？</p><ul><li>通过该类提供的方法来实现对隐藏信息的操作和访问</li><li>隐藏对象的信息</li><li>留出访问的接口</li></ul><a id="more"></a><h1 id="封装的优点"><a href="#封装的优点" class="headerlink" title="封装的优点"></a>封装的优点</h1><ul><li>良好的封装能减少耦合</li><li>类内部的结构可以自由修改</li><li>可以对成员变量进行更精确的控制</li><li>隐藏信息，实现细节</li></ul><hr><h1 id="实现Java封装的步骤"><a href="#实现Java封装的步骤" class="headerlink" title="实现Java封装的步骤"></a>实现Java封装的步骤</h1><ul><li><p>隐藏对象</p><p><strong>修改属性的可见性——设置为 private</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，将 name 和 age 属性设置为私有的，只有本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。</p></li><li><p>留出接口</p><p><strong>创建 getter / setter 方法——设置为 public 用于属性的读写</strong></p><p><strong>在 getter / setter 方法中加入属性控制语句——对属性值的合法性进行判断</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name）之间发生的同名的冲突。</p></li></ul><hr><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>管理 Java 文件</li><li>解决同名文件冲突</li></ul><h2 id="定义包"><a href="#定义包" class="headerlink" title="定义包"></a>定义包</h2><p><strong>语法：</strong>package 包名;</p><p><strong>注意：</strong></p><p>1.必须放在 Java 源文件中的第一行</p><p>2.一个 Java 源文件中只能有一个 package 语句</p><p>3.包名全部英文小写</p><p>4.命名方式：域名倒序 + 模块 + 功能</p><p>eg：package com.nuc.zigbee;</p><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><p><strong>语法：</strong></p><p>import 包名.类名;</p><p>eg:</p><p>import com.nuc.*;</p><p>import com.nuc.zigbee;</p><h2 id="常用系统包"><a href="#常用系统包" class="headerlink" title="常用系统包"></a>常用系统包</h2><p>java.lang 包含 Java 语言基础的类</p><p>java.util 包含 Java 语言中的各种工具类</p><p>java.io 包含输入、输出相关功能的类</p><hr><h1 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h1><p>static 翻译为静态，从面向对象的角度讲，当一个类中的变量或方法用 static 修饰时，这些变量和方法就成了类本身的，他们和对象的关系并不大。但是从直观的角度讲，这些被修饰的量确实被该类所有对象所拥有，并且被这个类的所有对象所共享，求其是当使用该类对象进行引用他们时。其实当使用对象进行引用 static 修饰成员时，在底层代码的实现中，其实还是转换为类名进行引用，这表明这个成员属于类。</p><ul><li>static + 属性——静态属性、类属性</li><li>static + 方法——静态方法、类方法</li><li>static + 类——不存在，不能加载类前</li><li>static + 方法内局部变量——不能加载局部变量前</li><li>static + 代码块——静态代码块</li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ul><li>通过{}可以形成代码块</li><li>方法内的代码块称为：普通代码块</li><li>类内的代码块称为：构造代码块</li><li>构造代码块前 + static：静态代码块</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>初学这个关键字时，书上有个重点，那就是一个类中， static 修饰的成员不能访问势力成员，只能访问静态成员。这个很好理解，static 修饰的成员叫做类成员，属于类本身的属性，随着类的编译进行初始化，而此时实例成员未必进行初始化，这就会带来很多错误，所以类成员访问实例成员是不能通过编译的。</li><li>静态方法中不可以定义 this，super 关键字，因为静态元素优先于对象存在。</li></ul><h3 id="静态成员的声明周期"><a href="#静态成员的声明周期" class="headerlink" title="静态成员的声明周期"></a>静态成员的声明周期</h3><p>静态成员随着类的加载而产生，销毁时释放，生命周期伴随着类的整个的生命周期，生命周期长，这就意味着对内存资源的占用也会相对比较长。</p><h3 id="静态方法中的成员调用"><a href="#静态方法中的成员调用" class="headerlink" title="静态方法中的成员调用"></a>静态方法中的成员调用</h3><ul><li>可以直接调用同类中的静态成员。</li><li>不可以直接调用同类中的非静态成员。</li><li>只能通过对象实例化后，对象.成员方法 的方式访问非静态成员。</li></ul><h3 id="各种代码块的执行顺序"><a href="#各种代码块的执行顺序" class="headerlink" title="各种代码块的执行顺序"></a>各种代码块的执行顺序</h3><p>无论实例产生多少对象，静态代码块只执行一次。</p><p>构造代码块在每次对象构造的时候调用。</p><p>方法中的普通代码块则是在每次调用方法的时候顺序调用。</p><h3 id="什么时候定义静态变量"><a href="#什么时候定义静态变量" class="headerlink" title="什么时候定义静态变量"></a>什么时候定义静态变量</h3><p>当对象中出现共享数据时，该数据被修饰成静态，对象中的特有数据，修饰为非静态，存在于堆内存中。</p><h3 id="什么时候定义静态方法"><a href="#什么时候定义静态方法" class="headerlink" title="什么时候定义静态方法"></a>什么时候定义静态方法</h3><p>当功能内部没有访问到非静态数据（对象中特有的数据），该函数可以定义为静态的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是封装？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过该类提供的方法来实现对隐藏信息的操作和访问&lt;/li&gt;
&lt;li&gt;隐藏对象的信息&lt;/li&gt;
&lt;li&gt;留出访问的接口&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="封装" scheme="https://cuizhe1023.github.io/tags/%E5%B0%81%E8%A3%85/"/>
    
      <category term="static" scheme="https://cuizhe1023.github.io/tags/static/"/>
    
  </entry>
  
  <entry>
    <title>Java基础四--面向对象基础</title>
    <link href="https://cuizhe1023.github.io/2018/10/13/Java%E5%9F%BA%E7%A1%80%E5%9B%9B/"/>
    <id>https://cuizhe1023.github.io/2018/10/13/Java基础四/</id>
    <published>2018-10-13T10:20:01.898Z</published>
    <updated>2018-10-14T00:25:01.681Z</updated>
    
    <content type="html"><![CDATA[<p>如果你现实中没有对象，至少你在java世界里会有茫茫多的对象，听起来是不是很激动呢？<br><a id="more"></a></p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>对象是类的一个实例，有状态和行为。</p><p>我们所在的世界，周围的一切事物都是对象，车、人、狗等等。这些对象都有自己的状态和行为。</p><p>我们用一只猫来举例，它的状态有：名字、品种、颜色，行为由：跑，叫，睡觉。</p><p>软件的对象也有状态和行为。软件对象的状态称为<strong>属性</strong>，行为通过<strong>方法</strong>体现。</p><h2 id="那么什么是面向对象？"><a href="#那么什么是面向对象？" class="headerlink" title="那么什么是面向对象？"></a>那么什么是面向对象？</h2><p>关注现实存在的事物的各方面的信息，从对象的角度出发，根据事物的特征进行程序设计</p><hr><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类是一个模子，确定对象将会拥有的特性（属性）和行为（方法）</p><p>类的特点：</p><ul><li>类是对象的类型</li><li>具有相同属性和方法的一组对象的集合</li></ul><p>对象是类的实例表现</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>对象具有的静态特征。对象“有什么”。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>对象具有的各种动态行为。对象“能做什么”。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>一个类中可以包含以下类型变量：</p><ul><li><p>局部变量</p><p>在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都在方法中，方法结束后，变量就会自动销毁</p></li><li><p>成员变量</p><p>成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问</p></li><li><p>类变量</p><p>类变量也声明在类中，方法体之外，但必须声明为static类型</p></li></ul><hr><h1 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h1><p>类是抽象的概念，仅仅是模板</p><p>对象是一个你能看得见，摸得着的具体实体</p><p>类是对象的类型</p><p>对象是特定类型的数据</p><hr><h1 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h1><p>实例化对象的过程可以分为两部分:</p><p>- 声明对象 Cat one</p><p>- 实例化对象 new Cat()</p><p>- Cat one = new Cat();//类名 对象名 = new  构造方法();</p><p>声明对象，就是在内存的<strong>栈区域</strong>开辟一块空间，此时这个空间里的值是空的</p><p>实例化对象，在内存的<strong>堆区域</strong>开辟一块空间，完成初始化操作</p><p><img src="/2018/10/13/Java基础四/对象实例化1.png" alt="对象实例化1"></p><p>经过赋值操作，我们将堆空间中的地址，传递到了栈当中的内存空间里。此后，我们就可以通过对象名去调用对象的属性和方法了。</p><p><img src="/2018/10/13/Java基础四/对象实例化2.png" alt="对象实例化2"></p><p>每次 new 对象就会产生新的实例化方法</p><p>- Cat one  = new Cat();</p><p>- Cat two = new Cat();</p><p><img src="/2018/10/13/Java基础四/对象实例化3.png" alt="对象实例化3"></p><p>多个对象也可以指向同一块实例化空间</p><p>- Cat one = new Cat();</p><p>- Cat two = one;</p><p><img src="/2018/10/13/Java基础四/对象实例化4.png" alt="对象实例化4"></p><h2 id="对象实例化-1"><a href="#对象实例化-1" class="headerlink" title="对象实例化"></a>对象实例化</h2><p>对象必须被实例化之后才能使用</p><p>对象间的引用传递，实际上传递的是堆内存空间的使用权</p><hr><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><ul><li>构造方法与类同名且没有返回值</li><li>只能在对象实例化的时候调用</li><li>一个类可以有多个构造方法—构造方法重载</li><li>当没有指定构造方法时，系统会自动调用无参的构造方法</li><li>当有指定构造方法，无论是有参、无参的构造方法，都不会自动调用无参的构造方法。</li><li>构造方法不可被重写</li></ul><hr><h1 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h1><p>this: 当前对象的默认引用</p><p>this 的使用</p><p>- 调用成员属性，解决成员属性和局部变量同名冲突</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  System.out.println(<span class="string">"我是单参构造"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>- 调用成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.eat();</span><br><span class="line">    System.out.println(<span class="string">"小猫快跑"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>- 调用重载的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"我是无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>();<span class="comment">//通过this()调用构造方法，必须放在方法体内的第一行。</span></span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">    System.out.println(<span class="string">"我是单参构造"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h1><p>当在一个源文件中定义多个类，并且还有 import 语句和 package 语句时，要特别注意这些规则</p><ul><li>一个源文件中只能有一个 public 类</li><li>一个源文件可以有多个非public类</li><li>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是  Employee，那么源文件应该命名为 Employee.java</li><li>如果一个类定义在某个包中，那么 package 语句应该在源文件的首行</li><li>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么import 语句应该在源文件中最前面</li><li>import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你现实中没有对象，至少你在java世界里会有茫茫多的对象，听起来是不是很激动呢？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面向对象" scheme="https://cuizhe1023.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java基础三--运算符</title>
    <link href="https://cuizhe1023.github.io/2018/10/13/Java%E5%9F%BA%E7%A1%80%E4%B8%89/"/>
    <id>https://cuizhe1023.github.io/2018/10/13/Java基础三/</id>
    <published>2018-10-13T10:15:29.982Z</published>
    <updated>2018-10-21T02:31:15.216Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 中运算符有一下几组</p><ul><li>算数运算符</li><li>关系运算符</li><li>位运算符</li><li>逻辑运算符</li><li>赋值运算符</li><li>其他运算符</li></ul><a id="more"></a><h1 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h1><p>算数运算符用在数学表达式中，作用和在数学中的作用一样。</p><p>在表格中 A = 10, B = 20</p><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">描述</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">+</td><td style="text-align:left">加法</td><td style="text-align:left">A + B = 30</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">减法</td><td style="text-align:left">A - B = -10</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">乘法</td><td style="text-align:left">A * B = 200</td></tr><tr><td style="text-align:left">/</td><td style="text-align:left">除法</td><td style="text-align:left">B / A = 2</td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">取余</td><td style="text-align:left">B % A = 0</td></tr><tr><td style="text-align:left">++</td><td style="text-align:left">自增</td><td style="text-align:left">A++ 或 ++A 等于11</td></tr><tr><td style="text-align:left">–</td><td style="text-align:left">自减</td><td style="text-align:left">B– 或者 –B 等于19</td></tr></tbody></table><h2 id="i-和-i-的区别"><a href="#i-和-i-的区别" class="headerlink" title="i++ 和 ++i 的区别"></a>i++ 和 ++i 的区别</h2><ul><li>++i 先进行自增操作，在进行表达式运算</li><li>i++ 先进行表达式运算，在进行自增操作</li></ul><p>简单的来说，i++ 与 ++i 在单独使用的时候，都代表了 i = i + 1;</p><p>表达式 a = ++i; 等价于 i = i + 1;a = i;</p><p>表达式 a = i++; 等价于 a = i;i = i + 1;</p><hr><h1 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h1><p>A = 10, B = 20</p><table><thead><tr><th style="text-align:left">运算符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td style="text-align:left">==</td><td>检查两个操作数的值是否相等，如果相等则返回true</td><td>(A = B) false</td></tr><tr><td style="text-align:left">!=</td><td>检查两个操作数的值是否相等，如果不相等则返回true</td><td>(A != B) true</td></tr><tr><td style="text-align:left">&gt;</td><td>检查左操作数的值是否大于右操作数的值，如果是，返回true</td><td>(A &gt; B) false</td></tr><tr><td style="text-align:left">&lt;</td><td>检查左操作数的值是否小于右操作数的值，如果是，返回true</td><td>(A &lt; B) true</td></tr><tr><td style="text-align:left">&gt;=</td><td>检查左操作数的值是否大于或者等于右操作数的值，如果是，返回true</td><td>(A &gt;= B) false</td></tr><tr><td style="text-align:left">&lt;=</td><td>检查左操作数的值是否小于或者等于右操作数的值，如果是，返回true</td><td>(A &lt;= B) true</td></tr></tbody></table><hr><h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>位运算应用于整数类型（int），长整型（long），短整型（short），字符型（char）和字节型（byte）等类型。</p><p>位运算符作用在所有的位上，并且按位运算。假设 A = 60, B = 13,则二进制表示如下</p><blockquote><p>A = 0011 1100</p><p>B = 0000 1101</p></blockquote><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与运算符，如果相对应位都是1，则结果为1，否则为0</td><td>(A &amp; B) = 0000 1100 即12</td></tr><tr><td>丨</td><td>按位或运算符，如果相对应位都是0，则结果为0，否则为1</td><td>(A 丨 B) = 0011 1101 即61</td></tr><tr><td>^</td><td>按位异或运算符，如果相对应位值相同，则结果为0，否则为1</td><td>(A ^ B) = 0011 0001 即49</td></tr><tr><td>~</td><td>取反运算符，按位取反运算符翻转操作数的每一位，即0变成1，1变成0</td><td>(~ A) = 1100 0011 即-61</td></tr><tr><td>&lt;&lt;</td><td>按位左移运算符。左操作数按位左移右操作数指定的位数</td><td>(A &lt;&lt; 2) = 1111 0000 即240</td></tr><tr><td>&gt;&gt;</td><td>按位右移运算符。左操作数按位右移右操作数指定的位数</td><td>(A &gt;&gt; 2) = 1111 即15</td></tr><tr><td>&gt;&gt;&gt;</td><td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充</td><td>(A &gt;&gt;&gt; 2) = 00001111 即15</td></tr></tbody></table><hr><h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><p>假设 A = true, B = false</p><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td><td>(A &amp;&amp; B) = false</td></tr><tr><td>丨丨</td><td>逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td><td>(A 丨丨 B) = true</td></tr><tr><td>！</td><td>逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td><td>! (A &amp;&amp; B)=  true</td></tr></tbody></table><h2 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h2><p>当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。</p><ul><li>短路逻辑与</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b = (a &lt; <span class="number">4</span>) &amp;&amp; (a++&lt;<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"使用短路逻辑运算符的结果为"</span>+b);</span><br><span class="line">        System.out.println(<span class="string">"a的结果为"</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用短路逻辑运算符的结果为false<br>a的结果为5</p></blockquote><p><strong>解析</strong>：该程序使用到了短路逻辑运算符(&amp;&amp;)，首先判断 a&lt;4 的结果为 false，则 b 的结果必定是 false，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。</p><ul><li>短路逻辑或</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b = (a &gt; <span class="number">4</span>) || (a++&lt;<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"使用短路逻辑运算符的结果为"</span>+b);</span><br><span class="line">        System.out.println(<span class="string">"a的结果为"</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用短路逻辑运算符的结果为true<br>a的结果为5</p></blockquote><p><strong>解析</strong>：该程序使用到了短路逻辑运算符(||)，首先判断 a &gt; 4 的结果为 true，则 b 的结果必定是 true，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。</p><hr><h1 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h1><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符，将右操作数的值赋给左侧操作数</td><td>C = A + B将把A + B得到的值赋给C</td></tr><tr><td>+=</td><td>加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td><td>C += A等价于C = C + A</td></tr><tr><td>-=</td><td>减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td><td>C -= A等价于C = C -  A</td></tr><tr><td>*=</td><td>乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td><td>C <em>= A等价于C = C </em> A</td></tr><tr><td>/=</td><td>除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td><td>C / = A等价于C = C / A</td></tr><tr><td>(％)=</td><td>取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td><td>C％= A等价于C = C％A</td></tr><tr><td>&lt;&lt; =</td><td>左移位赋值运算符</td><td>C &lt;&lt; = 2等价于C = C &lt;&lt; 2</td></tr><tr><td>&gt;&gt; =</td><td>右移位赋值运算符</td><td>C &gt;&gt; = 2等价于C = C &gt;&gt; 2</td></tr><tr><td>&amp;=</td><td>按位与赋值运算符</td><td>C＆= 2等价于C = C＆2</td></tr><tr><td>^ =</td><td>按位异或赋值操作符</td><td>C ^ = 2等价于C = C ^ 2</td></tr><tr><td>丨=</td><td>按位或赋值操作符</td><td>C 丨 = 2等价于C = C 丨 2</td></tr></tbody></table><hr><h1 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h1><h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p><p>对于条件表达式b ? x : y，先计算条件b，然后进行判断。如果b的值为true，计算x的值，运算结果为x的值；否则，计算y的值，运算结果为y的值。一个条件表达式绝不会既计算x，又计算y。条件运算符是右结合的，也就是说，从右向左分组计算。例如，a ? b : c ? d : e将按a ? b : (c ? d : e)执行。</p><h2 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h2><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p><p>用法：<br>result = object instanceof class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">"James"</span>;</span><br><span class="line"><span class="keyword">boolean</span> result = name <span class="keyword">instanceof</span> String; <span class="comment">// 由于 name 是 String 类型，所以返回 true</span></span><br></pre></td></tr></table></figure><hr><h1 id="Java-运算符优先级"><a href="#Java-运算符优先级" class="headerlink" title="Java 运算符优先级"></a>Java 运算符优先级</h1><table><thead><tr><th>类别</th><th>操作符</th><th>关联性</th></tr></thead><tbody><tr><td>后缀</td><td>() [] . (点操作符)</td><td>左到右</td></tr><tr><td>一元</td><td>+ - ! ~</td><td>从右到左</td></tr><tr><td>乘性</td><td>* / ％</td><td>左到右</td></tr><tr><td>加性</td><td>+ -</td><td>左到右</td></tr><tr><td>移位</td><td>&gt;&gt; &gt;&gt;&gt;  &lt;&lt;</td><td>左到右</td></tr><tr><td>关系</td><td>&gt; &gt;= &lt; &lt;=</td><td>左到右</td></tr><tr><td>相等</td><td>==  !=</td><td>左到右</td></tr><tr><td>按位与</td><td>＆</td><td>左到右</td></tr><tr><td>按位异或</td><td>^</td><td>左到右</td></tr><tr><td>按位或</td><td>丨</td><td>左到右</td></tr><tr><td>逻辑与</td><td>&amp;&amp;</td><td>左到右</td></tr><tr><td>逻辑或</td><td>丨丨</td><td>左到右</td></tr><tr><td>条件</td><td>？：</td><td>从右到左</td></tr><tr><td>赋值</td><td>= += -= *= /= ％= &gt;&gt;= &lt;&lt;= &amp;= ^= 丨=</td><td>从右到左</td></tr><tr><td>逗号</td><td>，</td><td>左到右</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Java 中运算符有一下几组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算数运算符&lt;/li&gt;
&lt;li&gt;关系运算符&lt;/li&gt;
&lt;li&gt;位运算符&lt;/li&gt;
&lt;li&gt;逻辑运算符&lt;/li&gt;
&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;li&gt;其他运算符&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="运算符" scheme="https://cuizhe1023.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>Java基础二--修饰符</title>
    <link href="https://cuizhe1023.github.io/2018/10/13/Java%E5%9F%BA%E7%A1%80%E4%BA%8C/"/>
    <id>https://cuizhe1023.github.io/2018/10/13/Java基础二/</id>
    <published>2018-10-13T10:15:18.088Z</published>
    <updated>2018-10-21T02:30:54.542Z</updated>
    
    <content type="html"><![CDATA[<p>Java 中主要有两类修饰符：</p><ul><li>访问修饰符</li><li>非访问修饰符</li></ul><a id="more"></a><h1 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h1><table><thead><tr><th style="text-align:center">访问修饰符</th><th style="text-align:center">当前类</th><th style="text-align:center">同一包内</th><th style="text-align:center">子类</th><th style="text-align:center">其他包</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><p>public : 公开,所有类可见</p><p>protected :继承访问权限（本包中的子类非子类均可访问，不同包中的子类可以访问，不是子类不能访问）</p><p>default :包访问权限（本包中的子类非子类均可访问，不同包中的类及子类均不能访问）</p><p>private :私有,在同一类内可见</p><p><strong>[注]</strong>：protected的可见性在于两点：</p><ul><li>父类的 protected 成员是包内可见的，并且对子类可见；</li><li>若子类与父类不在同一包中，那么在子类中，子类实例可以访问其从父类继承而来的protected方法，而不能访问父类实例的protected方法。</li></ul><h2 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h2><ul><li>父类中声明为 public 的方法在子类中也必须为 public。</li><li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li><li>父类中声明为 private 的方法，不能够被继承。</li></ul><hr><h1 id="Java-非访问修饰符"><a href="#Java-非访问修饰符" class="headerlink" title="Java 非访问修饰符"></a>Java 非访问修饰符</h1><p>Java 中的非访问修饰符有：</p><ul><li>static 修饰符，用来修饰类方法和类变量</li><li>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</li><li>abstract 修饰符，用来创建抽象类和抽象方法。</li><li>synchronized 和 volatile 修饰符，主要用于线程的编程。</li></ul><h2 id="Static-修饰符"><a href="#Static-修饰符" class="headerlink" title="Static 修饰符"></a>Static 修饰符</h2><p>所谓静态就是指在编译后所分配的内存会一直存在，直到程序退出内存才会释放这个空间，也就是只要程序在运行，那么这块内存就会一直存在。</p><ul><li><p><strong>静态变量：</strong></p><p>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</p></li><li><p><strong>静态方法：</strong></p><p>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p></li></ul><h2 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h2><p>final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</p><ul><li>final 修饰符通常和 static 修饰符一起使用来创建类常量。</li><li>类中的 final 方法可以被子类继承，但是不能被子类修改。声明 final 方法的主要目的是防止该方法的内容被修改。</li><li>final 类不能被继承，没有类能够继承 final 类的任何特性。</li></ul><h2 id="abstract-修饰符"><a href="#abstract-修饰符" class="headerlink" title="abstract 修饰符"></a>abstract 修饰符</h2><ul><li><p><strong>抽象类：</strong></p><p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</p><p>一个类不能同时被 abstract 和 final 修饰<strong>[被 final 修饰后就不能被继承了]</strong>。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p><p>抽象类可以包含抽象方法和非抽象方法。</p></li><li><p><strong>抽象方法：</strong></p><p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。</p><p>抽象方法不能被声明成 final 和 static。</p><p>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p><p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p><p>抽象方法的声明以分号结尾。</p></li></ul><h2 id="synchronized-修饰符"><a href="#synchronized-修饰符" class="headerlink" title="synchronized 修饰符"></a>synchronized 修饰符</h2><p>synchronized 关键字声明的方法同一时间只能被一个线程访问。</p><h2 id="transient-修饰符"><a href="#transient-修饰符" class="headerlink" title="transient 修饰符"></a>transient 修饰符</h2><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。</p><p>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</p><h2 id="volatile-修饰符"><a href="#volatile-修饰符" class="headerlink" title="volatile 修饰符"></a>volatile 修饰符</h2><p>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p><p>一个 volatile 对象引用可能是 null。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 中主要有两类修饰符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;访问修饰符&lt;/li&gt;
&lt;li&gt;非访问修饰符&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="修饰符" scheme="https://cuizhe1023.github.io/tags/%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>Java基础一--基本数据类型&amp;类型转换</title>
    <link href="https://cuizhe1023.github.io/2018/10/13/Java%E5%9F%BA%E7%A1%80%E4%B8%80/"/>
    <id>https://cuizhe1023.github.io/2018/10/13/Java基础一/</id>
    <published>2018-10-13T10:08:00.335Z</published>
    <updated>2018-10-28T03:17:14.079Z</updated>
    
    <content type="html"><![CDATA[<p>Java 中有两大数据类型：</p><ul><li>内置数据类型</li><li>引用数据类型</li></ul><a id="more"></a><p><img src="/2018/10/13/Java基础一/数据类型.jpg" alt="数据类型"></p><h1 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h1><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p><table><thead><tr><th style="text-align:center">基本类型</th><th style="text-align:center">大小</th><th style="text-align:center">最小值</th><th style="text-align:center">最大值</th><th style="text-align:center">默认值</th><th style="text-align:center">包装类</th><th style="text-align:center">例子</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">8 bit</td><td style="text-align:center">-128</td><td style="text-align:center">+127</td><td style="text-align:center">0</td><td style="text-align:center">Byte</td><td style="text-align:center">byte a = 100</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">16 bit</td><td style="text-align:center">-2^15</td><td style="text-align:center">+2^15 - 1</td><td style="text-align:center">0</td><td style="text-align:center">Short</td><td style="text-align:center">short s = 1000</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">32 bit</td><td style="text-align:center">-2^31</td><td style="text-align:center">+2^31 - 1</td><td style="text-align:center">0</td><td style="text-align:center">Integer</td><td style="text-align:center">int a = 100000</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">64 bit</td><td style="text-align:center">-2^63</td><td style="text-align:center">+2^63 -1</td><td style="text-align:center">0L</td><td style="text-align:center">Long</td><td style="text-align:center">long a = 100000L</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">32 bit</td><td style="text-align:center">IEEE754</td><td style="text-align:center">IEEE754</td><td style="text-align:center">0.0f</td><td style="text-align:center">Float</td><td style="text-align:center">float f1 = 234.5f</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">64 bit</td><td style="text-align:center">IEEE754</td><td style="text-align:center">IEEE754</td><td style="text-align:center">0.0d</td><td style="text-align:center">Double</td><td style="text-align:center">double d1 = 123.4</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">16 bit</td><td style="text-align:center">Unicode 0</td><td style="text-align:center">Unicode 2^16-1</td><td style="text-align:center">空</td><td style="text-align:center">Character</td><td style="text-align:center">char letter = ‘A’</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">false</td><td style="text-align:center">Boolean</td><td style="text-align:center">boolean one = true</td></tr></tbody></table><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>虽然 Java 语言是典型的面向对象编程语言，但其中的八种基本数据类型并不支持面向对象编程，基本类型的数据不具备“对象”的特性——不携带属性、没有方法可调用。 沿用它们只是为了迎合人类根深蒂固的习惯，并的确能简单、有效地进行常规数据处理。</p><h3 id="基本数据类型的不足"><a href="#基本数据类型的不足" class="headerlink" title="基本数据类型的不足"></a>基本数据类型的不足</h3><ul><li>不具有对象的特性</li><li>无法进行对象化交互</li><li>解决办法——包装类</li></ul><p>这种借助于非面向对象技术的做法有时也会带来不便，比如引用类型数据均继承了 Object 类的特性，要转换为 String 类型（经常有这种需要）时只要简单调用 Object 类中定义的 toString() 即可，而基本数据类型转换为 String 类型则要麻烦得多。为解决此类问题 ，Java 为每种基本数据类型分别设计了对应的类，称之为包装类(Wrapper Classes)。这样便可以把这些基本类型转换为对象来处理了。</p><p>每个包装类的对象可以封装一个相应的基本类型的数据，并提供了其它一些有用的方法。包装类对象一经创建，其内容（所封装的基本类型数据值）不可改变。</p><h3 id="包装类有哪些？"><a href="#包装类有哪些？" class="headerlink" title="包装类有哪些？"></a>包装类有哪些？</h3><p>Java 中常用的包装类可以分为三类：Character、Number、Boolean</p><h3 id="包装类与基本数据类型"><a href="#包装类与基本数据类型" class="headerlink" title="包装类与基本数据类型"></a>包装类与基本数据类型</h3><ul><li>装箱：把基本数据类型转换成包装类<ul><li>自动装箱</li><li>手动装箱</li></ul></li><li>拆箱：把包装类转换成基本数据类型<ul><li>自动拆箱</li><li>手动拆箱</li></ul></li></ul><h4 id="装箱-amp-拆箱"><a href="#装箱-amp-拆箱" class="headerlink" title="装箱&amp;拆箱"></a>装箱&amp;拆箱</h4><h5 id="什么是自动拆箱装箱？"><a href="#什么是自动拆箱装箱？" class="headerlink" title="什么是自动拆箱装箱？"></a>什么是自动拆箱装箱？</h5><p>很简单，下面两局代码就可以看到装箱和拆箱的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line">Integer total = <span class="number">99</span>;</span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> totalprim = total;</span><br></pre></td></tr></table></figure><p>简单的来说，自动装箱是 Java 编译器在 Java 基本数据类型和对应的对象包装类型上做的自动转换。例如把 int 转换成 Integer ，double 转换成 Double 等等</p><p>如果反过来，就是自动拆箱，这也是编译器为我们做的事。</p><p>通常我们要创建一个类的对象实例的时候，我们会这样：<code>Class c = new Class(parameter);</code></p><p>当我们创建一个 Integer 对象是，却可以这样：<code>Integer i = 100;</code></p><p>实际上，执行上面那句代码的时候，系统为我们执行了：<code>Integer i = Integer.valueOf(100);</code></p><p>此即基本数据类型的自动装箱功能。</p><p>当我们将 Integer 对象赋值给 int 类型时：</p><p><code>Integer i = 10;</code></p><p><code>int t = i;</code></p><p>实际上，执行上面那句代码的时候，系统为我们执行了：<code>int i = i.intValue();</code>&gt;</p><p><strong>接下来，我们来看这样的代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Integer i1 = <span class="number">32</span>;</span><br><span class="line">        Integer x1 = <span class="number">32</span>;</span><br><span class="line">        System.out.println(i1 == x1);</span><br><span class="line">        Integer i2 = <span class="number">132</span>;</span><br><span class="line">        Integer x2 = <span class="number">132</span>;</span><br><span class="line">        System.out.println(i2 == x2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>true<br>false</p></blockquote><p>解释如下：</p><p>初始值在 -128 – 127 之间的值，它们被装箱为Integer对象后，会在内存中被重用。超过这个值的时候每次装箱是会产生新的对象。</p><p><strong>为重载带来的问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Integer x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Integer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"long"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Long x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Long"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p><p>long</p></blockquote><p>在这种情况下编译器选择的是加宽操作，而不是装箱。</p><p>测试结果（优先级排序）：</p><p>int&gt;long &gt; float &gt; Integer &gt; Long(运行出错) &gt; char(编译报错)</p><p>这里说一下为什么转 Long 会出错。</p><p>因为 int 不能直接转为 Long 类型，int 是基本数据类型，而 Long 是包装类。int 转 Integer 可以通过装箱实现，而 Long 不是 int 的包装类，所以不行。</p><p>那么如果想将 int 转为 Long 呢？</p><p>可以通过一下步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">long</span> l = a;<span class="comment">//先将 int 转为 long 类型</span></span><br><span class="line">        Long l1 = l;<span class="comment">//再将 long 装箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串与基本数据类型"><a href="#字符串与基本数据类型" class="headerlink" title="字符串与基本数据类型"></a>字符串与基本数据类型</h3><ul><li>基本数据类型转换为字符串<ul><li>使用包装类的 toString() 方法</li></ul></li><li>字符串转换为基本数据类型<ul><li>自动拆箱调用包装类的 parseXXX() 静态方法</li><li>调用包装类的 valueOf() 方法转换为基本类型的包装类，自动拆箱</li></ul></li></ul><h3 id="基本类型与包装类型的异同"><a href="#基本类型与包装类型的异同" class="headerlink" title="基本类型与包装类型的异同"></a>基本类型与包装类型的异同</h3><ul><li>在 Java 中，一切皆对象，但是八大基本类型却不是对象</li><li>声明方式的不同，基本类型无须通过 new 关键字来创建，而包装类型需要 new 关键字</li><li>存储方式及位置的不同，基本数据类型是将变量的值保存在栈中，这样可以更高效的存取，包装类型需要通过引用指向实例，具体的实例保存在堆中</li><li>初始值的不同，包装类型的初始值为 null ，基本类型的初始值视具体的类型而定，比如 int 的初始值为0；boolean 的初始值为 false</li><li>使用方法的不同，比如与集合类合作使用时(泛型)，只能使用包装类型</li></ul><hr><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><ul><li>在 Java 中，引用类型的变量非常类似于 C/C++ 的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了</li><li>引用数据类型包括：类、接口类型、数组类型、枚举类型、注解类型，字符串型；</li><li>所有引用类型的默认值都是 null</li></ul><hr><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>什么是类型转换？</p><p><strong>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></p><p>转换从低级到高级</p><blockquote><p>低————————————————————&gt;高</p><p>byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double </p></blockquote><p>数据类型转换必须满足如下规则：</p><ul><li><p>不能对boolean类型进行类型转换。</p></li><li><p>不能把对象类型转换成不相关类的对象。</p></li><li><p>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p></li><li><p>转换过程中可能导致溢出或损失精度，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">128</span>;   </span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;</span><br></pre></td></tr></table></figure><p>因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p></li><li><p>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span>)<span class="number">23.7</span> == <span class="number">23</span>;        </span><br><span class="line">(<span class="keyword">int</span>)-<span class="number">45.89f</span> == -<span class="number">45</span></span><br></pre></td></tr></table></figure></li></ul><p>类型转换分为：</p><ul><li><strong>自动类型转换</strong></li><li><strong>强制类型转换</strong></li></ul><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZiDongLeiZhuan</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">            <span class="keyword">char</span> c1=<span class="string">'a'</span>;<span class="comment">//定义一个char类型</span></span><br><span class="line">            <span class="keyword">int</span> i1 = c1;<span class="comment">//char自动类型转换为int</span></span><br><span class="line">            System.out.println(<span class="string">"char自动类型转换为int后的值等于"</span>+i1);</span><br><span class="line">            <span class="keyword">char</span> c2 = <span class="string">'A'</span>;<span class="comment">//定义一个char类型</span></span><br><span class="line">            <span class="keyword">int</span> i2 = c2+<span class="number">1</span>;<span class="comment">//char 类型和 int 类型计算</span></span><br><span class="line">            System.out.println(<span class="string">"char类型和int计算后的值等于"</span>+i2);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>自动类型转换为<span class="keyword">int</span>后的值等于<span class="number">97</span></span><br><span class="line"><span class="keyword">char</span>类型和<span class="keyword">int</span>计算后的值等于<span class="number">66</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong>：c1 的值为字符 <strong>a</strong> ,查 ASCII 码表可知对应的 int 类型值为 97， A 对应值为 65，所以 i2=65+1=66。</p><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>将高级别类型赋值给低级别类型时，必须进行强制类型转换。</p><ul><li>条件是转换的数据类型必须是兼容的。</li><li>格式：(type)value type是要强制类型转换后的数据类型。</li></ul><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li><p>Java 中有两大数据类型，基本数据类型和引用数据类型。</p><ul><li>基本数据类型在被创建时，在栈上给其划分一块内存，将<strong>数据直接存储在栈</strong>上.</li><li>引用数据类型在被创建时，首先要在栈上给其引用分配一块内存，而<strong>对象的具体信息都存储在堆</strong>上，然后由栈上面的引用指向堆中对象的地址。</li></ul></li><li><p>简答的说小类型可<strong>自动转换</strong>为大类型，大类型转小类型需要<strong>强制转换</strong>。</p></li></ul><p><img src="/2018/10/13/Java基础一/Java类型装换.jpg" alt="Java类型转换"></p><p>箭头指向的方向表示可以自动转换，箭头的相反方向需要强制转换，虚线所指向的内容可能发生精度的丢失。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 中有两大数据类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内置数据类型&lt;/li&gt;
&lt;li&gt;引用数据类型&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://cuizhe1023.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数据类型" scheme="https://cuizhe1023.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
</feed>
